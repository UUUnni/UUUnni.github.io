<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SDU计算机组成原理笔记</title>
    <link href="/2022/07/07/ComputerOrganizationReview/"/>
    <url>/2022/07/07/ComputerOrganizationReview/</url>
    
    <content type="html"><![CDATA[<h1 id="简答题整理"><a href="#简答题整理" class="headerlink" title="简答题整理"></a>简答题整理</h1><h2 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h2><h3 id="冯诺依曼计算机的特点"><a href="#冯诺依曼计算机的特点" class="headerlink" title="冯诺依曼计算机的特点"></a>冯诺依曼计算机的特点</h3><p>① 计算机由运算器、存储器、控制器、输入设备和输出设备五大部件组成</p><p>② 指令和数据以同等地位存于存储器内，并可按地址寻访</p><p>③ 指令和数据均用二进制代码表示</p><p>④ 指令由操作码和地址码组成，操作码表示操作的性质，地址码表示操作数在存储器中的位置</p><p>⑤ 指令在存储器内按顺序存放</p><p>⑥ 机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</p><h3 id="现代计算机的组成"><a href="#现代计算机的组成" class="headerlink" title="现代计算机的组成"></a>现代计算机的组成</h3><p>主机（主存储器    CPU（ALU    CU））</p><p>I/O设备</p><h2 id="第四章-存储器"><a href="#第四章-存储器" class="headerlink" title="第四章 存储器"></a>第四章 存储器</h2><h3 id="存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？"><a href="#存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？" class="headerlink" title="存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？"></a>存储器的层次结构主要体现在什么地方？为什么要分这些层次？计算机如何管理这些层次？</h3><p>体现在主存-缓存层次和主存-辅存层次</p><p>主存-缓存层次主要解决CPU和主存速度不匹配的问题，该层次的速度接近于缓存，而容量和单位成本接近于主存，解决了存储器的高速度和低成本之间的矛盾；主存-辅存层次主要解决存储系统的容量问题，该层次的速度接近于主存，而容量和单位成本接近于辅存，解决了存储器的大容量和低成本之间的矛盾</p><p>主存-缓存之间的数据调度由硬件完成，对程序员透明；主存-辅存之间的数据调度由硬件和操作系统共同完成</p><h3 id="什么叫刷新？说明刷新有几种方法？"><a href="#什么叫刷新？说明刷新有几种方法？" class="headerlink" title="什么叫刷新？说明刷新有几种方法？"></a>什么叫刷新？说明刷新有几种方法？</h3><p>为防止信息丢失，将DRAM的原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程叫做刷新</p><p>集中刷新：在规定的刷新周期内，对全部存储单元集中一段时间逐行刷新，该段时间内必须停止读写操作</p><p>分散刷新：对每行存储单元的刷新分散到每个存储周期内完成</p><p>异步刷新：结合集中刷新和分散刷新。存取周期不变，行间刷新时间间隔为刷新周期/行数</p><h3 id="简要说明提高访存速度可采取的措施"><a href="#简要说明提高访存速度可采取的措施" class="headerlink" title="简要说明提高访存速度可采取的措施"></a>简要说明提高访存速度可采取的措施</h3><p>使用高速器件</p><p>采用主存-缓存层次结构</p><p>调整主存结构，使用单体多字系统或多体并行系统</p><h2 id="第五章-输入输出系统"><a href="#第五章-输入输出系统" class="headerlink" title="第五章 输入输出系统"></a>第五章 输入输出系统</h2><h3 id="I-O设备有哪些编址方式，各有何特点？"><a href="#I-O设备有哪些编址方式，各有何特点？" class="headerlink" title="I/O设备有哪些编址方式，各有何特点？"></a>I/O设备有哪些编址方式，各有何特点？</h3><p>统一编址：在主存地址空间划出I/O地址，通过访存指令即可实现对I/O设备的访问</p><p>独立编址：I/O地址和主存地址分开，通过I/O指令实现对I/O设备的访问</p><h3 id="I-O设备与主机交换信息时，共有哪几种控制方式？简述它们的特点"><a href="#I-O设备与主机交换信息时，共有哪几种控制方式？简述它们的特点" class="headerlink" title="I/O设备与主机交换信息时，共有哪几种控制方式？简述它们的特点"></a>I/O设备与主机交换信息时，共有哪几种控制方式？简述它们的特点</h3><p>程序查询方式：主机与I/O设备串行工作。CPU启动I/O设备后，时刻查询I/O设备状态，若准备就绪则执行I/O指令，若未准备好就踏步等待直到准备就绪。</p><p>程序中断方式：主机与I/O设备并行工作。CPU启动I/O设备后，继续执行现行程序，当I/O设备准备就绪后向CPU发送中断请求信号，CPU响应中断请求后执行I/O指令。</p><p>DMA方式：主机与I/O设备并行工作，主存与I/O设备之间有一条直接的数据通路。CPU启动I/O设备后，继续执行现行程序，当I/O设备准备就绪后发出DMA请求，CPU把外部总线的使用权暂时交给DMA，不必中断现行程序，只需暂停一个存取周期的访存。</p><h3 id="什么是I-O接口，它与端口有何区别？"><a href="#什么是I-O接口，它与端口有何区别？" class="headerlink" title="什么是I/O接口，它与端口有何区别？"></a>什么是I/O接口，它与端口有何区别？</h3><p>I/O接口指主机和I/O设备间设置的硬件电路和相应的软件控制</p><p>I/O端口是指接口电路中存放数据信息、控制信息和状态信息的寄存器。</p><h3 id="简述I-O接口的功能和基本组成"><a href="#简述I-O接口的功能和基本组成" class="headerlink" title="简述I/O接口的功能和基本组成"></a>简述I/O接口的功能和基本组成</h3><p>功能：选址、传送数据、传送命令、反映设备状态</p><p>基本组成：设备选择电路、数据缓冲寄存器、命令寄存器和命令译码器、设备状态标记、控制逻辑电路</p><h3 id="结合程序查询方式的接口电路，说明其工作过程"><a href="#结合程序查询方式的接口电路，说明其工作过程" class="headerlink" title="结合程序查询方式的接口电路，说明其工作过程"></a>结合程序查询方式的接口电路，说明其工作过程</h3><p>①当CPU通过I/O指令启动I/O设备后，指令的设备码字段通过地址线进入设备选择电路</p><p>②若设备码与地址线上的代码吻合，则输出SEL为1</p><p>③I/O指令的启动命令通过与SEL与非运算，将D置0，B置1</p><p>④B触发器启动设备工作</p><p>⑤输入设备将数据送入数据缓冲寄存器</p><p>⑥设备工作结束后，将D置1，B置0</p><p>⑦D触发器发出准备就绪信号</p><p>⑧CPU将数据缓冲寄存器中的数据读出</p><h3 id="在什么条件和什么时间，CPU可以响应I-O的中断请求"><a href="#在什么条件和什么时间，CPU可以响应I-O的中断请求" class="headerlink" title="在什么条件和什么时间，CPU可以响应I/O的中断请求"></a>在什么条件和什么时间，CPU可以响应I/O的中断请求</h3><p>条件：允许中断触发器EINT=1，有中断请求INTR=1，未被屏蔽MASK=0</p><p>时间：一条指令执行结束时刻</p><h3 id="结合中断接口电路，说明其工作过程"><a href="#结合中断接口电路，说明其工作过程" class="headerlink" title="结合中断接口电路，说明其工作过程"></a>结合中断接口电路，说明其工作过程</h3><p>①由CPU发出启动I/O设备指令，将D置0，B置1</p><p>②B触发器启动设备工作</p><p>③输入设备将数据送入数据缓冲寄存器</p><p>④设备工作结束后，将D置1，B置0</p><p>⑤D发出设备准备就绪信号，且本设备未被屏蔽时发出中断查询信号</p><p>⑥设备向CPU发出中断请求，并送入排队其进行中断判优</p><p>⑦若CPU允许中断且设备被排队选中，则进入中断响应阶段，将排队器输出送至设备编码器形成向量地址</p><p>⑧向量地址送至PC，作为下一条指令的地址</p><p>⑨进入中断服务，CPU读出数据缓冲寄存器中的数据</p><p>⑩中断返回至源程序断点处</p><h3 id="试比较单重中断和多重中断服务程序的处理流程，说明它们不同的原因"><a href="#试比较单重中断和多重中断服务程序的处理流程，说明它们不同的原因" class="headerlink" title="试比较单重中断和多重中断服务程序的处理流程，说明它们不同的原因"></a>试比较单重中断和多重中断服务程序的处理流程，说明它们不同的原因</h3><div class="table-container"><table><thead><tr><th>单重中断</th><th>多重中断</th></tr></thead><tbody><tr><td>取指令</td><td>取指令</td></tr><tr><td>执行指令</td><td>执行指令</td></tr><tr><td>中断否？</td><td>中断否？</td></tr><tr><td>中断响应</td><td>中断响应</td></tr><tr><td>程序断点进栈</td><td>程序断点进栈</td></tr><tr><td>关中断</td><td>关中断</td></tr><tr><td>向量地址-&gt;PC</td><td>向量地址-&gt;PC</td></tr><tr><td>保护现场</td><td>保护现场</td></tr><tr><td></td><td>开中断</td></tr><tr><td>设备服务</td><td>设备服务</td></tr><tr><td>恢复现场</td><td>恢复现场</td></tr><tr><td>开中断</td><td></td></tr><tr><td>中断返回</td><td>中断返回</td></tr></tbody></table></div><p>区别：开中断指令安排的位置不同。</p><p>单重中断：开中断指令设置在最后中断返回之前，意味在整个中断服务程序中CPU不再响应其他中断源的请求</p><p>多重中断：开中断指令设置在保护现场之后，意味在保护现场后CPU可以再次响应级别更高的中断源请求</p><h3 id="解释周期挪用，分析周期挪用可能会出现的几种情况"><a href="#解释周期挪用，分析周期挪用可能会出现的几种情况" class="headerlink" title="解释周期挪用，分析周期挪用可能会出现的几种情况"></a>解释周期挪用，分析周期挪用可能会出现的几种情况</h3><p>每当I/O设备发出DMA请求时，I/O设备挪用总线使用权一个或几个主存周期</p><p>情况1：CPU此时不需要访存，I/O设备与CPU不发生冲突</p><p>情况2：CPU此时正在访存，等待存取周期结束后CPU才将总线使用权让出</p><p>情况3：CPU同时提出访存请求，发生冲突，DMA请求优先，挪用总线使用权</p><h3 id="DMA接口的功能和组成"><a href="#DMA接口的功能和组成" class="headerlink" title="DMA接口的功能和组成"></a>DMA接口的功能和组成</h3><p><strong>功能：</strong></p><p>向CPU申请DMA传送；</p><p>在CPU允许DMA工作时，处理总线控制权的转交；</p><p>在DMA期间管理系统总线，控制数据传送；</p><p>确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度；</p><p>数据块传送结束时，给出DMA操作完成的信号</p><p><strong>组成：</strong></p><p>主存地址寄存器AR：用于存放主存中需要交换数据的地址</p><p>字计数器WC：用于记录传送数据的总字数</p><p>数据缓冲寄存器BR：用于暂存每次传送的数据</p><p>DMA控制逻辑：负责管理DMA的传送过程</p><p>中断机构：向CPU提出中断请求，请求CPU做DMA的后处理</p><p>设备地址寄存器DAR：存放I/O设备的设备码或表示设备信息存储区的寻址信息</p><h3 id="结合DMA接口电路说明其工作过程"><a href="#结合DMA接口电路说明其工作过程" class="headerlink" title="结合DMA接口电路说明其工作过程"></a>结合DMA接口电路说明其工作过程</h3><p>(1) 预处理</p><p>指明数据传送方向</p><p>设备地址送入DMA接口中的DAR，并启动设备</p><p>主存起始地址送入DMA接口中的AR</p><p>传送数据个数送入DMA接口中的WC</p><p>(2) 数据传送</p><p>①设备准备好一个字后发出通选信号，将该字读到BR中/将BR中的输出数据送至设备中后发出通选信号</p><p>②与此同时向DMA接口发送请求DREQ</p><p>③DMA接口向总线申请使用权HRQ</p><p>④CPU发回HLDA信号，表示允许将总线控制权移交给DMA</p><p>⑤将DMA的AR中地址送地址总线命令存储器写/读</p><p>⑥通知设备已被授予一个DMA周期，为读下一个字做准备</p><p>⑦将DMA数据缓冲寄存器的内容送数据总线/主存将相应地址单元数据通过数据总线送入DMA的BR</p><p>⑧主存将数据总线上的信息写至地址总线指定的存储单元中/将DMA的数据缓冲寄存器的内容送到输出设备</p><p>⑨修改主存地址和字计数值</p><p>⑩判断数据块是否传送结束，若未结束则继续传送；若已结束则向CPU申请程序中断</p><p>(3) 后处理</p><p>执行中断服务程序</p><p>做DMA结束处理</p><h2 id="第七章-指令系统"><a href="#第七章-指令系统" class="headerlink" title="第七章 指令系统"></a>第七章 指令系统</h2><h3 id="试比较基址寻址和变址寻址"><a href="#试比较基址寻址和变址寻址" class="headerlink" title="试比较基址寻址和变址寻址"></a>试比较基址寻址和变址寻址</h3><p>两种寻址方式都可以扩大寻址范围</p><p>基址寻址的有效地址等于形式地址加上基址寄存器的内容；变址寻址的有效地址的等于形式地址加上变址寄存器的内容</p><p>基址寄存器的内容由操作系统给定，且在程序的执行过程中不可变；变址寄存器的内容由用户给定，且在程序的执行过程中可变</p><p>基址寻址用于为程序或数据分配存储空间；变址寻址用于处理数组程序</p><h2 id="第八章-CPU结构和功能"><a href="#第八章-CPU结构和功能" class="headerlink" title="第八章 CPU结构和功能"></a>第八章 CPU结构和功能</h2><h3 id="CPU的功能和结构"><a href="#CPU的功能和结构" class="headerlink" title="CPU的功能和结构"></a>CPU的功能和结构</h3><p>功能：指令控制、操作控制、时间控制、数据加工、处理中断</p><p>结构：寄存器（程序计数、存放指令地址、存放指令、存放操作数等）</p><p>​            CU（产生各种微操作命令序列）</p><p>​            ALU（算术和逻辑运算）</p><p>​            中断系统（处理异常情况和特殊请求）</p><h3 id="指令周期的流程，分别说明每个子周期的作用"><a href="#指令周期的流程，分别说明每个子周期的作用" class="headerlink" title="指令周期的流程，分别说明每个子周期的作用"></a>指令周期的流程，分别说明每个子周期的作用</h3><p>取指周期：取指令</p><p>间址周期：取有效地址</p><p>执行周期：完成执行指令的操作</p><p>中断周期：保存程序断点</p><h3 id="什么是中断隐指令，有哪些功能？"><a href="#什么是中断隐指令，有哪些功能？" class="headerlink" title="什么是中断隐指令，有哪些功能？"></a>什么是中断隐指令，有哪些功能？</h3><p>中断隐指令是指令系统中没有的指令，它由CPU在中断响应周期自动完成</p><p>功能：保护程序断点、寻找服务程序入口地址（硬件向量法和软件查询法）、硬件关中断</p><h2 id="第九、十章-控制单元"><a href="#第九、十章-控制单元" class="headerlink" title="第九、十章 控制单元"></a>第九、十章 控制单元</h2><h3 id="什么是指令周期、机器周期和时钟周期？三者有何关系"><a href="#什么是指令周期、机器周期和时钟周期？三者有何关系" class="headerlink" title="什么是指令周期、机器周期和时钟周期？三者有何关系"></a>什么是指令周期、机器周期和时钟周期？三者有何关系</h3><p>指令周期：取出并执行一条指令需要的全部时间</p><p>机器周期：所有指令执行过程中的基准时间</p><p>时钟周期：控制计算机操作的最小时间单位，其频率即为CPU主频</p><p>一个指令周期包含若干个机器周期，一个机器周期包含若干个时钟周期</p><h3 id="指令微操作及节拍安排"><a href="#指令微操作及节拍安排" class="headerlink" title="指令微操作及节拍安排"></a>指令微操作及节拍安排</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">PC-&gt;MAR现行指令地址-&gt;MAR<br><span class="hljs-number">1</span>-&gt;R命令存储器读<br>M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR现行指令从存储器中读至MDR<br>MDR-&gt;IR现行指令-&gt;IR<br>OP<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>CU指令的操作码-&gt;CU译码<br>(PC)+<span class="hljs-number">1</span>-&gt;PC形成下一条指令的地址<br></code></pre></div></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">T0PC-&gt;MAR,<span class="hljs-number">1</span>-&gt;R<br>T1M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR,(PC)+<span class="hljs-number">1</span>-&gt;PC<br>T2MDR-&gt;IR,OP<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>CU<br></code></pre></div></td></tr></table></figure><h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR指令的地址码字段-&gt;MAR<br><span class="hljs-number">1</span>-&gt;R命令存储器读<br>M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR有效地址从存储器中读至MDR<br></code></pre></div></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">T0Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR,<span class="hljs-number">1</span>-&gt;R<br>T1M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR<br></code></pre></div></td></tr></table></figure><h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><h5 id="取数LDA-X"><a href="#取数LDA-X" class="headerlink" title="取数LDA X"></a>取数LDA X</h5><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR指令的地址码字段-&gt;MAR<br><span class="hljs-number">1</span>-&gt;R命令存储器读<br>M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR操作数从存储器中读至MDR<br>MDR-&gt;ACC操作数-&gt;ACC<br></code></pre></div></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">T0Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR,<span class="hljs-number">1</span>-&gt;R<br>T1M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR<br>T2MDR-&gt;ACC<br></code></pre></div></td></tr></table></figure><h5 id="存数STA-X"><a href="#存数STA-X" class="headerlink" title="存数STA X"></a>存数STA X</h5><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR指令的地址码字段-&gt;MAR<br><span class="hljs-number">1</span>-&gt;W命令存储器写<br>ACC-&gt;MDR欲写入的数据-&gt;MDR<br>MDR-&gt;M(MAR)数据写至存储器中<br></code></pre></div></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">T0Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR,<span class="hljs-number">1</span>-&gt;W<br>T1ACC-&gt;MDR<br>T2MDR-&gt;M(MAR)<br></code></pre></div></td></tr></table></figure><h5 id="加法ADD-X"><a href="#加法ADD-X" class="headerlink" title="加法ADD X"></a>加法ADD X</h5><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR指令的地址码字段-&gt;MAR<br><span class="hljs-number">1</span>-&gt;R命令存储器读<br>M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR操作数从存储器读至MDR<br><span class="hljs-function"><span class="hljs-params">(ACC)</span>+<span class="hljs-params">(MDR)</span>-&gt;</span>ACC两数相加结果送ACC<br></code></pre></div></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">T1Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>MAR,<span class="hljs-number">1</span>-&gt;R<br>T2M<span class="hljs-function"><span class="hljs-params">(MAR)</span>-&gt;</span>MDR<br>T3<span class="hljs-function"><span class="hljs-params">(ACC)</span>+<span class="hljs-params">(MDR)</span>-&gt;</span>ACC<br></code></pre></div></td></tr></table></figure><h5 id="无条件转移JMP-X"><a href="#无条件转移JMP-X" class="headerlink" title="无条件转移JMP X"></a>无条件转移JMP X</h5><figure class="highlight livescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livescript">Ad<span class="hljs-function"><span class="hljs-params">(IR)</span>-&gt;</span>PC转移（目标）地址-&gt;PC<br></code></pre></div></td></tr></table></figure><h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean"><span class="hljs-number">0</span>-&gt;MAR特定地址<span class="hljs-number">0</span>-&gt;MAR<br><span class="hljs-number">1</span>-&gt;W命令存储器写<br>PC-&gt;MDRPC内容（程序断点）-&gt;MDR<br>MDR-&gt;M(MAR)程序断点写入<span class="hljs-number">0</span>地址单元中<br>向量地址-&gt;PC 向量地址形成部件的输出送至PC<br><span class="hljs-number">0</span>-&gt;EINT关中断将允许中断触发器置零<br></code></pre></div></td></tr></table></figure><figure class="highlight clean"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs clean">T0<span class="hljs-number">0</span>-&gt;MAR,<span class="hljs-number">1</span>-&gt;W<br>T1PC-&gt;MDR<br>T2MDR-&gt;M(MAR),向量地址-&gt;PC<br></code></pre></div></td></tr></table></figure><h3 id="微程序控制单元的设计思想"><a href="#微程序控制单元的设计思想" class="headerlink" title="微程序控制单元的设计思想"></a>微程序控制单元的设计思想</h3><p>若干条微命令组成一条微指令，控制实现一步操作</p><p>若干条微指令组成一段微程序，解释一条机器指令</p><p>每条机器指令对应一段微程序，微程序存放于控制存储器中</p><h3 id="微程序控制单元的组成"><a href="#微程序控制单元的组成" class="headerlink" title="微程序控制单元的组成"></a>微程序控制单元的组成</h3><ul><li><p>控制存储器：用来存放全部微程序</p></li><li><p>CMAR控存地址寄存器：用来存放于欲读出的微指令地址</p></li><li><p>CMDR控存数据寄存器：用来存放从控存读出的微指令</p></li><li><p>顺序逻辑：用来控制微指令序列</p></li><li><p>微地址形成部件</p></li><li><p>地址译码</p></li></ul><h3 id="微程序控制单元的工作原理"><a href="#微程序控制单元的工作原理" class="headerlink" title="微程序控制单元的工作原理"></a>微程序控制单元的工作原理</h3><p>根据机器指令的操作码，从控制存储器中找到与之对应的微程序的入口地址，取出微指令，发出微操作命令，形成下一条微指令的地址，以此类推……执行机器指令，以达到运行程序的目的</p><h3 id="微指令的操作控制有几种编码方式？各有何特点？哪一种控制速度最快？"><a href="#微指令的操作控制有几种编码方式？各有何特点？哪一种控制速度最快？" class="headerlink" title="微指令的操作控制有几种编码方式？各有何特点？哪一种控制速度最快？"></a>微指令的操作控制有几种编码方式？各有何特点？哪一种控制速度最快？</h3><p>直接编码：操作控制字段每一位代表一个微操作命令，执行速度最快</p><p>字段直接编码：将操作控制字段分为若干段，将一组互斥的微命令放在一个字段内，每段经译码后发出控制信号</p><p>字段间接编码：一个字段的某些微命令需由另一个字段中的某些微命令解释</p><p>混合编码：直接编码和字段编码混合使用</p><h3 id="微指令的地址有几种形成方式？"><a href="#微指令的地址有几种形成方式？" class="headerlink" title="微指令的地址有几种形成方式？"></a>微指令的地址有几种形成方式？</h3><p>①直接由微指令的下地址字段给出</p><p>②根据机器指令的操作码形成</p><p>③增量计数器</p><p>④分支转移</p><p>⑤通过测试网络形成</p><p>⑥由硬件直接产生微程序入口地址</p><h1 id="31猜计算题"><a href="#31猜计算题" class="headerlink" title="31猜计算题"></a>31猜计算题</h1><p>计算机性能有关计算 $f,MIPS,CPI,T_M=\sum^n_{i=1}f_it_i$</p><p>存储器与CPU连接 片选逻辑</p><p>Cache有关计算 命中率、主存系统效率</p><p>Cache与主存的映射</p><p>定点数加减法和溢出判断 浮点数加减</p><p>原码一位乘 补码一位乘</p><p>数据寻址 结合大端小端存储模式</p><p>指令格式设计 扩展编码技术</p><p>中断屏蔽字 CPU执行程序轨迹</p><p>指令微操作、微命令、控制信号、节拍分配</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>ComputerOrganization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU电子电路基础笔记</title>
    <link href="/2022/07/07/BasicElectronicCircuitNote/"/>
    <url>/2022/07/07/BasicElectronicCircuitNote/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-直流电路"><a href="#第一章-直流电路" class="headerlink" title="第一章 直流电路"></a>第一章 直流电路</h1><h2 id="Ⅰ-电路"><a href="#Ⅰ-电路" class="headerlink" title="Ⅰ 电路"></a>Ⅰ 电路</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>电路：构成电流通路的一切设备总和</li><li>电源：提供电能或电信号的设备和器件</li><li>负载：消耗电能或使用电信号的设备和器件</li><li>金属导线</li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ol><li>传送、分配和使用电能的电路，如照明电路、电力系统（强电）。</li><li>变换、传送、处理信号的电路，如各种控制系统、计算机等（弱电）。</li></ol><h2 id="Ⅱ-理想电路元件"><a href="#Ⅱ-理想电路元件" class="headerlink" title="Ⅱ 理想电路元件"></a>Ⅱ 理想电路元件</h2><p>无源元件<br>电阻R，电感L，电容C</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582864324052.png" alt="1582864324052" style="zoom: 67%;"></p><p>有源元件<br>独立电源，受控源</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582864396692.png" alt="1582864396692" style="zoom:50%;"></p><p>理想导线<br>允许任意强度的电流通过而不消耗或存储任何形式的能量。长度随意改变。</p><h3 id="电容的串并联"><a href="#电容的串并联" class="headerlink" title="电容的串并联"></a>电容的串并联</h3><p>串联：$\frac{1}{C}=\frac{1}{C_1}+\frac{1}{C_2}$</p><p>并联：$C=C_1+C_2$</p><h3 id="电感的串并联"><a href="#电感的串并联" class="headerlink" title="电感的串并联"></a>电感的串并联</h3><p>串联：$L=L_1+L_2$</p><p>并联：$\frac{1}{L}=\frac{1}{L_1}+\frac{1}{L_2}$</p><h2 id="Ⅲ-基本变量"><a href="#Ⅲ-基本变量" class="headerlink" title="Ⅲ 基本变量"></a>Ⅲ 基本变量</h2><h3 id="电流"><a href="#电流" class="headerlink" title="电流"></a>电流</h3><blockquote><p>电路中某处的电流的大小等于单位时间内通过该横截面的电荷量</p></blockquote><script type="math/tex; mode=display">i={dq\over dt}</script><h3 id="电压"><a href="#电压" class="headerlink" title="电压"></a>电压</h3><blockquote><p>AB两点的电压（端电压，电压降，电位差），定义为单位<strong>正</strong>电荷因受电场力作用从A点移动到B点所做的功。</p></blockquote><script type="math/tex; mode=display">u_{AB}={dw\over dq}</script><h3 id="电动势"><a href="#电动势" class="headerlink" title="电动势"></a>电动势</h3><blockquote><p>电源的两端具有电位差，具有把正电荷从低点位端（负端）移到高电位端（正端）的能力。</p></blockquote><p>交流电动势常用 $e(t)$ 或 $e$ 表示，直流电动势则用 $E$ 表示。</p><p>电动势的方向是从低点位端指向高电位端</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866108114.png" alt="1582866108114" style="zoom:67%;"></p><h3 id="功率"><a href="#功率" class="headerlink" title="功率"></a>功率</h3><blockquote><p>一段电路在单位时间之内得到或失去的能量</p></blockquote><p>在关联参考方向下，瞬时功率：</p><script type="math/tex; mode=display">p(t)={dw(t)\over dt}={dw(t)\over dq}\cdot{dq\over dt}=u(t)\cdot i(t)</script><p>在非关联参考方向上，瞬时功率：</p><script type="math/tex; mode=display">p(t)=-u(t)\cdot i(t)</script><p><strong>当 $p&gt;0$ 时，吸收功率；当 $p&lt;0$ 时，发出功率。</strong></p><p>对一完整的电路，满足：发出的功率=吸收的功率</p><h3 id="能量"><a href="#能量" class="headerlink" title="能量"></a>能量</h3><blockquote><p>电路在 $t_{1}$ 到 $t_{2}$ 的时间间隔内吸收/发出的电能量等于瞬时功率在该时间段内的积分。</p></blockquote><script type="math/tex; mode=display">w=\int_{t_1}^{t_2}p(t)dt=\int_{t_1}^{t_2}u(t)i(t)dt</script><h2 id="Ⅳ-电路参考方向"><a href="#Ⅳ-电路参考方向" class="headerlink" title="Ⅳ 电路参考方向"></a>Ⅳ 电路参考方向</h2><p>电流的<strong>实际</strong>方向指单位正电荷的移动方向<br>电流（电压）的<strong>参考</strong>方向可以任意选定</p><p>按参考方向进行分析计算，根据计算结果的正负确定其实际方向</p><h3 id="关联参考方向"><a href="#关联参考方向" class="headerlink" title="关联参考方向"></a>关联参考方向</h3><blockquote><p>元件或支路的u，i采用相同的参考方向称之为关联参考方向。<br>反之，称为非关联参考方向。</p></blockquote><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582864554335.png" alt="1582864554335" style="zoom: 67%;"></p><p><strong>关联参考方向一定是针对一段电路讨论</strong></p><h2 id="Ⅴ-基尔霍夫定律"><a href="#Ⅴ-基尔霍夫定律" class="headerlink" title="Ⅴ 基尔霍夫定律"></a>Ⅴ 基尔霍夫定律</h2><h3 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h3><p>支路，节点，回路，网孔</p><h3 id="基尔霍夫电流定律（KCL"><a href="#基尔霍夫电流定律（KCL" class="headerlink" title="基尔霍夫电流定律（KCL)"></a>基尔霍夫电流定律（KCL)</h3><p><strong>在任一瞬间，流出电路中任一结点的电流的代数和恒等于零，即：</strong></p><script type="math/tex; mode=display">\sum I=0</script><p><strong>约定：流入取负，流出取正。</strong></p><p>KCL可推广应用于电路中包围多个节点的任意闭合面</p><p>（1）KCL是电荷守恒和电流连续性原理在节点处的反映；<br>（2）KCL是对支路电流加的约束，与支路上接的元件无关，与电路是线性还是非线性无关；<br>（3）KCL方程是按电流参考方向列写，与电流实际方向无关。</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866146896.png" alt="1582866146896" style="zoom:67%;"></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866168800.png" alt="1582866168800" style="zoom:67%;"></p><h3 id="基尔霍夫电压定律（KVL）"><a href="#基尔霍夫电压定律（KVL）" class="headerlink" title="基尔霍夫电压定律（KVL）"></a>基尔霍夫电压定律（KVL）</h3><p><strong>在任一瞬间，沿任一回路绕行一周，各段电压降的代数和恒等于零。即：</strong></p><script type="math/tex; mode=display">\sum U=0</script><p><strong>约定：电压降的方向与回路绕行方向一致取正，反之取负。</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866255772.png" alt="1582866255772" style="zoom: 80%;"></p><h2 id="Ⅵ-迭加原理"><a href="#Ⅵ-迭加原理" class="headerlink" title="Ⅵ 迭加原理"></a>Ⅵ 迭加原理</h2><p><strong>在线性电路中，多个电源在某一支路产生的电流（或电压），等于各个电源单独作用时在该支路产生的电流（或电压）的代数和。</strong><br><strong>约定：与总量同向的分量取正，与总量反向的分量取负。</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866291883.png" alt="1582866291883" style="zoom:80%;"></p><h2 id="Ⅶ-等效变换"><a href="#Ⅶ-等效变换" class="headerlink" title="Ⅶ 等效变换"></a>Ⅶ 等效变换</h2><blockquote><p>两个二段网络$N_1$和$N_2$，当他们与同一个外部电路相接，在相接端点处的电压、电流关系完全相同，则称$N_1$和$N_2$是相互等效的二端网络。</p></blockquote><p><strong>有阻电压源$\Leftrightarrow$有阻电流源</strong></p><blockquote><p>有阻电压源<br>一个理想电源和一个电阻元件<strong>串联</strong></p><script type="math/tex; mode=display">U=E-IR_{su}</script><p>有阻电流源<br>一个理想电源和一个电阻元件<strong>并联</strong></p><script type="math/tex; mode=display">I=I_s-{U\over R_{si}}</script></blockquote><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866345406.png" alt="1582866345406" style="zoom: 67%;"></p><p><strong>等效互换</strong></p><script type="math/tex; mode=display">R_{su}=R_{si}=R_s</script><script type="math/tex; mode=display">E=I_sR_s</script><p><strong>注意：等效变换前后要保持电源方向一致，即电流源的电流方向是由电压源的$-\rightarrow+$(经内部）</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866369077.png" alt="1582866369077" style="zoom:80%;"></p><h2 id="Ⅷ-戴维南定理"><a href="#Ⅷ-戴维南定理" class="headerlink" title="Ⅷ 戴维南定理"></a>Ⅷ 戴维南定理</h2><blockquote><p>由线性元件构成的任意有源二端网络均可等效为一个有阻电压源。</p></blockquote><p><strong>等效有阻电压源的电动势 $E_0$ 等于二段网络的开路电压，内阻 $R_0$ 等于网络内的独立电源均为零（电压源短路，电流源开路）时网络的等效电阻。</strong></p><p><strong>PS. 对外等效</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1582866402991.png" alt="1582866402991" style="zoom:80%;"></p><h2 id="Ⅸ-电流分析方法"><a href="#Ⅸ-电流分析方法" class="headerlink" title="Ⅸ 电流分析方法"></a>Ⅸ 电流分析方法</h2><h3 id="支路电流法"><a href="#支路电流法" class="headerlink" title="支路电流法"></a>支路电流法</h3><blockquote><p>以支路电流为变量，根据基尔霍夫定律KCL、KVL，列电路方程组求解</p></blockquote><p><strong>PS：该法方程过多，慎用。</strong></p><ol><li>选定各支路电流参考方向</li><li><p>任选n-1个独立节点，按KCL列各节点电流方程</p></li><li><p>选取m-n+1个独立回路并规定回路方向，按KVL列回路电压方程</p></li><li>解方程，得到各支路电流</li></ol><h3 id="回路电流法"><a href="#回路电流法" class="headerlink" title="回路电流法"></a>回路电流法</h3><blockquote><p>以回路电流为变量，根据KVL列出电路方程组求解</p><p>回路电流：假设每个独立回路都有一个沿回路流动的电流</p></blockquote><ol><li>选取独立回路并规定回路电流。通常取网孔为独立回路，顺时针方向为回路电流方向</li><li>对各独立回路，按<strong>KVL</strong>写出回路电压方程</li><li>求解</li></ol><h4 id="含电流源的回路"><a href="#含电流源的回路" class="headerlink" title="含电流源的回路"></a>含电流源的回路</h4><p><strong><em>方法一：等效变换</em></strong></p><p>将有阻电流源等效变换为有阻电压源</p><p><strong><em>方法二：不做等效变换</em></strong></p><p><strong>情况1：电流源限制一个回路（边沿支路）</strong></p><p>可不写电流源所在回路的方程，但需要附加电流约束</p><p><strong>情况2：电流源限制多个回路（公共支路）</strong></p><p>增设电流源所在支路的电压，并考虑电流源对回路电流的约束</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1583805299879.png" alt="1583805299879"></p><h3 id="节点电压法"><a href="#节点电压法" class="headerlink" title="节点电压法"></a>节点电压法</h3><blockquote><p>选定参考点（通常选取连接支路较多的节点）。其余节点为独立节点。</p><p>各独立节点与参考节点间的电压分别称为对应节点电压。</p><p>节点电压的参考极性均以参考节点为负极性端，独立节点为正极性端。</p></blockquote><p>对每个独立节点根据<strong>KCL</strong>列方程</p><p>注意含电压源的支路电压计算</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1583805386475.png" alt="1583805386475" style="zoom: 67%;"></p><h1 id="第二章-正弦交流电"><a href="#第二章-正弦交流电" class="headerlink" title="第二章 正弦交流电"></a>第二章 正弦交流电</h1><h2 id="Ⅰ-交流电概述"><a href="#Ⅰ-交流电概述" class="headerlink" title="Ⅰ 交流电概述"></a>Ⅰ 交流电概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>正弦交流电是时间按照正弦函数规律变化的电压和电流。</p><p>由于交流电的大小和方向都是随时间不断变化的每一瞬间电压（电动势）和电流的数值都不相同。一般表示为$i(t),u(t)或i,u$。</p><h3 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h3><ol><li><p>三要素：频率、幅值、初相位（<strong>注意正弦函数和余弦函数</strong>）</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584059685706.png" alt="1584059685706" style="zoom:80%;"></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584059642932.png" alt="1584059642932" style="zoom: 67%;"></p></li><li><p>大小：瞬时值、最大值、有效值</p><blockquote><p>瞬时值：$e,i,u$</p><p>最大值：$E_m,I_m,U_m$。在选择电器的耐压时，必须考虑电压的最大值。</p><p>有效值：$E,I,U$。一个直流电流与一个交流电流分别通过阻值相等的电阻，如果通电的时间相等，在电阻上产生的热量也相等，那么直流电的数值就叫做交流电的有效值。一般电工仪表所测量的正弦量的值就是有效值。通常所说的交流电的电流、电压、电动势的值，如不做特殊说明都指有效值。</p></blockquote><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584059985621.png" alt="1584059985621" style="zoom: 80%;"></p></li><li><p>方向：相位、初相位、相位差</p><blockquote><p>相位：$wt+\varphi$是时间的函数，表示正弦量的变化进程，确定正弦量瞬时值的大小和方向。</p><p>初相位：$t=0$时的相位。</p><p>相位差：两个正弦量的相位之差，<strong>同频率</strong>的正弦电量的相位差等于其初相位之差，通常以$\varphi$表示。$(一般取-180^{\circ}\le180^{\circ})$</p></blockquote></li></ol><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584064623103.png" alt="1584064623103" style="zoom: 60%;"></p><h2 id="Ⅱ-复数运算"><a href="#Ⅱ-复数运算" class="headerlink" title="Ⅱ 复数运算"></a>Ⅱ 复数运算</h2><h3 id="1-复数及其表达形式"><a href="#1-复数及其表达形式" class="headerlink" title="1.复数及其表达形式"></a>1.复数及其表达形式</h3><p>（1) 代数形式</p><script type="math/tex; mode=display">实部和虚部：A=a+jb\\Re[A]=a\ \ \ \ \ Im[A]=b\\模：|A|=\sqrt{a^2+b^2}\\与实轴的夹角（幅角）：\varphi=tan^{-1}{b\over a}\\投影a、b和模的关系：\begin{cases}a=|A|cos\varphi\\b=|A|sin\varphi\end{cases}</script><p>（2）三角函数形式</p><script type="math/tex; mode=display">A=|A|cos\varphi+j|A|sin\varphi=|A|(cos\varphi+jsin\varphi)</script><p>（3）指数形式</p><script type="math/tex; mode=display">A=|A|e^{j\varphi}</script><p>（4）极坐标形式</p><script type="math/tex; mode=display">A=|A|\angle\varphi</script><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584065673550.png" alt="1584065673550" style="zoom: 60%;"></p><h3 id="2-复数运算"><a href="#2-复数运算" class="headerlink" title="2.复数运算"></a>2.复数运算</h3><p>设有两个复数$A=a_1+ja_2=a\angle\varphi_a=ae^{j\varphi_a},B=b_1+jb_2=b\angle\varphi_b=be^{j\varphi_b}$</p><p>（1）加减法</p><script type="math/tex; mode=display">C=A+B=(a_1+b_1)+j(a_2+b_2)\\C^,=A-B=(a_1-b_1)+j(a_2-b_2)</script><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584066032862.png" alt="1584066032862" style="zoom: 67%;"></p><p>（2）乘除法</p><script type="math/tex; mode=display">C=A\cdot B=ab\angle\varphi_a+\varphi_b=abe^{j(\varphi_a+\varphi_b)}\\C^,={A\over B}={ae^{j\varphi_a}\over be^{j\varphi_b}}={a\over b}\angle\varphi_a-\varphi_b</script><p>（3）旋转因子</p><script type="math/tex; mode=display">根据欧拉公式有e^{j{\pi\over2}}=cos({\pi\over2})+jsin({\pi\over2})=j</script><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584066325358.png" alt="1584066325358" style="zoom: 67%;"></p><p>注意：</p><p>相量的加减只能用代数形式运算</p><p>相量的乘除可以用代数形式或极坐标形式</p><p>因此，经常需要进行代数形式与极坐标形式的转换</p><h2 id="Ⅲ-正弦量的相量表示"><a href="#Ⅲ-正弦量的相量表示" class="headerlink" title="Ⅲ 正弦量的相量表示"></a>Ⅲ 正弦量的相量表示</h2><h3 id="1-分析示意图"><a href="#1-分析示意图" class="headerlink" title="1.分析示意图"></a>1.分析示意图</h3><blockquote><p>设有一正弦量$i=Isin(\omega t+{\varphi}_i)$，从该正弦量出发，最终推导出与它对应的相量，中间要用到复数作为过渡的桥梁。</p></blockquote><p><strong>PS. 相量中, $I$表示有效值，注意$\dot{I}$的写法</strong></p><p>①正弦量$\to$复数</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584060907162.png" alt="1584060907162" style="zoom:80%;"></p><p>② 复数$\to$相量</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584060980607.png" alt="1584060980607" style="zoom:80%;"></p><p>③ 正弦量$\to$相量</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584061008581.png" alt="1584061008581" style="zoom:80%;"></p><p><em>看一道例题帮助理解</em></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584061378253.png" alt="1584061378253" style="zoom:67%;"></p><h3 id="2-相量图及旋转相量"><a href="#2-相量图及旋转相量" class="headerlink" title="2.相量图及旋转相量"></a>2.相量图及旋转相量</h3><p><strong>（1）相量图</strong></p><blockquote><p>相量是一种特殊的复数，可在复平面上用矢量表示，这种相量在复平面上的几何表示图称为相量图。</p></blockquote><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584066563630.png" alt="1584066563630" style="zoom: 60%;"></p><p>· 同频率的正弦量所代表的相量可以画在同一复平面上。</p><p>· 按照平行四边形法则进行向量相加，从而完成正弦量的加减。</p><p><strong>（2）旋转相量</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584066916664.png" alt="1584066916664" style="zoom:60%;"></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584067014825.png" alt="1584067014825" style="zoom:60%;"></p><h3 id="3-相量的运算"><a href="#3-相量的运算" class="headerlink" title="3.相量的运算"></a>3.相量的运算</h3><p><strong>（1）加减法</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584067082060.png" alt="1584067082060" style="zoom:60%;"></p><p><strong>（2）微分</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584067207375.png" alt="1584067207375" style="zoom:60%;"></p><p><strong>（3）积分</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584067227343.png" alt="1584067227343" style="zoom: 60%;"></p><h3 id="4-电路分析的相量法"><a href="#4-电路分析的相量法" class="headerlink" title="4.电路分析的相量法"></a>4.电路分析的相量法</h3><blockquote><p>•    同频率的正弦量可用相量表示，对正弦量瞬时值成立的定理公式等，对相量同样成立，如基尔霍夫定律，叠加原理，戴维南定理等。<br>•    用相量表示正弦量，用复数运算完成相量的计算，就是电路分析的相量法。</p></blockquote><p><strong>优点：</strong></p><p>①把时域问题变为复数问题</p><p>②把微积分方程的运算变为复数方程运算</p><p>③可以把直流电路的分析方法直接用于交流电路</p><p><strong>注意：</strong></p><p>①只有正弦量才能用向量表示，非正弦量不可以</p><p>②只有同频率的正弦量才能画在一张向量图上，不同频率不行</p><p>③一般取直角坐标轴的水平正方向为参考方向，逆时针转动的角度为正，反之为负</p><p>④用向量表示正弦交流电后，他们的加减运算可按平行四边形法则进行</p><h2 id="Ⅳ-正弦交流电路中的电阻元件"><a href="#Ⅳ-正弦交流电路中的电阻元件" class="headerlink" title="Ⅳ 正弦交流电路中的电阻元件"></a>Ⅳ 正弦交流电路中的电阻元件</h2><h3 id="1-电压电流"><a href="#1-电压电流" class="headerlink" title="1.电压电流"></a>1.电压电流</h3><p>电阻两端电压u和电流i<strong>同频、同相，大小成比例</strong></p><p>电压与电流的有效值（或最大值）的关系符合欧姆定律 $U=IR$</p><p>用向量表示电压与电流的关系为 $\dot U=R\dot I$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584662817364.png" alt="1584662817364" style="zoom:67%;"></p><h3 id="2-瞬时功率"><a href="#2-瞬时功率" class="headerlink" title="2.瞬时功率"></a>2.瞬时功率</h3><script type="math/tex; mode=display">p=p_R=ui=U_msin\omega t\cdot I_msin\omega t=U_mI_msin^2\omega t=U_mI_m{1-cos2\omega t\over2}=UI(1-cos2\omega t)\geq 0</script><p>电阻只要有电流就消耗能量，它是一种耗能原件。</p><h3 id="3-平均功率"><a href="#3-平均功率" class="headerlink" title="3.平均功率"></a>3.平均功率</h3><script type="math/tex; mode=display">P={1\over T}\int_T p(t)dt={1\over T}\int_0^T(UI-UIcos2\omega t)dt=UI={U_mI_m\over2}=I^2R={U^2\over R}</script><p>式中的U，I是正弦交流电的有效值</p><h2 id="Ⅴ-正弦交流电路中的电感元件"><a href="#Ⅴ-正弦交流电路中的电感元件" class="headerlink" title="Ⅴ 正弦交流电路中的电感元件"></a>Ⅴ 正弦交流电路中的电感元件</h2><h3 id="1-线性电感"><a href="#1-线性电感" class="headerlink" title="1.线性电感"></a>1.线性电感</h3><p>磁链与电流成正比的元件。即 $\Psi = Li$，$L$是电感量，单位为亨利（H）</p><p>磁场能量：$w_L={1\over 2}Li^2$</p><h3 id="2-电压电流"><a href="#2-电压电流" class="headerlink" title="2.电压电流"></a>2.电压电流</h3><p>在电压电流<strong>关联参考方向</strong>下</p><script type="math/tex; mode=display">瞬时值：u(t)=-e(t)={d\Psi(t)\over dt}=L{di(t)\over dt}</script><p>设正弦电流为$i=I_msin\omega t$</p><script type="math/tex; mode=display">u=L{di\over dt}=LI_m{d(sin\omega t)\over dt}=\omega LI_mcos\omega t=\omega LI_msin(\omega t+90°)=U_msin(\omega t+90°)</script><p>由此可知，u和i是同频率的正弦量，<strong>电压的相位超前电流90°</strong>，数值上满足 $U_m=\omega LI_m$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584673386920.png" alt="1584673386920"></p><h3 id="3-感抗"><a href="#3-感抗" class="headerlink" title="3.感抗"></a>3.感抗</h3><p>电感具有对交流电流起阻碍作用的物理性质，称为感抗，记为$X_L$，与电阻同量纲，即</p><script type="math/tex; mode=display">X_L=\omega L=2\pi fL</script><p>当$f=0,X_L=0$时，“直流畅通，高频受阻”</p><p>用相量表示电压与电流的关系为：</p><script type="math/tex; mode=display">\dot U=jX_L\dot I=j\omega L\dot I</script><p>注意</p><p>①感抗只对<strong>正弦交流电</strong>有意义</p><p>②感抗等于电压和电流的<strong>有效值</strong>之比，对瞬时值无意义</p><p>③感抗与<strong>频率有关</strong>，对于直流稳态电感相当于短路</p><h3 id="4-瞬时功率"><a href="#4-瞬时功率" class="headerlink" title="4.瞬时功率"></a>4.瞬时功率</h3><script type="math/tex; mode=display">p=p_L=ui=U_msin(\omega t+90°)\times I_msin\omega t={1\over 2}U_mI_msin2\omega t=UIsin2\omega t</script><h3 id="5-平均功率"><a href="#5-平均功率" class="headerlink" title="5.平均功率"></a>5.平均功率</h3><script type="math/tex; mode=display">P={1\over T}\int_0^T(UIsin2\omega t)dt=0</script><p>电感<strong>不消耗</strong>平均功率（有功功率）</p><p>但是电感不断与电源进行能量交换，其瞬时功率不为零</p><p>纯电感条件下电路中仅用能量的交换而没有能量的损耗</p><h3 id="6-无功功率"><a href="#6-无功功率" class="headerlink" title="6.无功功率"></a>6.无功功率</h3><p>电感<strong>瞬时功率的最大值</strong>为电感吸收的无功功率，用$Q_L$表示，即：</p><script type="math/tex; mode=display">Q_L=UI=I^2X_L={U^2\over X_L}\ \ \ \ (var)</script><h2 id="Ⅵ-正弦交流电路中的电容元件"><a href="#Ⅵ-正弦交流电路中的电容元件" class="headerlink" title="Ⅵ 正弦交流电路中的电容元件"></a>Ⅵ 正弦交流电路中的电容元件</h2><h3 id="1-线性电容"><a href="#1-线性电容" class="headerlink" title="1.线性电容"></a>1.线性电容</h3><p>电荷量q与电压u成正比的电容元件。即 $q=Cu$</p><p>电容储存的电场能量： $w_E={1\over2}Cu^2$</p><h3 id="2-电压电流-1"><a href="#2-电压电流-1" class="headerlink" title="2.电压电流"></a>2.电压电流</h3><p>对于线性电容，电流与电压的导数（变化率）成正比</p><script type="math/tex; mode=display">瞬时值：i(t)={dq\over dt}=C{du(t)\over dt}</script><p>设正弦电压$u=U_msin\omega t$</p><script type="math/tex; mode=display">i=C{du\over dt}=CU_m{d(sin\omega t)\over dt}=\omega CU_mcos\omega t=\omega CU_msin(\omega t+90°)=I_msin(\omega t+90°)</script><p>由此知，u和i是同频率的正弦量，<strong>电流的相位超前电压90°</strong>，数值上满足：$I_m=\omega CU_m$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584672746467.png" alt="1584672746467"></p><h3 id="3-容抗"><a href="#3-容抗" class="headerlink" title="3.容抗"></a>3.容抗</h3><p>电容对交流电流起阻碍作用的物理性质，称为容抗，记为$X_C$，量纲与电阻相同</p><script type="math/tex; mode=display">X_C={1\over \omega C}={1\over 2\pi fC}</script><p>当 $f\to 0$ 时，电容相当于开路，“隔直通交”</p><p>用相量表示电压与电流的关系为：</p><script type="math/tex; mode=display">\dot{U}=-jX_C\dot I=-j{\dot I\over wC}={\dot I\over jwC}</script><p>$-jX_C$ 称为“复容抗”</p><h3 id="4-瞬时功率-1"><a href="#4-瞬时功率-1" class="headerlink" title="4.瞬时功率"></a>4.瞬时功率</h3><script type="math/tex; mode=display">p=ui=U_msin\omega t\times I_msin(\omega t+90)=U_mI_msin\omega t\times cos\omega t={U_mI_m\over 2}sin2\omega t=UIsin2\omega t</script><h3 id="5-平均功率-1"><a href="#5-平均功率-1" class="headerlink" title="5.平均功率"></a>5.平均功率</h3><script type="math/tex; mode=display">P=0</script><p>电容<strong>不消耗</strong>平均功率（有功功率）</p><p>但是电容不断与电源进行能量交换，其瞬时功率不为零</p><h3 id="6-无功功率-1"><a href="#6-无功功率-1" class="headerlink" title="6.无功功率"></a>6.无功功率</h3><script type="math/tex; mode=display">Q_C=-UI=-I^2X_C=-{U^2\over X_C} \ \ \ \ (var)</script><p>正负只是区别是感性无功还是容性无功</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584673324653.png" alt="1584673324653"></p><h2 id="Ⅶ-RLC串并联电路和复阻抗"><a href="#Ⅶ-RLC串并联电路和复阻抗" class="headerlink" title="Ⅶ RLC串并联电路和复阻抗"></a>Ⅶ RLC串并联电路和复阻抗</h2><h3 id="1-RLC串联电路"><a href="#1-RLC串联电路" class="headerlink" title="1.RLC串联电路"></a>1.RLC串联电路</h3><p><strong>电压电流关系</strong></p><p>由KVL，相量形式为</p><script type="math/tex; mode=display">\dot{U}=\dot{U}_R+\dot{U}_L+\dot{U}_C=[R+j(X_L-X_C)]\dot{I}=Z\dot I</script><p>$Z$为电路的“复阻抗”，$Z=R+jX=|Z|\ang \phi $，$Z={\dot{U}\over\dot{I}}$</p><h3 id="2-复阻抗"><a href="#2-复阻抗" class="headerlink" title="2.复阻抗"></a>2.复阻抗</h3><script type="math/tex; mode=display">Z=R+jX=|Z|\ang \phi</script><p>$|Z|$：复阻抗的模（阻抗）    $\phi$：复阻抗的幅角（阻抗角）    $R$：等效电阻    $X$：等效电抗</p><p>复阻抗是带角度的</p><h4 id="电压电流关系"><a href="#电压电流关系" class="headerlink" title="电压电流关系"></a>电压电流关系</h4><p>电压电流取关联方向，设$Z=|Z|\ang \phi,\ \ \dot{I}=I\ang\phi$</p><script type="math/tex; mode=display">\dot{U}=Z\dot{I}=|Z|\ang \phi\times I\ang\phi_i=|Z|I\ang(\phi_i+\phi)=U\ang\phi_u</script><p>电压电流关系$\begin{cases}大小：U=|Z|I\\相位：\phi=\phi_u-\phi_i\begin{cases}&gt;0,电压超前电流（电感性电路）\\=0,电压电流同相（纯阻性电路）\\&lt;0,电压滞后电流（电容性电路）\end{cases}\end{cases}$</p><h4 id="阻抗三角形"><a href="#阻抗三角形" class="headerlink" title="阻抗三角形"></a>阻抗三角形</h4><p>表示 $R,X,|Z|,\phi$ 关系的直角三角形</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584674563191.png" alt="1584674563191" style="zoom:40%;"></p><h4 id="电压三角形"><a href="#电压三角形" class="headerlink" title="电压三角形"></a>电压三角形</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/1584674870766.png" alt="1584674870766" style="zoom:40%;"></p><h4 id="复阻抗的串并联"><a href="#复阻抗的串并联" class="headerlink" title="复阻抗的串并联"></a>复阻抗的串并联</h4><p><strong>阻抗串联</strong></p><p>Z是串联阻抗的等效阻抗，等于各串联阻抗之和</p><script type="math/tex; mode=display">Z=Z_1+Z_2+......+Z_N\\|Z|\not=|Z_1|+|Z_2|+......+|Z_N|</script><p>N个串联复阻抗的分压公式为</p><script type="math/tex; mode=display">\dot{U_k}={Z_k\over\sum_{k=1}^NZ_k}\dot{U}</script><p><strong>阻抗并联</strong></p><p>并联电路的等效阻抗为</p><script type="math/tex; mode=display">Z={Z_1Z_2\over Z_1+Z_2}</script><p>并联复阻抗的分流公式为</p><script type="math/tex; mode=display">\begin{cases}\dot{I_1}={Z_2\over Z_1+Z_2}\dot{I}\\\dot{I_2}={Z_1\over Z_1+Z_2}\dot{I}\end{cases}</script><h2 id="Ⅷ-应用相量法计算正弦交流电路"><a href="#Ⅷ-应用相量法计算正弦交流电路" class="headerlink" title="Ⅷ 应用相量法计算正弦交流电路"></a>Ⅷ 应用相量法计算正弦交流电路</h2><p><strong>正弦交流电路的定律、公式在形式上与直流电路相同</strong></p><p>欧姆定律：$\dot U=Z\dot I$</p><p>KCL：$\sum\dot I=0$</p><p>KVL：$\sum\dot U=0$</p><p>叠加原理：各分量均为相量，总量为各分量的相量和</p><p>戴维南定理：等效电源为$\dot E_0,Z_0$</p><p>回路电流法：回路电流为相量，自阻、互阻为复数</p><p>节点电压法：节点电压为相量，自导、互导为复数</p><h2 id="Ⅸ-正弦交流电路的功率计算"><a href="#Ⅸ-正弦交流电路的功率计算" class="headerlink" title="Ⅸ 正弦交流电路的功率计算"></a>Ⅸ 正弦交流电路的功率计算</h2><h3 id="瞬时功率"><a href="#瞬时功率" class="headerlink" title="瞬时功率"></a>瞬时功率</h3><script type="math/tex; mode=display">p=ui=\sqrt2U\sin(\omega t+\phi)\cdot \sqrt2I\sin\omega t=UI\cos\phi-UI\cos(2\omega t+\phi)</script><p>$\phi$：阻抗角，电压和电流的相位差<br>$\phi=0$，电路只消耗能量<br>$\phi\not=0$，电路与电源有能量交换</p><h3 id="有功功率P（平均功率、功率）"><a href="#有功功率P（平均功率、功率）" class="headerlink" title="有功功率P（平均功率、功率）"></a>有功功率P（平均功率、功率）</h3><script type="math/tex; mode=display">P={1\over T}\int^T_0pdt={1\over T}\int^T_0[UI\cos\phi-UI\cos(2\omega t-\phi)]dt=UI\cos\phi</script><p><strong>$cos\phi$：电路的功率因数，[0,1]</strong></p><p>白炽灯看作纯电阻，$\cos\phi=1$</p><p>电路消耗的总有功功率等于电路中各电阻所消耗的有功功率之和</p><h3 id="无功功率Q"><a href="#无功功率Q" class="headerlink" title="无功功率Q"></a>无功功率Q</h3><p>$\phi\not=0$时，电路和电源之间交换功率的最大值</p><script type="math/tex; mode=display">p=UI\cos\phi-UI\cos(2\omega t+\phi)=UI\cos\phi-UI\cos\phi\cdot \cos2\omega t+UI\sin\phi\cdot \sin2\omega t\\UI\cos\phi-UI\cos\phi\cdot \cos2\omega t \to“消耗”的瞬时功率（电阻瞬时）\\UI\sin\phi\cdot \sin2\omega t \to 交换的瞬时功率（电抗无功）</script><p>无功功率：$Q=UI\sin\phi$</p><p>①无功功率可正可负，感性电路大于0，容性电路小于0</p><p>②电感无功和电容无功可相互抵消，电路所消耗的无功等于电路中各电抗元件所消耗的无功的代数和，$Q=\sum Q_L-\sum Q_C$（正-正）</p><h3 id="视在功率S"><a href="#视在功率S" class="headerlink" title="视在功率S"></a>视在功率S</h3><p>定义：$S=UI$为视在功率，单位为伏安（VA）</p><p>表示电源设备的供电能力，也称“容量”</p><p>家用电表按有功功率收费</p><h3 id="功率三角形"><a href="#功率三角形" class="headerlink" title="功率三角形"></a>功率三角形</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/1585271303183.png" alt="1585271303183" style="zoom:60%;"></p><h3 id="提高电路的功率因数"><a href="#提高电路的功率因数" class="headerlink" title="提高电路的功率因数"></a>提高电路的功率因数</h3><p>并联电容器，利用电容器中超前于电压的电流抵消感性负载消耗的无功电流分量</p><p>计算：</p><ul><li>通常给出：电源$(U,\omega)$，负载$(P,\cos\phi)$</li><li>要求达到：$\cos\phi^,$</li><li>求并接的电容$C$</li></ul><p>求解步骤：</p><p>①计算旧电路的无功功率</p><script type="math/tex; mode=display">Q_L=UI\sin\phi=U\cdot{P\over U\cos\phi}\cdot\sin\phi={P\over \cos\phi}\sqrt{1-\cos^2\phi}</script><p>②计算新电路的无功功率</p><script type="math/tex; mode=display">Q=UI\sin\phi´={P\over \cos\phi´}\sqrt{1-\cos^2\phi´}</script><p>③计算电容无功功率</p><script type="math/tex; mode=display">Q_C=Q-Q_L</script><p>④计算电容容量</p><script type="math/tex; mode=display">C={Q_C\over\omega U^2}={Q_C\over 2\pi fU^2}</script><h1 id="第三章-非正弦交流电路与电路中的过渡过程"><a href="#第三章-非正弦交流电路与电路中的过渡过程" class="headerlink" title="第三章 非正弦交流电路与电路中的过渡过程"></a>第三章 非正弦交流电路与电路中的过渡过程</h1><h2 id="Ⅰ-电路的过渡过程"><a href="#Ⅰ-电路的过渡过程" class="headerlink" title="Ⅰ 电路的过渡过程"></a>Ⅰ 电路的过渡过程</h2><h3 id="稳态"><a href="#稳态" class="headerlink" title="稳态"></a>稳态</h3><p><strong>直流电路：</strong>各支路电压电流保持恒定</p><p><strong>交流电路：</strong>各支路的电压电流的幅值、频率、变化规律等稳定不变</p><h3 id="过渡过程"><a href="#过渡过程" class="headerlink" title="过渡过程"></a>过渡过程</h3><p>当电路结构（开关通断）或元件参数发生变化（电源或其他元器件通断），可能会改变电路原来的工作状态，使得电路中的电压或电流由一种稳定状态转换成另一种稳定状态的过程。</p><p>电路的过渡过程必然性，电容上的电压和电感中的电流一般不能跃变。</p><h3 id="过渡过程的三种类型"><a href="#过渡过程的三种类型" class="headerlink" title="过渡过程的三种类型"></a>过渡过程的三种类型</h3><h4 id="零输入响应"><a href="#零输入响应" class="headerlink" title="零输入响应"></a><strong>零输入响应</strong></h4><p>在没有电源输入的情况下引起的电路中电压和电流的变化称为电路的零输入响应</p><p>电路中含有储能元件时就可能出现零输入响应</p><h5 id="时间常数-tau"><a href="#时间常数-tau" class="headerlink" title="时间常数$\tau$"></a><strong>时间常数$\tau$</strong></h5><p>①表示过渡过程进行快慢</p><p>​    $\tau$越大，电压电流的暂态变化越慢，反之，越快</p><p>​    $\tau$仅与电路内参数有关，与激励和初始状态无关</p><p>②一阶RC线性电路的零输入响应中，$t=\tau$时，电压$U_c$衰减到初始值的36.8%</p><p>​    理论上$t=\infty$才能达到稳定，即$U_c=0$</p><p>​    实际上$t=3\tau-5\tau$进入稳态</p><ul><li><p>一阶RC电路的零输入响应</p><script type="math/tex; mode=display">u_C(t)=U_0e^{-{t\over\tau}},i_C(t)={U_0\over R}e^{-{t\over\tau }},t\ge0_+\\\tau=RC</script></li><li><p>一阶RL电路的零输入响应</p><script type="math/tex; mode=display">i_L(t)=I_0e^{-{t\over\tau}},u_L=-RI_0e^{-{t\over\tau}},t\ge0_+\\\tau={L\over R}=GL</script></li><li><p>综上，<strong>零输入响应=初始值$\times e^{-{t\over\tau}},t\ge0_+$</strong>，R指所有电阻的等效电阻</p></li><li><p>求解过程分为三步骤：</p><ul><li>根据电路模型、元件属性和原始状态确定代求变量的初始值</li><li>根据换路后的电路模型确定电路的时间常数$\tau$</li><li>写出零输入响应</li></ul></li></ul><h4 id="零状态响应"><a href="#零状态响应" class="headerlink" title="零状态响应"></a>零状态响应</h4><p>电路中的储能元件的初始储能为零，完全由电源激励所产生的电路响应为零状态响应</p><ul><li><p>一阶RC电路零状态响应</p><script type="math/tex; mode=display">u_C(t)=U_s(1-e^{-{t\over\tau}}),i_C(t)=C{du_C(t)\over dt}={U_s\over R}e^{-{t\over\tau}}\\u_C(t)=RI_s(1-e^{-{t\over\tau}}),i_C=I_se^{-{t\over\tau}}</script></li><li><p>一阶RL电路的零状态响应</p></li></ul><script type="math/tex; mode=display">i_L(t)={U_s\over R}(1-e^{-{t\over\tau}}),u_L(t)=L{di_L(t)\over dt}=U_se^{-{t\over\tau}}</script><h4 id="全响应"><a href="#全响应" class="headerlink" title="全响应"></a>全响应</h4><p>输入和初始储能均不为零的电路，引起的电路响应</p><p>全响应=零输入响应+零状态响应</p><ul><li><p>一阶电路全响应</p><p>首先求零输入响应，然后求零状态响应</p></li></ul><script type="math/tex; mode=display">  u_C(t)=u_{ZI}(t)+u_{ZS}(t)=U_s+(U_0-U_s)e^{-{t\over\tau}}\\  i(t)=i_{ZI(t)}+i_{ZS}(t)=0+({U_s\over R}-{U_0\over R})e^{-{t\over\tau}}</script><h2 id="Ⅱ-换路定理"><a href="#Ⅱ-换路定理" class="headerlink" title="Ⅱ 换路定理"></a>Ⅱ 换路定理</h2><p>在换路瞬间，电容电压和电感电流不能突变</p><ol><li>具有电感的电路</li></ol><script type="math/tex; mode=display">i_L(0_+)=i_L(0_-)</script><ol><li>具有电容的电路</li></ol><script type="math/tex; mode=display">   u_C(0_+)=u_C(0_-)</script><p><strong>特别注意：</strong>除了$i_L,u_C$其他物理量可以发生突变，由电路结构决定</p><h2 id="Ⅲ-时域经典法"><a href="#Ⅲ-时域经典法" class="headerlink" title="Ⅲ 时域经典法"></a>Ⅲ 时域经典法</h2><p>根据KVL，KCL和元件的伏安特性建立描述电路的方程，然后再求解微分方程，得到所求变量的解，称为时域经典法。</p><script type="math/tex; mode=display">\star \ i_c=L{di\over dt}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \star u_c=C{du\over dt}</script><p><em>注意 i 与 u 的参考方向是否关联</em></p><p>微分方程的阶次称为电路的阶次</p><p>当得到的方程为一阶线性常系数微分方程，相应电路为一阶线性电路。</p><ul><li>电路中仅一个动态元件的电路是一阶电路。</li><li>若电路中的动态元件可以归结为一个动态元件的电路是一阶电路</li></ul><blockquote><script type="math/tex; mode=display">{dy\over dx}+p(x)y=Q(x)\\{dy\over dx}+p(x)y=0\ \ \ \ \ \ \ \ \ \ y=Ce^{-\int p(x)dx}\\y=Ce^{-\int p(x)dx}+{Q(x)\over p(x)}</script><p>C由初始值决定</p></blockquote><h2 id="Ⅳ-一阶电路的阶跃响应"><a href="#Ⅳ-一阶电路的阶跃响应" class="headerlink" title="Ⅳ 一阶电路的阶跃响应"></a>Ⅳ 一阶电路的阶跃响应</h2><p>单位阶跃函数用$\epsilon(t)$表示，其定义为：</p><script type="math/tex; mode=display">\epsilon(t)=\begin{cases}1,t>0\\0,t<0\end{cases}\\u_s(t)=U_s\epsilon(t)V</script><ul><li><p>应用1：描述某些情况下的开关动作</p></li><li><p>应用2：描述起始时间</p></li></ul><script type="math/tex; mode=display">  \epsilon(t-t_0)=\begin{cases}1,t-t_0\\0,t<t_0\end{cases}</script><ul><li>应用3：简洁地表示某些信号</li></ul><script type="math/tex; mode=display">  f(t)=A\epsilon(t)-A\epsilon(t-t_0)</script><p>当激励为$\epsilon(t)$时，电路的零状态响应称为单位阶跃响应，简称阶跃响应$g(t)$</p><p>（1）线性叠加性</p><script type="math/tex; mode=display">af_1(t)+bf_2(t)\to ay_{f_1}(t)+by_{f_2}(t)</script><p>（2）时不变性</p><script type="math/tex; mode=display">if:\ f(t)\to y_f(t)\\then:\ f(t-t_0)\to y_f(t-t_0)</script><h2 id="Ⅴ-求解一阶电路的三要素法"><a href="#Ⅴ-求解一阶电路的三要素法" class="headerlink" title="Ⅴ 求解一阶电路的三要素法"></a>Ⅴ 求解一阶电路的三要素法</h2><p>若用$f(t)$表示电压或电流，$f(0_+)$表示其换路后的初始值，$f(\infin)$表示其换路后的稳态值，用$\tau$表示电路的时间常数</p><script type="math/tex; mode=display">f(t)=f(\infin)+[f(0_+)-f(\infin)]e^{-{t\over\\tau}}</script><p><strong>初始值和稳态值的计算</strong></p><p>换路后的初态电路$\begin{cases}电容换成电压源\ E_C=u_C(0_+)\\电感换成电流源\ I_L=i_L(0_+)\end{cases}$</p><p>换路后的稳态电路$\begin{cases}电容开路\\电感短路\end{cases}$</p><h1 id="第四章-半导体基础"><a href="#第四章-半导体基础" class="headerlink" title="第四章 半导体基础"></a>第四章 半导体基础</h1><h2 id="Ⅰ-杂质半导体"><a href="#Ⅰ-杂质半导体" class="headerlink" title="Ⅰ 杂质半导体"></a>Ⅰ 杂质半导体</h2><p><strong>N型半导体</strong>：掺入5价元素，多子是电子，少子是空穴</p><p><strong>P型半导体</strong>：掺入3价元素，多子是空穴，少子是电子</p><p>注意：杂质半导体呈电中性</p><h3 id="PN结"><a href="#PN结" class="headerlink" title="PN结"></a>PN结</h3><p>一侧为P型半导体，另一侧为N型半导体，在它们的交界面就形成PN结</p><p>在N型和P型交界处，载流子的浓度差会引起扩散运动。P区的空穴向N区扩散，与其电子复合；N区的电子向P区扩散，与其空穴复合。使交界面附近的载流子消失，只剩下带电离子，形成不能移动的空间电荷区，这各电荷区就叫做PN结。此外，该区域多数载流子已扩散到对方并复合掉了，或者说消耗尽了，因此也叫耗尽层。</p><h3 id="PN结内电场"><a href="#PN结内电场" class="headerlink" title="PN结内电场"></a>PN结内电场</h3><p>方向由N区指向P区</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587088472408.png" alt="1587088472408" style="zoom:67%;"></p><h3 id="PN结的单向导电性"><a href="#PN结的单向导电性" class="headerlink" title="PN结的单向导电性"></a>PN结的单向导电性</h3><ol><li>PN结外加正向电压<strong>（P区接正，N区接负）</strong>，外电场与内电场方向相反，内电场被削弱，多子扩散得到加强，少子漂移被削弱，扩散电流大大超过漂移电流，使多子越过交界面形成正向电流（由P到N），形成较大的正向电流。<strong>（导通）</strong></li><li>PN结外加反向电压<strong>（P区接负，N区接正）</strong>，外电场与内电场方向一致，内电场增强，不利于多子的扩散，有利于少子的漂移，形成了基于少子飘逸的反向电流，由于少子数量很少，电路中基本无电流。<strong>（截止）</strong></li></ol><p><strong>结论</strong>：PN结具有单向导电性，正偏导通，反偏截止</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587088530476.png" alt="1587088530476" style="zoom:67%;"></p><h2 id="Ⅱ-半导体二极管的伏安特性"><a href="#Ⅱ-半导体二极管的伏安特性" class="headerlink" title="Ⅱ 半导体二极管的伏安特性"></a>Ⅱ 半导体二极管的伏安特性</h2><p>理论上，二极管的伏安特性就是PN结的伏安特性，PN结两端的电压$U_D$和电流$I_D$之间的关系：</p><script type="math/tex; mode=display">I_D=I_S(e^{\frac{qU_D}{kT}}-1)\\U_T=\frac{kT}{q},热电压\\I_D=I_S(e^{U_D\over U_T}-1)\\I_S反向饱和电流,U_D二极管两端电压降\\k=1.6\times10^{-19}C玻尔兹曼常数,q电子电荷,T绝对温度</script><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587089197902.png" alt="1587089197902" style="zoom:80%;"></p><h3 id="正向特性"><a href="#正向特性" class="headerlink" title="正向特性"></a>正向特性</h3><p>① 死区：正向电压$U_D$小于死区电压时，二极管截止，正向电流$I_D$约为0</p><p>② 导通区：$U_D&gt;U_{D(on)}$时，外加正向电压大于PN结内电场，阻挡层消失，二极管导通，$I_D$急剧增大。导通后二极管两端电压基本恒定。</p><p><strong>结论：</strong>正偏时电阻小，具有非线性，电路中一定要有限流电阻，不然因为电流过大损害二极管</p><h3 id="反向特性"><a href="#反向特性" class="headerlink" title="反向特性"></a>反向特性</h3><p>① 击穿：$U_D&gt;U_{BR}$，反向电流急剧增大，二极管失去单向导电性，对应的电压$U_{BR}$称为反向击穿电压</p><p>② 截止：$U_D&lt;U_{BR}$，反向电压的存在外电场增强内电场（阻止多子）。由于存在少子，会有一定的反向电流$I_D$。一定电压范围内，反向电流几乎不变，反向电流很小且近似为常数，称为反向饱和电流$I_S$</p><p><strong>结论：</strong>反偏电阻大，存在击穿现象</p><h3 id="温度对二极管的影响"><a href="#温度对二极管的影响" class="headerlink" title="温度对二极管的影响"></a>温度对二极管的影响</h3><p>随着温度的升高，其正向特性曲线左移，即导通电压减小；反向特性曲线下移，即反向饱和电流增大</p><h2 id="Ⅲ-二极管电路分析"><a href="#Ⅲ-二极管电路分析" class="headerlink" title="Ⅲ 二极管电路分析"></a>Ⅲ 二极管电路分析</h2><h3 id="理想模型"><a href="#理想模型" class="headerlink" title="理想模型"></a>理想模型</h3><p>忽略二极管的正向导通压降和反向漏电流</p><p>理想二极管 = 理想开关</p><ul><li>外加电压稍大于0，就导通，管压降为0V——开关闭合</li><li>当反偏时，二极管截止，其电阻为无穷大——开关断开</li></ul><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587089430760.png" alt="1587089430760" style="zoom:67%;"></p><h3 id="恒压模型"><a href="#恒压模型" class="headerlink" title="恒压模型"></a>恒压模型</h3><p>二极管正向压降与外加电压相比不能忽略，可用理想二极管和电压源E串联构成的模型来近似替代。导通管压降常称为“阈值电压”，用$V_\gamma$表示</p><p>小功率硅二极管通常取$V_\gamma=0.7V$，锗二极管通常取$V_\gamma=0.5V$，正向压降不再认为是0，而是接近实际工作电压的某一定值，且不随电流变化</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587089522625.png" alt="1587089522625" style="zoom:67%;"></p><p>解：先确定二极管工作状态：“设截止，算电压，定状态”</p><ul><li>先假定二极管截止，按二极管截止时的电路计算出二极管的端电压，再根据这个端电压确定二极管的工作状态</li><li>若端电压小于二极管的阈值电压$V_\gamma$，则二极管截止；否则，二极管导通</li></ul><h3 id="稳压二极管"><a href="#稳压二极管" class="headerlink" title="稳压二极管"></a>稳压二极管</h3><p>稳压管主要工作在反向击穿区，配合限流电阻可得到一个稳定的电压</p><ul><li><p>稳定电压$U_Z$</p><p>稳压管在反向击穿状态工作时的两端电压</p></li><li><p>稳定电流$I_Z$</p><p>反向击穿状态工作时的电流。最大值$I_{Zmax}=\frac {P_{ZM}}{U_Z}$，超过此值会烧坏管子；最小值$I_{Zmin}$，小于此值时，稳压二极管将失去稳压作用</p></li><li><p>动态电阻$r_Z$</p><p>稳压管子端电压和其电流的变化量之比，曲线越陡，则动态电阻越小，稳压效果越好，$r_Z=\frac{\Delta U_Z}{\Delta I_Z}$</p></li><li><p>最大允许耗散功率$P_{ZM}$</p><p>稳压管不发生热击穿的最大功率损耗。其值为稳定电压和允许的最大电流乘积。$P_{ZM}=U_Z\cdot I_{Zmax}$</p></li></ul><p>解：首先判断稳压二极管能否击穿，方法是假设稳压管断开，看$U_O$是否大于$U_Z$</p><h2 id="Ⅳ-半导体三极管"><a href="#Ⅳ-半导体三极管" class="headerlink" title="Ⅳ 半导体三极管"></a>Ⅳ 半导体三极管</h2><p>NPN型，PNP型</p><p>发射区、基区、集电区</p><p>发射极（e）、基极（b）、集电极（c）</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587687317643.png" alt="1587687317643" style="zoom: 60%;"></p><script type="math/tex; mode=display">I_e=I_c+I_b\\共发射极直流电流放大系数：\bar\beta=\frac{I_{cE}}{I_{bE}}\\I_{cbo}可以忽略时：\bar\beta=\frac{I_c}{I_b},I_e=(1+\bar\beta)I_b</script><h3 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h3><ul><li><p>直流静态电流放大系数$\bar\beta=\frac{I_CE}{I_BE}$</p><p>交流动态电流放大系数$\beta=\frac{\Delta I_{CE}}{\Delta I_{BE}}$</p></li><li><p>发射机开路时，集基极反向饱和电流$I_{CBO}$</p></li><li><p>基极开路时，集射极穿透电流$I_{CEO}$</p></li></ul><h3 id="特性曲线"><a href="#特性曲线" class="headerlink" title="特性曲线"></a>特性曲线</h3><ol><li><p>输入特性曲线（BE回路）</p><p>$I_{B}=f(U_{BE})|U_{CE}=c常数$</p><p>就是PN结的特性</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587690154036.png" alt="1587690154036" style="zoom:67%;"></p></li><li><p>输出特性曲线（CE回路）</p><p>$I_C=f(U_{CE})|I_B=c常数$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587690215473.png" alt="1587690215473" style="zoom:80%;"></p><ul><li><p>放大区</p><p>条件：e结正偏，c结反偏$(I_B&gt;0,U_{CE}\geqslant U_{BE})$</p><p>特点：$I_C=\beta I_B$</p></li></ul></li></ol><ul><li><p>饱和区</p><p>条件：e结正偏，c结正偏$(I_B&gt;0,U_{CE}&lt;U_{BE})$</p><p>特点：$I_C&lt;\beta I_B$；三个电极间电压很小，相当短路。</p></li><li><p>截止区</p><p>条件：e结反偏，c结反偏</p><p>特点：$I_B=0,I_C=I_{CEO}\approx 0$；三个电极间相当开路。</p></li></ul><h2 id="Ⅴ-晶体管的工作状态及电路模型"><a href="#Ⅴ-晶体管的工作状态及电路模型" class="headerlink" title="Ⅴ 晶体管的工作状态及电路模型"></a>Ⅴ 晶体管的工作状态及电路模型</h2><h3 id="截止"><a href="#截止" class="headerlink" title="截止"></a>截止</h3><p>发射结与集电结均处于反偏</p><ul><li><p>条件：$U_{BE}&lt;V_\gamma(V_{BES})$</p></li><li><p>特点：$I_B=0,I_C=0$</p></li><li><p>电路模型：各电极之间断开</p></li><li><p>输出电压：$U_0=U_{CE}=V_{CC}$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587694652176.png" alt="1587694652176" style="zoom:67%;"></p></li></ul><h3 id="放大"><a href="#放大" class="headerlink" title="放大"></a>放大</h3><p>发射结正偏，集电结反偏</p><ul><li><p>条件：$U_{BE}\geqslant V_\gamma,V_C&gt;V_B$</p></li><li><p>特点：$I_C=\beta I_B$</p></li><li><p>电路模型：发射结恒压（导通），集电结恒流（受控）</p></li><li><p>输出电压：$U_0=U_{CE}=V_{CC}-R_CI_C=V_{CC}-\beta R_CI_B$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587694998345.png" alt="1587694998345" style="zoom: 67%;"></p></li></ul><h3 id="饱和"><a href="#饱和" class="headerlink" title="饱和"></a>饱和</h3><p>发射结与集电结均处于正偏</p><ul><li><p>条件：$U_{BE}&gt;V_\gamma,V_C\leqslant V_B$，常用条件：$I_B\geqslant I_{BS}\approx \frac{V_{CC}}{\beta R_C}$</p></li><li><p>特点：$I_C=I_{CS}\approx \frac{V_{CC}}{R_C}$</p></li><li><p>电路模型：发射结恒压$(V_{BE}=V_\gamma)$，集电结恒压$(V_{CE}\approx 0)$</p></li><li><p>输出电压：$U_0=U_{CES}\approx 0$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587695482074.png" alt="1587695482074" style="zoom:67%;"></p></li></ul><h2 id="Ⅵ-晶体管工作状态分析"><a href="#Ⅵ-晶体管工作状态分析" class="headerlink" title="Ⅵ 晶体管工作状态分析"></a>Ⅵ 晶体管工作状态分析</h2><p>判定方法：先设截止，再查饱和，否则放大</p><ul><li><p>先由基极回路判定是否截止</p><ul><li><p>假定e结截止，计算电路加在e结上的电压$U_{BE}^´$</p></li><li><p>若$U_{BE}^´&lt;V_\gamma$，则e结截止，$I_B=0,U_{BE}=U_{BE}^´$</p></li><li><p>若$U_{BE}^´&gt;V_\gamma$，则e结导通，$U_{BE}=V_\gamma$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1587695854848.png" alt="1587695854848" style="zoom:80%;"></p></li></ul></li><li><p>若导通，检查是否饱和</p><ul><li>集电极饱和电流，$I_{CS}=\frac{V_{CC}-V_{CES}}{R_C}\approx \frac{V_{CC}}{R_C}$</li><li>临界饱和基极电流，$I_{BS}=\frac{I_{CS}}{\beta}=\frac{V_{CC}}{\beta R_C}$</li><li>若$I_B\geqslant I_{BS}$，则T饱和：$I_C=I_{CS},U_0=U_{CES}\approx 0$</li><li>若$I_B&lt;I_{BS}$，则T放大：$I_C=\beta I_B,U_0=V_{CC}-R_CI_C$</li></ul></li></ul><h1 id="第五章-基本交流放大电路"><a href="#第五章-基本交流放大电路" class="headerlink" title="第五章 基本交流放大电路"></a>第五章 基本交流放大电路</h1><h2 id="Ⅰ-晶体管基本交流放大电路"><a href="#Ⅰ-晶体管基本交流放大电路" class="headerlink" title="Ⅰ 晶体管基本交流放大电路"></a>Ⅰ 晶体管基本交流放大电路</h2><h3 id="电路组成"><a href="#电路组成" class="headerlink" title="电路组成"></a>电路组成</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/1588897410316.png" alt="1588897410316" style="zoom:60%;"></p><p>输入信号源、晶体三极管、输出负载以及直流电源和相应的偏置电路</p><ul><li><p>直流电源和相应的偏置电路用来为晶体三极管提供静态工作点，以保证晶体三极管工作在放大区</p></li><li><p>输出负载将电流的变化转变为电压的变化</p></li></ul><h4 id="共发射放大电路的组成"><a href="#共发射放大电路的组成" class="headerlink" title="共发射放大电路的组成"></a>共发射放大电路的组成</h4><ul><li><p><strong>晶体管T</strong>：放大元件，用基极电流$i_B$控制集电极电流$i_C$    $(i_c=\beta i_B)$</p></li><li><p><strong>电源$V_{CC}$和$E_B$</strong>：使晶体管的发射结正偏，集电结反偏，晶体管处在放大状态；同样是能量来源，提供$i_B,i_C$。一般是几伏到十几伏</p></li><li><p><strong>偏置电阻$R_B$</strong>：调节基极偏置电流 $I_B$，使晶体管有合适的工作点 ，一般为几十千欧到几百千欧</p></li><li><p><strong>集电极负载电阻$R_C$</strong>：将集电极电流的变化转变为电压的变化，以获得电压放大，一般为几千欧</p></li><li><p><strong>电容$C_1,C_2$</strong>：传递交流信号（耦合作用）。隔离直流信号。为了减少信号的电压损失，$C_1,C_2$应该足够大。极性电容（电解电容）</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1588898271807.png" alt="1588898271807" style="zoom:60%;"></p></li></ul><h4 id="三种基本组态放大器"><a href="#三种基本组态放大器" class="headerlink" title="三种基本组态放大器"></a>三种基本组态放大器</h4><p>共基极、共集电极、共发射极</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1588899551355.png" alt="1588899551355" style="zoom:67%;"></p><h3 id="放大原理"><a href="#放大原理" class="headerlink" title="放大原理"></a>放大原理</h3><ol><li><p><strong>无输入信号时放大器的工作情况</strong></p><p>当$u_i=0$时，放大电路处于静态或直流工作状态，此时的基极电流$I_B$、集电极电流$I_C$和集电极发射极电压$U_{CE}$在三极管特性曲线上所确定的点称为静态工作点，习惯上用Q表示</p><p>这些电压和电流值也称为静态电压和静态电流</p><p>静态工作点的设置是放大器能否正常工作的重要条件</p></li><li><p><strong>输入交流信号时的工作情况</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1588900023268.png" alt="1588900023268" style="zoom:50%;"></p></li></ol><h3 id="放大电路的分析方法"><a href="#放大电路的分析方法" class="headerlink" title="放大电路的分析方法"></a>放大电路的分析方法</h3><h4 id="静态分析（直流计算）"><a href="#静态分析（直流计算）" class="headerlink" title="静态分析（直流计算）"></a>静态分析（直流计算）</h4><p>计算放大电路在没有输入信号时的工作状态</p><ul><li><p>画直流通路——电容开路，电感短路；信号源不作用（电压源短路，电流源开路）</p></li><li><p>估算法</p><script type="math/tex; mode=display">I_{BQ}=\frac{V_{CC}-U_{BEQ}}{R_B}\approx\frac{V_{CC}-U_{BES}}{R_B}\\\ \\判断是否处于放大状态\\I_{CQ}=\beta I_{BQ}\\U_{CEQ}=V_{CC}-I_{CQ}R_C</script></li><li><p>图解法</p><ul><li><p>输入回路</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1588902033125.png" alt="1588902033125" style="zoom:50%;"></p></li><li><p>输出回路</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1588902091667.png" alt="1588902091667" style="zoom:50%;"></p><p>截止失真：$R_B$过大，$I_{BQ}$过小。发射结没有正向导通，三极管进入截止区。Q点过低，输出波形出现顶部失真</p><p>饱和失真：$R_B$过小，$I_{BQ}$过大。集电结没有反向偏置，三极管进入饱和区。Q点过高，输出波形出现底部失真</p></li><li><p>图解步骤</p><ul><li><p>估算法求出基极电流$I_{BQ}$</p></li><li><p>根据$I_{BQ}$在输出特性曲线中找到对应的曲线</p></li><li><p>作直流负载线</p><p>根据$U_{CE}=U_{CC}-I_CR_C$可画一条直线，其纵轴截距为$\frac{U_{CC}}{R_C}$，横轴截距为$U_{CC}$，斜率$-\frac{1}{R_C}$，只与负载电阻有关</p></li><li><p>求静态工作点Q并确定$U_{CEQ},I_{CQ}$的值</p><p>输出特性曲线和直流负载线的交点即为静态工作点Q，由Q可在坐标上查得$U_{CEQ},I_{CQ}$</p></li></ul></li></ul></li></ul><h4 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h4><p>一般只考虑交流分量，通常采用微变等效电路近似计算。</p><h5 id="晶体管的微变等效电路"><a href="#晶体管的微变等效电路" class="headerlink" title="晶体管的微变等效电路"></a>晶体管的微变等效电路</h5><p>小功率晶体管动态输入电阻的估算式$r_{be}=200+(1+\beta)\frac{26mV}{I_E(mA)}$</p><blockquote><p>$I_E$是发射极的静态电流，以毫安为单位</p><p>200Ω是小功率晶体管的基区体电阻</p><p>26mV是25°C时的温度电压当量值</p><p>小功率三极管的$r_{be}$一般为几百欧到几千欧</p></blockquote><p>输出用受控电流源$\beta i_b$表示</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589506761490.png" alt="1589506761490" style="zoom:60%;"></p><h5 id="晶体管放大电路的交流通路"><a href="#晶体管放大电路的交流通路" class="headerlink" title="晶体管放大电路的交流通路"></a>晶体管放大电路的交流通路</h5><p>输入交流信号时放大电路交流信号流通的路径</p><p>画交流通路——直流电源、电容短路</p><h5 id="放大电路与微变等效电路的转换"><a href="#放大电路与微变等效电路的转换" class="headerlink" title="放大电路与微变等效电路的转换"></a>放大电路与微变等效电路的转换</h5><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589509741055.png" alt="1589509741055" style="zoom:60%;"></p><ul><li><p>电压放大倍数$A_u=\frac{U_o}{U_i}$</p><ul><li><p>$R_L´=R_C//R_L$</p><p>$A_u=\frac{\dot{U_o}}{\dot{U_i}}=\frac{-R_L´\dot{I_c}}{r_{be}\dot{I_b}}=\frac{-R_L´\beta\dot{I_b}}{r_{be}\dot{I_b}}=-\frac{\beta R_L´}{r_{be}}$</p></li><li><p>空载放大倍数$A_{u0}$，$R_L=\infin$（开路）,$A_u=-\frac{\beta R_C}{r_{be}}$</p></li></ul><p>​        负载电阻越小，放大倍数越低，这是放大器的负载效应</p><ul><li>源载放大倍数$A_{us}$(考虑信号源内阻)</li></ul><p>​        $A_{us}=\frac{U_o}{U_s}=\frac{U_i}{U_S}\frac{U_o}{U_i}=\frac{r_i}{R_S+r_i}A_u$</p><p>​        信号源有内阻$R_S$时，放大器得到的输入电压小于信号源的电动势。</p></li><li><p>输入电阻$r_i=\frac{U_i}{I_i}$($r_i$越大越好)</p><p>微变等效电路$r_i=r_{be}//R_B\approx r_{be}$</p><p>注意：$r_i$是放大器的输入电阻，$r_{be}$是三极管的输入电阻</p></li><li><p>输出电阻$r_o$（$r_o$越小越好)</p><p>计算方法：信号源$U_S$短路，断开负载$R_L$，在输出端<strong>加</strong>电压$U_o$，求出由$U_o$产生的电流$I_o$，则输出电阻为$r_o=\frac{U_o}{I_o}$</p><p>微变等效电路$r_o=R_C$</p></li></ul><h2 id="Ⅱ-固定偏置放大电路"><a href="#Ⅱ-固定偏置放大电路" class="headerlink" title="Ⅱ 固定偏置放大电路"></a>Ⅱ 固定偏置放大电路</h2><p>固定偏置电路：由$R_B$提供偏流$I_B$，可以通过改变$R_B$的阻值来调整$I_B$的大小，从而获得合适的工作点</p><p>缺点：晶体管的电气参数受温度影响较大</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589511072398.png" alt="1589511072398" style="zoom:67%;"></p><script type="math/tex; mode=display">I_{BQ}=\frac{U_{CC}-U_{BEQ}}{R_B}=\frac{U_{CC}-0.7}{R_B}\approx\frac{U_{CC}}{R_B}\\I_{CQ}=\beta\times I_{BQ}+(1+\beta)I_{CBO}\\U_{CEQ}=U_{CC}-I_{CQ}\times R_C</script><h2 id="Ⅲ-分压式偏置放大电路"><a href="#Ⅲ-分压式偏置放大电路" class="headerlink" title="Ⅲ 分压式偏置放大电路"></a>Ⅲ 分压式偏置放大电路</h2><h4 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589511580940.png" alt="1589511580940" style="zoom:60%;"></p><script type="math/tex; mode=display">U_{BQ}=\frac{R_{b2}}{R_{b1}+R_{b2}}V_{CC}\\I_{CQ}\approx I_{EQ}=\frac{U_{BQ}-U_{BEQ}}{R_e}\approx \frac{U_{BQ}}{R_e}\\I_{BQ}=\frac{I_{CQ}}{\beta}\\U_{CEQ}=V_{CC}-I_{CQ}(R_c+R_e)</script><h4 id="交流分析"><a href="#交流分析" class="headerlink" title="交流分析"></a>交流分析</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589511730316.png" alt="1589511730316" style="zoom:45%;"></p><script type="math/tex; mode=display">A_u=-\frac{\beta R^´_L}{r_{be}}(R^´_L=R_C//R_L)\\R_i=r_{be}//R_{b1}//R_{b2}\approx r_{be}\\R_o=R_c</script><h2 id="Ⅳ-射极输出放大器"><a href="#Ⅳ-射极输出放大器" class="headerlink" title="Ⅳ 射极输出放大器"></a>Ⅳ 射极输出放大器</h2><p>射极输出器是共集电极（简称共集）组态的放大电路</p><h4 id="静态分析-1"><a href="#静态分析-1" class="headerlink" title="静态分析"></a>静态分析</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589512600247.png" alt="1589512600247" style="zoom:67%;"></p><script type="math/tex; mode=display">U_{CC}=I_{BQ}R_B+U_{BEQ}+I_{EQ}R_E=I_{BQ}R_B+U_{BEQ}+(1+\beta)I_{BQ}R_E\\I_{BQ}=\frac{U_{CC}-U_{BEQ}}{R_B+(1+\beta)R_E}\\I_{CQ}=\beta I_{BQ}\\U_{CEQ}=U_{CC}-I_{EQ}R_E\approx U_{CC}-I_{CQ}R_E</script><h4 id="动态分析-1"><a href="#动态分析-1" class="headerlink" title="动态分析"></a>动态分析</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/1589512852202.png" alt="1589512852202" style="zoom:60%;"></p><ul><li><p>求电压放大倍数</p><script type="math/tex; mode=display">A_u=\frac{U_o}{U_i}=\frac{(1+\beta)R^´_L}{r_{be}+(1+\beta)R^´_L}\\R^´_L=R_L//R_E</script></li><li><p>求输入电阻</p><script type="math/tex; mode=display">I_i=I_1+I_b=\frac{U_i}{R_B}+\frac{U_i}{r_{be}+(1+\beta)R^´_L}\\R_i=\frac{U_i}{I_i}=R_B//[r_{be}+(1+\beta)R^´_L]</script></li><li><p>求输出电阻</p><script type="math/tex; mode=display">I=I_b+\beta I_b+I_e=\frac{U}{r_{be}+R_s}+\beta\frac{U}{r_{be}+R_s}+\frac{U}{R_E}\\R_o=\frac{U}{I}=R_E//\frac{r_{be}+R^´_L}{1+\beta}200</script></li></ul><h1 id="第六章-集成运算放大器"><a href="#第六章-集成运算放大器" class="headerlink" title="第六章 集成运算放大器"></a>第六章 集成运算放大器</h1><ul><li><p>集成运放是一种直接耦合的多级放大器，放大倍数高达$10^4$以上，具有以下特性：</p><ul><li>可放大交流信号，也可以放大直流信号</li><li>差动输入，有两个输入端，利用对称性，有效抑制温漂和零漂</li><li>尽可能用有源器件代替无源器件</li></ul></li><li><p>集成运放通常由输入放大级、中间电压放大级、输出级及偏置电路等四部分组成</p></li><li><p>集成运放有两个输入端和一个输出端。反相输入端标’-‘号，同相输入端标’+’号。$V_o=A_0(V_{i+}-V_{i-})$</p><p>输出电压与反相输入电压相位相反，与同相输入电压相位相同</p></li></ul><p><img src="/2022/07/07/BasicElectronicCircuitNote/1590112365430.png" alt="1590112365430" style="zoom:50%;"></p><h2 id="差分放大电路"><a href="#差分放大电路" class="headerlink" title="差分放大电路"></a>差分放大电路</h2><p><img src="/2022/07/07/BasicElectronicCircuitNote/1590107937947.png" alt="1590107937947" style="zoom:50%;"></p><script type="math/tex; mode=display">u_{i1}=u_c+u_d\ \ \ \ u_{i2}=u_c-u_d\\共模信号u_c\ \ \ \ 差模信号u_d</script><ul><li>两个输入端分别输入大小相等、相位相反的信号，这种信号叫做差模信号，这时的放大倍数叫做差模增益$A_d=\frac{u_{od}}{u_d}$</li><li>两个输入端分别输入大小相等、相位相同的信号(有害)，这种信号叫做共模信号，这时的放大倍数叫做共模增益</li><li>电路对共模信号有很强的负反馈，所以共模放大倍数很小，一般小于1，$A_c=\frac{u_{oc}}{u_c}$</li></ul><h2 id="理想运算放大器"><a href="#理想运算放大器" class="headerlink" title="理想运算放大器"></a>理想运算放大器</h2><h4 id="满足条件"><a href="#满足条件" class="headerlink" title="满足条件"></a>满足条件</h4><ul><li><p>开环差模电压放大倍数    $A_{uo}=\infin$</p></li><li><p>差模输入电阻    $r_{id}\to\infin$</p></li><li><p>输出电阻    $r_o=0$</p></li><li><p>带宽    $BW\to\infin$</p></li><li><p>转换速率    $S_R\to\infin$</p></li><li><p>共模抑制比    $CMRR\to\infin$</p></li><li><p>无干扰和噪声，输入偏置电流，无温漂，失调电流均为0</p></li></ul><h4 id="传输特性"><a href="#传输特性" class="headerlink" title="传输特性"></a>传输特性</h4><blockquote><p>输出电压与输入电压之间的特性曲线</p></blockquote><p><img src="/2022/07/07/BasicElectronicCircuitNote/1590113849768.png" alt="1590113849768" style="zoom:50%;"></p><p><strong>线性区</strong></p><p>由于$A_{uo}=\infin$，输出电压为有限值，所以$u_{id}=u_+-u_-=u_o/A_{uo}\approx0$，即$u_-=u_+$，称为”虚短“</p><p>由于$r_{id}\to\infin$，有$i_-=i_+=u_{id}/r_{id}\approx0$，称为”虚断“</p><p><strong>饱和区</strong></p><p>输出电压为运放的正负饱和值$\pm U_{OM}$，该值略低于运放的正负电源的电压值</p><h2 id="运算放大器的基本应用电路"><a href="#运算放大器的基本应用电路" class="headerlink" title="运算放大器的基本应用电路"></a>运算放大器的基本应用电路</h2><h3 id="反相放大器"><a href="#反相放大器" class="headerlink" title="反相放大器"></a>反相放大器</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/1590113945333.png" alt="1590113945333" style="zoom: 50%;"></p><script type="math/tex; mode=display">\because I_i\approx0(虚断)\\\therefore i_1\approx i_f \\i_1=\frac{u_i-u_-}{R_1}\ \ \ \ i_f=\frac{u_--u_o}{R_f}\\\frac{u_i-u_-}{R_1}=\frac{u_--u_o}{R_f}\\\because u_-\approx u_+(虚短)=0(虚地)\\\therefore A_u=\frac{U_o}{U_i}=-\frac{R_F}{R_1}</script><p>负号表示$u_o$与$u_i$相位相反，所以称为反相放大器</p><p>$r_i=R_1,r_o=0$，输出电阻不受负载电阻影响</p><h3 id="同相放大器"><a href="#同相放大器" class="headerlink" title="同相放大器"></a>同相放大器</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/1590114930672.png" alt="1590114930672" style="zoom:50%;"></p><script type="math/tex; mode=display">\because I_i\approx0(虚断)\\\therefore i_1\approx i_f \\i_1=\frac{-u_-}{R_1}\ \ \ \ i_f=\frac{u_--u_o}{R_f}\\\frac{-u_-}{R_1}=\frac{u_--u_o}{R_f}\\\because u_-\approx u_+(虚短)=u_i\\\therefore A_u=\frac{V_o}{V_i}=1+\frac{R_F}{R_1}</script><p>正号表示$u_o$与$u_i$同相，且$A_u\ge1$。</p><p>$r_i\to\infin,r_o=0$</p><p>若$R_F=0$或$R_1\to\infin$，$A_u=1$，即$u_o=u_i$，电路变成电压跟随器</p><h3 id="减法器"><a href="#减法器" class="headerlink" title="减法器"></a>减法器</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529081002122.png" alt="image-20200529081002122" style="zoom: 50%;"></p><p>当$u_{i1}$单独作用时，$u_{o1}=-\frac{R_F}{R_1}u_{i1}$</p><p>当$u_{i2}$单独作用时，$u_{o2}=(1+\frac{R_F}{R_1})u_+=(1+\frac{R_F}{R_1})\frac{R_3}{R_2+R_3}u_{i2}$</p><script type="math/tex; mode=display">u_0=u_{o1}+u_{o2=}=(1+\frac{R_F}{R_1})\frac{R_3}{R_2+R_3}u_{i2}-\frac{R_F}{R_1}u_{i1}</script><p>当$R_1=R_2,R_3=R_F$时，$u_o=\frac{R_3}{R_1}(u_{i2}-u_{i1})$</p><p>当$R_1=R_2=R_3=R_F$时，$u_o=u_{i2}-u_{i1}$</p><p>$u_{i2}=0$（接地）时，减法器等效为反向比例放大器</p><h3 id="反相加法器"><a href="#反相加法器" class="headerlink" title="反相加法器"></a>反相加法器</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529084041090.png" alt="image-20200529084041090"></p><script type="math/tex; mode=display">U_-=U_+=0\\\ \\I_{i1}+I_{i2}+I_{i3}=\frac{U_{i1}-U_-}{R_1}+\frac{U_{i2}-U_-}{R_2}+\frac{U_{i3}-U_-}{R_3}=\frac{U_{-}-U_o}{R_f}\\\ \\U_o=-(\frac{R_f}{R_1}U_{i1}+\frac{R_f}{R_2}U_{i2}+\frac{R_f}{R_3}U_{i3})</script><p>当$R_1=R_2=R_3=R$时，$U_o=-\frac{R_f}{R}(U_{i1}+U_{i2}+U_{i3})$</p><p>改变某一输入回路的电阻时，仅改变输出电压与该路输入电压之间的比例，对其他各路无影响，调节灵活方便。</p><h3 id="同向加法器"><a href="#同向加法器" class="headerlink" title="同向加法器"></a>同向加法器</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529084516314.png" alt="image-20200529084516314" style="zoom:80%;"></p><script type="math/tex; mode=display">I_f=I_{R_1}\\U_{-}=\frac{R_1}{R_1+R_f}U_o\\I_{i1}+I_{i2}+I_{i3}=\frac{U_{i1}-U_+}{R^´_1}+\frac{U_{i2}-U_+}{R^´_2}+\frac{U_{i3}-U_+}{R^´_3}=\frac{U_+}{R^´}\\\because U_+=U_-\\\therefore U_+=\frac{R_+}{R^´_1}U_{i1}+\frac{R_+}{R^´_2}U_{i2}+\frac{R_+}{R^´_3}U_{i3}\\(R_+=R^´_1//R^´_2//R^´_3//R^´)\\\therefore U_o=(1+\frac{R_f}{R_1})(\frac{R_+}{R^´_1}U_{i1}+\frac{R_+}{R^´_2}U_{i2}+\frac{R_+}{R^´_3}U_{i3})</script><p>改变某一输入回路的电阻时，其他支路的比例关系也有所改变，调节麻烦</p><h2 id="电压比较器"><a href="#电压比较器" class="headerlink" title="电压比较器"></a>电压比较器</h2><p>按理想情况分析</p><p>若$U_-&gt;U_+$，则$U_o=-U_{OM}$</p><p>若$U_-&lt;U_+$，则$U_o=+U_{OM}$</p><h3 id="非零电平比较器"><a href="#非零电平比较器" class="headerlink" title="非零电平比较器"></a>非零电平比较器</h3><p>若$u_i$从同相端输入（同相电压比较器）</p><p>当$u_i&gt;u_R$时，$u_o=+U_{om}$；当$u_i&lt;u_R$时，$u_o=-U_{om}$</p><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529092344419.png" alt="image-20200529092344419" style="zoom: 50%;"></p><p>若$u_i$从反相端输入（反相电压比较器）</p><p>当$u_i<u_R$时，$u_o=+U_{om}$；当$u_i>u_R$时，$u_o=-U_{om}$</u_R$时，$u_o=+U_{om}$；当$u_i></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529092454429.png" alt="image-20200529092454429" style="zoom:50%;"></p><h3 id="零电平比较器"><a href="#零电平比较器" class="headerlink" title="零电平比较器"></a>零电平比较器</h3><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529092148928.png" alt="image-20200529092148928" style="zoom: 50%;"></p><h3 id="迟滞比较器-滞回比较器、滞环比较器、施密特触发器"><a href="#迟滞比较器-滞回比较器、滞环比较器、施密特触发器" class="headerlink" title="迟滞比较器(滞回比较器、滞环比较器、施密特触发器)"></a>迟滞比较器(滞回比较器、滞环比较器、施密特触发器)</h3><h4 id="反向滞回比较器（下行）"><a href="#反向滞回比较器（下行）" class="headerlink" title="反向滞回比较器（下行）"></a>反向滞回比较器（下行）</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200529095310838.png" alt="image-20200529095310838" style="zoom:50%;"></p><p>当$u_i\to -\infty$，$u_o$正饱和$(u_o=+U_{OM})$，$U_+=\frac{R_1}{R_1+R_2}U_{om}=U_{+H}$</p><p>当$u_i\to +\infty$，$u_o$负饱和$(u_o=-U_{OM})$，$U_+=-\frac{R_1}{R_1+R_2}U_{om}=U_{+L}$</p><p>$U_{+H}$上门限电压    $U_{+L}$下门限电压    $U_{+H}-U_{+L}$称为回差</p><p><strong>加上参考电压后</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200605084450122.png" alt="image-20200605084450122" style="zoom: 60%;"></p><script type="math/tex; mode=display">U_{+H}=\frac{R_1}{R_1+R_2}U_{om}+\frac{R_2}{R_1+R_2}U_R\\U_{+L}=-\frac{R_1}{R_1+R_2}U_{om}+\frac{R_2}{R_1+R_2}U_R</script><h4 id="同相滞回比较器（上行）"><a href="#同相滞回比较器（上行）" class="headerlink" title="同相滞回比较器（上行）"></a>同相滞回比较器（上行）</h4><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200605084814911.png" alt="image-20200605084814911" style="zoom:60%;"></p><script type="math/tex; mode=display">当u_o=-U_{OM}\\令\frac{R_2}{R_1+R_2}u_i-\frac{R_1}{R_1+R_2}U_{om}=0\\则u_i=U_{+H}=\frac{R_1}{R_2}U_{om}</script><script type="math/tex; mode=display">当u_o=+U_{OM}\\令\frac{R_2}{R_1+R_2}u_i+\frac{R_1}{R_1+R_2}U_{om}=0\\则u_i=U_{+L}=-\frac{R_1}{R_2}U_{om}</script><p><strong>加上参考电压后</strong></p><p><img src="/2022/07/07/BasicElectronicCircuitNote/image-20200605085000842.png" alt="image-20200605085000842" style="zoom:60%;"></p><script type="math/tex; mode=display">当u_o=-U_{OM}\\令\frac{R_2}{R_1+R_2}u_i-\frac{R_1}{R_1+R_2}U_{om}=U_R\\则u_i=U_{+H}=\frac{R_1}{R_2}U_{om}+\frac{R_1+R_2}{R_2}U_R</script><script type="math/tex; mode=display">当u_o=+U_{OM}\\令\frac{R_2}{R_1+R_2}u_i+\frac{R_1}{R_1+R_2}U_{om}=U_R\\则u_i=U_{+L}=-\frac{R_1}{R_2}U_{om}+\frac{R_1+R_2}{R_2}U_R</script>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>ElectronicCircuit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU计算机网络复习笔记</title>
    <link href="/2022/07/07/ComputerNetworkReview/"/>
    <url>/2022/07/07/ComputerNetworkReview/</url>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>对等实体间的通信规则</p><h4 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h4><p>层和协议的集合</p><h4 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h4><p>一个特定的系统所使用的一组协议，即每一层一个协议</p><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>指下层为相邻上层提供的功能调用</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>连接分散计算机设备以实现资源共享和信息传递的计算机系统</p><h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><p>传输控制协议/网际协议。是指能够在多个不同网络间实现信息传输的协议簇</p><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>把多个信号组合起来在一条物理信道上进行传输</p><h4 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h4><p>地址解析协议。根据IP地址获得MAC地址的TCP/IP协议</p><h4 id="对等通信P2P"><a href="#对等通信P2P" class="headerlink" title="对等通信P2P"></a>对等通信P2P</h4><p>各主机地位相等，通过直接交换来共享计算机资源和服务</p><h4 id="汇集树"><a href="#汇集树" class="headerlink" title="汇集树"></a>汇集树</h4><p>从所有源节点到一个指定目的节点的最佳路径形成的以目的节点为根的树</p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><p>单位时间内能够传输的数据量</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>域名系统。是将域名和IP地址相互映射的一个分布式数据库</p><h4 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h4><p>网络地址转换。为缓解IPv4地址短缺问题，每个局域网有专用的内部IP地址，当内网中的主机要访问外网时，路由器通过NAT转换为公网IP，才能和因特网连接</p><h4 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h4><p>非对称数字用户线。上下行带宽不一致</p><h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4><p>将两个不同协议的数据重新封装在新的包头中通过互联网络传递</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><p>发送的数据可以让该网络中的所有其他主机接收到</p><h4 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h4><p>一个发送者与多个接收者实现点对多点通信</p><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><p>生存时间。一个IP数据报在网络中能够被路由器转发的最大跳数</p><h4 id="服务质量"><a href="#服务质量" class="headerlink" title="服务质量"></a>服务质量</h4><p>描述网络能够提供的服务能力或网络应用的要求</p><p>常用的参数有：带宽、抖动、延迟抖动、丢失率</p><h4 id="通信子网"><a href="#通信子网" class="headerlink" title="通信子网"></a>通信子网</h4><p>网络中实现网络通信功能的设备及其软件的集合</p><h4 id="资源子网"><a href="#资源子网" class="headerlink" title="资源子网"></a>资源子网</h4><p>网络中实现数据处理的资源及网络服务</p><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h4 id="什么是介质访问控制问题"><a href="#什么是介质访问控制问题" class="headerlink" title="什么是介质访问控制问题"></a>什么是介质访问控制问题</h4><p>当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题</p><h4 id="CSMA协议的工作原理"><a href="#CSMA协议的工作原理" class="headerlink" title="CSMA协议的工作原理"></a>CSMA协议的工作原理</h4><p>发送数据前监听信道，若信道忙则不发送数据等待，若信道空闲则可以发送数据</p><p>又有1-坚持CSMA，0-坚持CSMA，p-坚持CSMA</p><h4 id="CSMA-CD协议的工作原理"><a href="#CSMA-CD协议的工作原理" class="headerlink" title="CSMA/CD协议的工作原理"></a>CSMA/CD协议的工作原理</h4><p>带冲突检测的载波监听多路访问</p><p>发送数据前监听信道，若信道忙则等待；若信道空闲则发送数据。</p><p>发送数据过程中持续监听信道，若检测到信道有冲突，则立刻停止发送数据，采用二进制指数后退算法等待一段时间后重发数据。</p><h4 id="CSMA-CA协议的工作原理"><a href="#CSMA-CA协议的工作原理" class="headerlink" title="CSMA/CA协议的工作原理"></a>CSMA/CA协议的工作原理</h4><p>带冲突避免的载波监听多路访问</p><p>发送数据前监听信道，若信道忙则等待；若信道空闲则随机后退后发送数据，发送完毕后若收到确认则发送成功，若在规定时间内没有收到确认则要以二进制指数后退重发该帧。</p><p>而在发送真实数据之前要进行信道预约，源端发送短帧RTS给目的端，目的端收到后发送短帧CTS给源端，源端收到该帧后才开始发送数据。这个过程中若其他节点收到RTS和CTS就会停止监听推迟接入到无线局域网中</p><h4 id="为什么无线局域网不能应用CSMA-CD"><a href="#为什么无线局域网不能应用CSMA-CD" class="headerlink" title="为什么无线局域网不能应用CSMA/CD"></a>为什么无线局域网不能应用CSMA/CD</h4><p>对于无线传输介质，接收信号强度往往小于发送信号强度，而且信号强度动态变化范围很广，若要实现碰撞检测则硬件开销过大</p><p>在无线通信中，不是所有的站点都能够听见对方</p><h4 id="TCP和IP两种协议的区别"><a href="#TCP和IP两种协议的区别" class="headerlink" title="TCP和IP两种协议的区别"></a>TCP和IP两种协议的区别</h4><p>TCP是面向连接的可靠的基于IP的传输层协议，实现应用进程间端对端的通信</p><p>IP是无连接的不可靠的网络层协议，规定了数据传输时的基本单元和格式，定义了数据报的递交办法和路由选择</p><h4 id="路由器IP层执行的分组转发算法"><a href="#路由器IP层执行的分组转发算法" class="headerlink" title="路由器IP层执行的分组转发算法"></a>路由器IP层执行的分组转发算法</h4><p>当路由器接收到IP数据报后，检查IP数据报首部是否出错，若出错则丢弃并通知源主机；若正确则继续转发</p><p>根据报文的目的IP地址，逐条检查路由表，若有匹配路由，则选择最长前缀匹配转发；</p><p>若没有匹配路由但有默认路由，则按默认路由转发；</p><p>若没有匹配路由且没有默认路由，则丢弃并通知源主机</p><h4 id="叙述具有五层协议的网络体系结构的要点，包括各层的主要功能"><a href="#叙述具有五层协议的网络体系结构的要点，包括各层的主要功能" class="headerlink" title="叙述具有五层协议的网络体系结构的要点，包括各层的主要功能"></a>叙述具有五层协议的网络体系结构的要点，包括各层的主要功能</h4><p>应用层：通过应用进程间的交互来实现特定网络应用</p><p>传输层：实现不同应用进程间端到端的通信</p><p>网络层：选择合适的路由实现分组在多个网络间的传输</p><p>数据链路层：在一段链路上无差错地传输以帧为单位的数据，每帧包括数据和必要的控制信息</p><p>物理层：实现比特流的透明可靠传输，并定义电缆插头及连接方法</p><h4 id="内部网关协议RIP的工作原理"><a href="#内部网关协议RIP的工作原理" class="headerlink" title="内部网关协议RIP的工作原理"></a>内部网关协议RIP的工作原理</h4><p>利用距离矢量算法，每个路由器维护一张状态表，表中列出当前已知的到每个目标的最佳距离以及使用的链路</p><p>初始状态，路由器仅知道自己到直连网络的跳数为1；每个路由器周期性地和自己的邻居交换并更新路由信息；若干次后每个路由器都会知道到达本自治系统的其他网络的最佳链路</p><h4 id="链路状态路由协议的工作原理"><a href="#链路状态路由协议的工作原理" class="headerlink" title="链路状态路由协议的工作原理"></a>链路状态路由协议的工作原理</h4><p>每个路由器了解自身的网络地址并发现它的邻居节点后构造初始的链路信息包</p><p>然后将这个包发送给该网络中所有其他路由器，并接收其他路由器发来的路由状态包</p><p>最终每个路由器都可以得到完整的网络拓扑信息，执行dijkstra算法就可得到它到各节点的最佳链路</p><h4 id="运输层中伪首部的作用"><a href="#运输层中伪首部的作用" class="headerlink" title="运输层中伪首部的作用"></a>运输层中伪首部的作用</h4><p>伪首部参与TCP报文段/UDP用户数据报的校验和计算，既检查了运输层报文，又对IP数据报的源IP地址和目的IP地址进行了校验。</p><h4 id="二进制指数后退算法"><a href="#二进制指数后退算法" class="headerlink" title="二进制指数后退算法"></a>二进制指数后退算法</h4><p>首先确定基本退避时间，一般取冲突期$2\tau$</p><p>遇到冲突后，当前重发次数为$n$，则取$k=min(n,10)$</p><p>在集合$\{0,…,2^k-1\}$中随机抽取一个数$r$，等待$r$个退避时间后再重发</p><p>如果$n\geq16$，则丢弃帧并向高层报告</p><p>使用二进制指数退避算法考虑了网络负载对冲突的影响，可使重传需要推迟的平均时间随重传次数的增大而增大，因而能减低发生碰撞的概率，有利于整个系统的稳定</p><h4 id="网桥的工作过程"><a href="#网桥的工作过程" class="headerlink" title="网桥的工作过程"></a>网桥的工作过程</h4><p>每个网桥维护一张哈希表，存放物理地址和网桥端口号的映射关系</p><p>当收到一个帧时，首先登记该帧的源物理地址和源端口号，再根据目的物理地址检查哈希表</p><p>如果表中没有对应项，则泛洪转发到网桥的其他所有端口</p><p>如果表中有对应项，若目的端口与源端口不一致，则根据表内信息转发到对应端口；若目的端口与源端口一致，则直接丢弃</p><h4 id="网络层如何使用RED算法进行拥塞控制"><a href="#网络层如何使用RED算法进行拥塞控制" class="headerlink" title="网络层如何使用RED算法进行拥塞控制"></a>网络层如何使用RED算法进行拥塞控制</h4><p>RED算法，随机早期检测算法</p><p>路由器维护一个运行队列长度的平均值，当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随即丢弃一小部分数据包。隐式通知源发生阻塞，降低源传输数据速度。</p><h4 id="TCP的连接建立过程"><a href="#TCP的连接建立过程" class="headerlink" title="TCP的连接建立过程"></a>TCP的连接建立过程</h4><p>三次握手</p><p>客户端向服务器发送TCP报文，SYN=1，企图建立连接并同步信号</p><p>服务器收到客户端建立连接的请求，并同步完成，向客户端发送TCP报文，SYN=1，ACK=1</p><p>客户端收到后成功建立TCP连接，向服务器发送TCP确认报文，ACK=1</p><p>服务器收到该报文后成功建立TCP连接</p><h4 id="TCP的连接释放过程"><a href="#TCP的连接释放过程" class="headerlink" title="TCP的连接释放过程"></a>TCP的连接释放过程</h4><p>四次挥手</p><p>客户端停止数据发送，向服务器发送企图释放连接的TCP报文，FIN=1，然后进入等待状态</p><p>服务器收到该报文后，向客户端发送普通的TCP确认报文，ACK=1，TCP连接处于半关闭状态</p><p>客户端收到后等待并接收服务器发送的数据</p><p>直至服务器发送数据完毕，服务器发送释放连接的TCP报文，FIN=1，ACK=1，然后等待最后的确认</p><p>客户端收到该报文后，向客户端发送普通的TCP确认报文，然后等待一小段时间再释放连接</p><p>客户端收到应答后可以释放连接</p><h4 id="慢启动算法的工作原理"><a href="#慢启动算法的工作原理" class="headerlink" title="慢启动算法的工作原理"></a>慢启动算法的工作原理</h4><p>设置一个慢启动阈值，初始的拥塞窗口大小为1</p><p>当拥塞窗口小于慢启动阈值时，每成功传输一轮数据，拥塞窗口扩大2倍</p><p>当拥塞窗口达到慢启动阈值时，每成功传输一轮数据，拥塞窗口加1</p><p>若传输的数据发生超时重传，则可以认为网络发生拥塞，慢启动阈值更新为当前拥塞窗口的一半大小，拥塞窗口更新为1，重新执行慢启动算法</p><h4 id="数据链路层的滑动窗口协议"><a href="#数据链路层的滑动窗口协议" class="headerlink" title="数据链路层的滑动窗口协议"></a>数据链路层的滑动窗口协议</h4><p>发送窗口：发送方允许发送且没有收到确认的一组连续的帧的序号。当发送方收到确认帧时才相应滑动</p><p>接收窗口：接收方允许接受的一组连续的帧的序号。当接收方收到序号为窗口下限的数据帧后就相应滑动</p><p>回退N协议：$1&lt;$发送窗口$\leq 2^n-1$ 接收窗口$=1$ 采用累计确认，当接收方收到无序帧时直接丢弃不返回确认，接收方超时后需要重传坏帧及已发送的后续帧</p><p>选择性重发协议：$1&lt;$接收窗口$\leq$发送窗口$\leq 2^{n-1}$ 不采用累计确认，接收方只丢弃坏帧，对于无序正确帧进行缓存并返回确认，接受方超时后只重传坏帧</p><p>如何提供流量控制：发送方可以一直发送数据直到发送缓冲区满，而缓冲区的清空依赖于接收方发来的确认，接收方可以通过发送确认的速率来控制发送方的发送速率，从而避免被过快的发送方淹没以达到流量控制的目的</p><h4 id="电话系统"><a href="#电话系统" class="headerlink" title="电话系统"></a>电话系统</h4><p>本地回路：调制解调器、ADSL、光纤到户</p><p>主干线：脉冲编码调制、时分多路复用、波分多路复用</p><p>交换局：电路交换、包交换</p><p>为什么不使用平面系统，而使用分层系统：分层可以降低设计的复杂度，方便设备间的互联互通，增强可升级性</p><h4 id="漏桶算法和令牌桶算法"><a href="#漏桶算法和令牌桶算法" class="headerlink" title="漏桶算法和令牌桶算法"></a>漏桶算法和令牌桶算法</h4><p>漏桶算法：数据包被放置在漏桶里，以恒定速率输出，当漏桶满了，那么新到达的数据包被丢弃</p><p>令牌桶算法：大小固定的令牌桶以恒定速率产生令牌，传送到令牌桶的数据包需要消耗令牌才能被发送出去</p><p>区别：令牌桶算法允许流量一定程度的突发；当令牌桶满了丢弃的是令牌，当漏桶满了丢弃的是数据包</p><h4 id="TCP协议滑动窗口的工作过程"><a href="#TCP协议滑动窗口的工作过程" class="headerlink" title="TCP协议滑动窗口的工作过程"></a>TCP协议滑动窗口的工作过程</h4><p>发送方发送数据给接收方</p><p>接收方收到数据后根据自己的缓冲区大小设置接收窗口，并通过确认报文告知发送方</p><p>发送方收到确认报文后，根据接收方接收窗口大小来限制自己的发送窗口大小</p><p>当接收方的缓冲区满了，则接收窗口大小变为0</p><p>发送方收到接收窗口大小为0的报文后启动计时器，若在计时器超时之前接收方发来新的窗口大小，则停止计时，继续正常工作；若计时器超时，则发送方发送零窗口探测报文获得当前接收窗口大小</p><h4 id="访问一个网站的过程"><a href="#访问一个网站的过程" class="headerlink" title="访问一个网站的过程"></a>访问一个网站的过程</h4><h5 id="数据在各个层次的封装过程"><a href="#数据在各个层次的封装过程" class="headerlink" title="数据在各个层次的封装过程"></a>数据在各个层次的封装过程</h5><p>应用层    http</p><p>传输层    tcp+http</p><p>网络层    ip+tcp+http</p><p>数据链路层    以太网+ip+tcp+http</p><h5 id="各个层次使用到的网络协议及其功能"><a href="#各个层次使用到的网络协议及其功能" class="headerlink" title="各个层次使用到的网络协议及其功能"></a>各个层次使用到的网络协议及其功能</h5><p>应用层    HTTP:www访问协议    DNS:域名解析服务</p><p>传输层    TCP:为HTTP提供可靠的数据传输    UDP:DNS使用UDP传输</p><p>网络层    IP:IP包传输和路由选择    ICMP:提供网络传输中的差错检测    ARP:本机的默认网关IP地址映射成物理MAC地址    NAT:私有IP和公网IP的转换</p><h5 id="通信过程中使用到的地址及转换"><a href="#通信过程中使用到的地址及转换" class="headerlink" title="通信过程中使用到的地址及转换"></a>通信过程中使用到的地址及转换</h5><p>域名通过DNS转换为IP地址</p><p>内网IP地址通过NAT转换为公网IP地址</p><p>IP地址通过ARP转换为物理MAC地址</p><h4 id="ARP协议的工作过程"><a href="#ARP协议的工作过程" class="headerlink" title="ARP协议的工作过程"></a>ARP协议的工作过程</h4><p><strong>在同一个网络内</strong>，假设A要给B发送数据包，但A只知道B的IP地址，而在通过以太网封装数据帧时还需要知道B的MAC地址，则执行ARP协议</p><p>A检查自己的本地ARP缓存，查找是否有B的匹配MAC地址</p><p>若没有，A发送带有目标IP地址、源IP地址、源MAC地址的ARP请求广播</p><p>网络中各主机收到该请求，若自己的IP地址与其不匹配则直接丢弃；B收到后正确匹配，则将A的IP地址和MAC地址存入自己的本地ARP缓存中，并发送包含自己MAC地址的ARP响应报文给A</p><p>A收到该报文后将B的IP地址和MAC地址添加到自己的ARP缓存中，然后就可以发送数据了</p><p><strong>不在同一个网络时</strong>，假设A要给B发送数据包</p><p>A检查自己的本地ARP缓存，发现B不属于本网络，则需要把数据包发往默认网关再进行后续转发</p><p>执行同一网络内的ARP协议获得默认网关的MAC地址，目的MAC地址填写默认网关的MAC地址进行封装，发送给默认网关</p><p>默认网关收到数据包，检查目的IP地址，查询路由表进行路由转发，找到对应接口后，执行同一网络内的ARP协议获得B的MAC地址，然后源MAC地址填写自己的MAC地址，目的MAC地址填写B的MAC地址进行封装，转发给主机B</p><h4 id="虚电路交换和数据包交换的工作原理"><a href="#虚电路交换和数据包交换的工作原理" class="headerlink" title="虚电路交换和数据包交换的工作原理"></a>虚电路交换和数据包交换的工作原理</h4><p>虚电路交换：首先建立一条虚电路，然后在所建立的连接上传输数据，传输结束后释放连接</p><p>数据包交换：每个数据包携带完整的目的地址独自选择路由进行交换</p><h4 id="DNS的工作原理"><a href="#DNS的工作原理" class="headerlink" title="DNS的工作原理"></a>DNS的工作原理</h4><p>对于一个给定的域名，需要获取它对应的IP地址，提出DNS请求</p><p>首先在本地域名服务器中查找，若有与该域名匹配的记录，则直接返回对应的IP地址</p><p>否则，去根域名服务器进行查询，查询方式分为递归查询和迭代查询，将最终查询的返回结果保存到本地域名服务器中去以备下次使用，并返回给客户机</p><h4 id="千兆以太网如何解决传输距离短的问题"><a href="#千兆以太网如何解决传输距离短的问题" class="headerlink" title="千兆以太网如何解决传输距离短的问题"></a>千兆以太网如何解决传输距离短的问题</h4><p>帧突发技术，使得一个工作站能够一次连续发送多个数据帧</p><h4 id="计算机采用层次结构的主要优点"><a href="#计算机采用层次结构的主要优点" class="headerlink" title="计算机采用层次结构的主要优点"></a>计算机采用层次结构的主要优点</h4><p>各层之间相互独立。上层无需知道下层实现细节，只需知道接口提供的服务</p><p>灵活性好。当一层发生改变，只要不改变接口关系，上下层不会受到影响</p><p>便于实现、调试和维护。</p><p>利于标准化。</p><h4 id="为什么规定以太网帧最小帧长"><a href="#为什么规定以太网帧最小帧长" class="headerlink" title="为什么规定以太网帧最小帧长"></a>为什么规定以太网帧最小帧长</h4><p>使用CSMA/CD协议时，如果发送的帧太短，没有来得及检测碰撞就已经发送完了，所以整个帧的发送时间应该不小于信号的往返传输时延</p><h4 id="逆向路径转发"><a href="#逆向路径转发" class="headerlink" title="逆向路径转发"></a>逆向路径转发</h4><p>用于广播路由。当一个广播数据包到达一个路由器时，路由器检查它到来的那条线路是否正是通常用来给广播源端发送数据包用的那条线路，如果是则路由器将该数据包转发到除了到来的那条线路之外的所有其他线路上；否则该数据包被当作一个可能的重复数据包丢弃</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ComputerNetwork</tag>
      
      <tag>SDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU计算机体系结构复习笔记</title>
    <link href="/2022/06/24/CSAreview/"/>
    <url>/2022/06/24/CSAreview/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-概念"><a href="#第一章-概念" class="headerlink" title="第一章 概念"></a>第一章 概念</h1><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p>分成6层 每层的功能</p><p><img src="/2022/06/24/CSAreview/image-20220622120846728.png" alt></p><p><strong>解释</strong>：L0-L2级 每当一条N+1级指令被译码后就直接去执行一串等效的N级指令，然后再去取下一条N+1级的指令，依次重复进行</p><p><strong>翻译</strong>：L3-L5级 先把N+1级程序全部转换成N级程序后再去执行新产生的N级程序，在执行过程中N+1级程序不再被访问</p><blockquote><p>解释执行比翻译执行所花的时间多，但占用的存储空间更少</p></blockquote><h2 id="计算机系统结构的定义"><a href="#计算机系统结构的定义" class="headerlink" title="计算机系统结构的定义"></a>计算机系统结构的定义</h2><p>计算机系统结构研究的是==软、硬件之间的功能分配==以及==对传统机器级界面的确定==，为机器语言、汇编语言程序设计者或编译程序生成系统，提供使其设计或生成的程序能在机器上正确运行而应看到和遵循的计算机属性</p><h2 id="计算机系统的分类（Flynn分类法）"><a href="#计算机系统的分类（Flynn分类法）" class="headerlink" title="计算机系统的分类（Flynn分类法）"></a>计算机系统的分类（Flynn分类法）</h2><p>按照指令流和数据流的多倍性特征进行分类</p><blockquote><p>指令流：机器执行的指令序列</p><p>数据流：由指令流调用的数据序列</p><p>多倍性：在系统性能瓶颈部件上同时处于同一执行阶段的指令或数据的最大可能个数</p></blockquote><ul><li><p><strong>单指令流单数据流 SISD</strong></p><p>典型顺序处理计算机</p><p><img src="/2022/06/24/CSAreview/image-20220622123158438.png" alt></p></li><li><p><strong>单指令流多数据流 SIMD</strong></p><p>并行处理机、向量处理机、超标量处理机、超流水线处理机</p><p>多个PU按一定方式互连，在同一个CU控制下，对各自的数据完成同一条指令规定的操作；从CU看指令顺序执行，从PU看数据并行执行</p><p><img src="/2022/06/24/CSAreview/image-20220622123335275.png" alt></p></li><li><p><strong>多指令流单数据流 MISD</strong></p><p>几条指令对同一个数据进行不同的处理</p><p><img src="/2022/06/24/CSAreview/image-20220622124152785.png" alt></p></li><li><p><strong>多指令流多数据流 MIMD</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622124224648.png" alt></p></li></ul><h2 id="Amdahl定律及其应用"><a href="#Amdahl定律及其应用" class="headerlink" title="Amdahl定律及其应用"></a>Amdahl定律及其应用</h2><p>系统中某一部件由于采用更快的执行方式，整个系统性能的提高与这种执行方式的使用频率有关</p><script type="math/tex; mode=display">可改进部分的比例：Fe=\frac{可改进部分的执行时间}{改进前整个任务的执行时间}\\改进部分的加速比：Se=\frac{改进前改进部分的执行时间}{改进后改进部分的执行时间}</script><p>假设 $T_0$ 为改进前整个任务的执行时间，则改进后整个任务的执行时间为</p><script type="math/tex; mode=display">T_n=T_0(1-Fe+\frac{Fe}{Se})</script><p>改进后整个系统的加速比为</p><script type="math/tex; mode=display">S_n=\frac{T_0}{T_n}=\frac{1}{1-Fe+\frac{Fe}{Se}}</script><h2 id="CPU性能公式"><a href="#CPU性能公式" class="headerlink" title="CPU性能公式"></a>CPU性能公式</h2><p>CPU的程序执行时间 $T_{CPU}$ 取决于：</p><ul><li><p>程序执行的总指令条数 $IC$ 取决于指令集结构和编译技术</p></li><li><p>平均每条指令的时钟周期数 $CPI$ 取决于计算机组成和指令集结构</p><script type="math/tex; mode=display">CPI=\frac{\sum_{i=1}^n(CPI_i\times I_i)}{IC}=\sum_{i=1}^n(CPI_i\times \frac{I_i}{IC})</script></li><li><p>时钟主频 $f_c$ 取决于硬件实现技术和计算机组成</p></li></ul><script type="math/tex; mode=display">T_{CPU}=IC\times CPI\times \frac{1}{f_c}</script><h2 id="程序访问的局部性规律"><a href="#程序访问的局部性规律" class="headerlink" title="程序访问的局部性规律"></a>程序访问的局部性规律</h2><p><strong>时间局部性</strong>：近期被访问的信息很可能马上被再次访问</p><p><strong>空间局部性</strong>：在访问地址上相邻近的信息很可能被一起访问</p><h2 id="软件的移植方法"><a href="#软件的移植方法" class="headerlink" title="软件的移植方法"></a>软件的移植方法</h2><p><strong>模拟</strong>：用机器语言程序解释实现软件移植</p><p><strong>仿真</strong>：用微程序直接解释另一种机器指令</p><p><img src="/2022/06/24/CSAreview/image-20220622132106479.png" alt></p><h1 id="第二章-指令系统"><a href="#第二章-指令系统" class="headerlink" title="第二章 指令系统"></a>第二章 指令系统</h1><h2 id="数据表示与数据结构"><a href="#数据表示与数据结构" class="headerlink" title="数据表示与数据结构"></a>数据表示与数据结构</h2><p><strong>数据表示</strong>：计算机硬件能够直接识别，可以被指令系统直接调用的数据类型</p><p><strong>数据结构</strong>：串、队、栈、向量、阵列、链表、树、图等软件要处理的各种数据结构，反映了应用中要用到的各种数据元素或信息单元之间的结构关系</p><p>数据结构要通过软件映像才能变换成机器所具有的数据表示来实现，不同的数据表示可为数据结构的实现提供不同的支持</p><p>数据结构和数据表示实际上是软硬件的交互面，需要在系统结构设计时确定</p><h2 id="标志符数据表示"><a href="#标志符数据表示" class="headerlink" title="标志符数据表示"></a>标志符数据表示</h2><p>一般的计算机中，数据存储单元只存放纯数据，数据的属性通过指令中的操作码来解释；高级语言使用类型说明语句指明数据类型，运算符不反映数据类型</p><p>为缩短高级语言与机器语言之间的语义差距，可以让机器中的每个数据都加上类型标志位。标识符由编译器或其他系统软件建立，对程序员透明。结果是数据存储量增加，指令存储量减少</p><p><img src="/2022/06/24/CSAreview/image-20220622134925755.png" alt></p><h2 id="数据描述符"><a href="#数据描述符" class="headerlink" title="数据描述符"></a>数据描述符</h2><p>为进一步减少标识符所占用的存储空间，对向量、数据、记录等数据，由于元素属性相同，采用数据描述符</p><blockquote><p>数据描述符与标志符的区别：标志符只作用于一个数据，而数据描述符作用于一组数据</p></blockquote><h2 id="浮点数的表示方式"><a href="#浮点数的表示方式" class="headerlink" title="浮点数的表示方式"></a>浮点数的表示方式</h2><p><img src="/2022/06/24/CSAreview/image-20220622142302203.png" alt></p><p>尾数决定了浮点数的表示精度，阶值决定了浮点数的表示范围</p><p>非负阶、规格化、正尾数</p><ul><li>最小尾数（小数点后第一个$r_m$进制数位为1）：$r_m^{-1}$</li><li><p>最大尾数（$r_m$进制尾数均为$r_m-1$）：$1-r_m^{-m’}$</p></li><li><p>最大阶值（阶值部分全为1）：$2^p-1$</p></li><li>最小值（$最小尾数\times r_m^0$）：$r_m^{-1}$</li><li>最大值（$最大尾数\times r_m^{最大阶值}$）：$(1-r_m^{-m’})\times r_m^{2^p-1}$</li><li>可表示的尾数个数（小数点后第一个$r_m$进制数位为1）：$r_m^{m’-1}(r_m-1)$</li><li>可表示的阶个数：$2^p$</li><li>可表示的数个数：$2^pr_m^{m’-1}(r_m-1)$</li></ul><p><strong>特性</strong>：尾数基值$r_m$增大，会扩大浮点数表示范围，增加可表示数的个数，减少移位次数，降低右移造成的精度损失，提高运算速度；但也会降低数据的表示精度，数值的分布变稀疏</p><p><strong>尾数下溢处理</strong></p><ul><li><p>截断法：将尾数超出机器字长的部分截去</p></li><li><p>舍入法：在机器运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加1</p></li><li><p>恒置1法：把有效字长的最低一位置成$r_m/2$</p></li><li><p>查表舍入法：用ROM或者PLA存放下溢处理表</p></li></ul><h2 id="编址方式"><a href="#编址方式" class="headerlink" title="编址方式"></a>编址方式</h2><p><strong>编址单位</strong>：字编址、字节编址、位编址、块编址</p><p><strong>编址单位与访问字长</strong>：</p><ul><li>一般：字节编址字访问</li><li>部分机器：位编址字访问</li><li>辅助存储器：块编址位访问</li></ul><p><strong>字节编址的大小端问题</strong> 例<code>0x12345678</code></p><ul><li>小端：高位字节放高地址，低位字节放低地址</li></ul><div class="table-container"><table><thead><tr><th>低地址</th><th></th><th></th><th>高地址</th></tr></thead><tbody><tr><td>0x78</td><td>0x56</td><td>0x34</td><td>0x12</td></tr></tbody></table></div><ul><li>大端：低位字节放高地址，高位字节放低地址</li></ul><div class="table-container"><table><thead><tr><th>低地址</th><th></th><th></th><th>高地址</th></tr></thead><tbody><tr><td>0x12</td><td>0x34</td><td>0x56</td><td>0x78</td></tr></tbody></table></div><p><strong>模m高位交叉编址</strong>：主要用来扩大存储器容量</p><p>体地址<code>A/m</code>    体内地址<code>A mod m</code></p><p><img src="/2022/06/24/CSAreview/image-20220622145653313.png" alt="模m高位交叉编址"></p><p><strong>模m低位交叉编址</strong>：主要用来提高存储器速度</p><p>体地址<code>A mod m</code>    体内地址<code>A/m</code></p><p><img src="/2022/06/24/CSAreview/image-20220622145840043.png" alt="模m低位交叉编址"></p><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p><strong>立即数寻址方式</strong>：直接在指令中给出操作数</p><p><strong>面向寄存器的寻址方式</strong>：指令在执行过程中所需要的操作数来自于寄存器，运算结果也写回寄存器</p><p><strong>面向主存储器的寻址方式</strong>：</p><ul><li><strong>直接寻址</strong>：在指令中直接给出参加运算的操作数及运算结果所存放的主存地址</li><li><strong>间接寻址</strong>：指令中给出的是操作数地址的地址</li><li><strong>变址寻址</strong>：指令执行时，用硬件加法器将变址寄存器中的基地址与指令给出的偏移量相加，才得到有效地址</li></ul><p><strong>面向堆栈的寻址方式</strong>：是隐含的，在指令中不需要给出操作数地址</p><h2 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h2><p><strong>直接定位</strong>：在程序装入主存之前，程序中的指令和数据的物理地址就已经确定</p><p><strong>静态定位</strong>：在程序装入主存的过程中进行地址变换</p><p><strong>动态定位</strong>：在程序执行过程中访问到相应的指令或数据时才进行地址变换</p><h2 id="操作码优化设计"><a href="#操作码优化设计" class="headerlink" title="操作码优化设计"></a>操作码优化设计</h2><p><a href="https://wenku.baidu.com/view/4e45626b25c52cc58bd6be3e.html">相关习题</a></p><p>操作码的最短平均长度</p><script type="math/tex; mode=display">H_{opt}=-\sum_{i=1}^n p_i\cdot\log_2{p_i}</script><p>相对最优编码的信息冗余量计算</p><script type="math/tex; mode=display">R=1-\frac{H_{opt}}{H}</script><p><strong>固定长度</strong></p><script type="math/tex; mode=display">H=\lceil\log_2{n}\rceil</script><p>优点：规整，译码简单</p><p>缺点：浪费信息量</p><p><strong>Huffman编码</strong></p><p>当各种事件发生的概率不等时，对发生概率最高的操作用最短的位数来表示，而对出现概率较低的操作用较长的位数来表示，使表示的平均位数缩短</p><p>采用最小概率合并法构造Huffman树确定编码</p><script type="math/tex; mode=display">H=\sum_{i=1}^n p_i\cdot l_i</script><p>缺点：不规整，译码困难；与地址码组成固定长度的指令比较困难</p><p><strong>扩展编码</strong></p><p>界于定长二进制编码和完全哈夫曼编码之间的一种编码方式，操作码的长度不是定长的，但规定码长取值在一有限集内。仍然采用高概率指令用短码、低概率指令用长码的哈夫曼编码思想</p><h2 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h2><p><strong>特点</strong>：</p><ul><li>减少指令和寻址方式种类</li><li>固定指令格式</li><li>大多数指令在单周期内完成</li><li>采用LOAD/STORE结构</li><li>硬布线逻辑</li><li>优化编译</li></ul><p><strong>思想</strong>：减少CPI</p><p><strong>技术</strong>：</p><ul><li>延时转移技术</li><li>指令取消技术</li><li>重叠寄存器窗口技术</li><li>指令流调整技术</li><li>采用高速缓冲存储器Cache</li><li>优化设计编译系统</li></ul><h1 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h1><h2 id="存储系统的定义和评价标准"><a href="#存储系统的定义和评价标准" class="headerlink" title="存储系统的定义和评价标准"></a>存储系统的定义和评价标准</h2><blockquote><p>两个或两个以上速度、容量和价格各不相同的存储器用硬件、软件、或软件与硬件相结合的方法连接起来成为一个存储系统</p><p>对应用程序员透明，速度=max，容量=max，价格=min</p></blockquote><p><strong>Cache存储系统</strong>由Cache和主存储器构成，对系统程序员以上均透明</p><p>主要目的是提高存储器速度</p><p><img src="/2022/06/24/CSAreview/image-20220622161929398.png" alt></p><p><strong>虚拟存储系统</strong>由主存储器额硬盘构成，对应用程序员透明</p><p>主要目的是扩大存储器容量</p><p><img src="/2022/06/24/CSAreview/image-20220622162024399.png" alt></p><p><strong>容量S</strong>要求提供尽可能大的地址空间，能够随机访问</p><ul><li>只对系统中存储容量最大的存储器进行编址，如Cache存储系统</li><li>另设计一个容量很大的逻辑地址空间，把相关存储器映射到该地址空间中，如虚拟存储系统</li></ul><p><strong>价格C</strong></p><script type="math/tex; mode=display">C=\frac{C_1 S_1+C_2S_2}{S_1+S_2}\\</script><p><strong>速度</strong>用访问周期T表示，命中率H，访问效率e</p><script type="math/tex; mode=display">e=\frac{T_1}{T}=\frac{T_1}{H\cdot T_1+(1-H)\cdot T_2}=\frac{1}{H+(1-H)\frac{T_2}{T_1}}=f(H,\frac{T_2}{T_1})</script><p>提高存储系统速度的两种方法：</p><ul><li>提高命中率</li><li>两个存储器的速度不要相差太大</li></ul><h2 id="存储系统的层次结构"><a href="#存储系统的层次结构" class="headerlink" title="存储系统的层次结构"></a>存储系统的层次结构</h2><p><img src="/2022/06/24/CSAreview/image-20220622164102587.png" alt></p><p><strong>存储系统频带平衡的解决方法</strong></p><ul><li>多个存储器并行工作</li><li>设置各种缓冲存储器</li><li>采用存储系统</li></ul><h2 id="并行存储器"><a href="#并行存储器" class="headerlink" title="并行存储器"></a>并行存储器</h2><p>把<code>m</code>字<code>w</code>位的存储器变为<code>m/n</code>字<code>n*w</code>位的存储器</p><p><img src="/2022/06/24/CSAreview/image-20220622164720466.png" alt></p><p>主要缺点：访问冲突大</p><ul><li>取指令冲突</li><li>读操作数冲突</li><li>写数据冲突</li><li>读写冲突</li></ul><h2 id="虚拟存储器工作原理"><a href="#虚拟存储器工作原理" class="headerlink" title="虚拟存储器工作原理"></a>虚拟存储器工作原理</h2><p>把主存储器、磁盘存储器和虚拟存储器都划分成固定大小的页，进行内部地址变换</p><p><img src="/2022/06/24/CSAreview/image-20220622165658467.png" alt></p><p><strong>页式</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622165824237.png" alt></p><p><strong>段式</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622165806554.png" alt></p><p><strong>段页式</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622165842995.png" alt></p><h2 id="加快内部地址变换的方法"><a href="#加快内部地址变换的方法" class="headerlink" title="加快内部地址变换的方法"></a>加快内部地址变换的方法</h2><p><strong>多级页表</strong></p><p>页表级数的计算公式</p><script type="math/tex; mode=display">g=\lceil\frac{虚页总数}{每页能容纳的页表项个数}\rceil=\lceil\frac{\log_2{N_v}-\log_2{N_p}}{\log_2{N_p}-\log_2{N_d}}\rceil</script><p>$N_v$为虚拟存储空间大小，$N_p$为页面大小，$N_d$为一个页表存储字的大小</p><p>采用多级页表使访问主存次数增加，需要<strong>加快查表速度</strong></p><ul><li><p>目录表法：压缩页表，用一个容量比较小的高速存储器来存放页表</p><p><img src="/2022/06/24/CSAreview/image-20220627165712592.png" alt></p></li><li><p>快慢表：时间局部性，用快表保存最近访问的虚页到实页的映射</p><p><img src="/2022/06/24/CSAreview/image-20220627165721583.png" alt></p></li><li><p>散列函数：把按内容的相联访问变为按地址访问</p><p><img src="/2022/06/24/CSAreview/image-20220627165732496.png" alt></p></li></ul><h2 id="页面替换算法"><a href="#页面替换算法" class="headerlink" title="页面替换算法"></a>页面替换算法</h2><p><strong>随机算法RAND</strong></p><p><strong>最优替换算法OPT</strong>：选将来最久没有被访问的页</p><p><strong>近期最少使用算法LRU</strong>：选最久未被访问的页</p><p><strong>先进先出算法FIFO</strong>：选最早装入主存的页</p><h2 id="提高主存命中率"><a href="#提高主存命中率" class="headerlink" title="提高主存命中率"></a>提高主存命中率</h2><p><strong>页面大小</strong>增加命中率增加，当达到某个值时命中率最大，之后页面增大命中率降低</p><p><img src="/2022/06/24/CSAreview/image-20220622173730659.png" alt></p><p><strong>主存容量S</strong>增加命中率H增加，随着S的增加，H增加的速度逐渐降低，当S增加到某个值之后H几乎不再增加</p><p><img src="/2022/06/24/CSAreview/image-20220622173724242.png" alt></p><p><strong>页面调度方式</strong>分为请求式和预取式</p><h2 id="Cache存储系统工作原理"><a href="#Cache存储系统工作原理" class="headerlink" title="Cache存储系统工作原理"></a>Cache存储系统工作原理</h2><p><img src="/2022/06/24/CSAreview/image-20220622174025863.png" alt></p><p>地址映像：把主存中的程序按照某种规则装入到Cache中，并建立主存地址与Cache地址之间的对应关系</p><p>地址变换：当程序已经装入到Cache之后，在程序运行过程中把主存地址变换成Cache地址</p><p><strong>全相联映像</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622174641664.png" alt></p><p><strong>直接映像</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622174546272.png" alt></p><p><strong>组相联映像</strong></p><p><img src="/2022/06/24/CSAreview/image-20220622174740444.png" alt></p><h2 id="Cache的一致性问题"><a href="#Cache的一致性问题" class="headerlink" title="Cache的一致性问题"></a>Cache的一致性问题</h2><p><strong>Cache与主存不一致的原因</strong>：</p><ul><li>CPU写Cache时没有立即写主存</li><li>IO设备写主存时没有更新Cache</li></ul><p><strong>解决办法</strong>：</p><ul><li><p><strong>写直达法</strong>：CPU的数据写入Cache时同时也写入主存</p></li><li><p><strong>写回法</strong>：CPU的数据只写入Cache不写入主存，只有当替换时才把修改过的Cache块写回主存</p></li><li><p>比较：</p><ul><li>可靠性：写直达法优于写回法</li><li>与主存的通信量：写回法少于写直达法</li><li>控制的复杂性：写直达法比写回法简单</li><li>硬件实现的代价：写回法要比写直达法好</li></ul></li></ul><h2 id="Cache的预取算法"><a href="#Cache的预取算法" class="headerlink" title="Cache的预取算法"></a>Cache的预取算法</h2><p><strong>按需取</strong>：当出现Cache不命中时，才把需要的一个块取到Cache中</p><p><strong>恒预取</strong>：无论Cache是否命中，都把下一块取到Cache中</p><p><strong>不命中预取</strong>：当出现Cache不命中，把本块和下一块都取到Cache中</p><h1 id="第四章-I-O系统"><a href="#第四章-I-O系统" class="headerlink" title="第四章 I/O系统"></a>第四章 I/O系统</h1><h2 id="基本的输入输出方式"><a href="#基本的输入输出方式" class="headerlink" title="基本的输入输出方式"></a>基本的输入输出方式</h2><p><strong>程序控制方式 Polling</strong></p><p><img src="/2022/06/24/CSAreview/image-20220623122733540.png" alt></p><p><strong>中断方式 Interrupts</strong></p><p>当出现(…)事件时，CPU暂停执行现行程序，转去处理这些事件，等处理完成后再返回来继续执行原先的程序</p><p><strong>直接存储器访问方式 DMA</strong></p><ul><li><p>周期窃取方式：在每一条指令执行结束时，CPU测试有没有DMA服务申请</p></li><li><p>直接存取方式：DMA控制器的数据传送申请直接发往主存储器</p></li><li><p>数据块传送方式：在设备控制器中设置一个数据缓冲存储器，设备控制器与主存储器之间的数据交换以数据块为单位，并采用程序中断方式进行</p></li></ul><h2 id="中断源分类和优先级"><a href="#中断源分类和优先级" class="headerlink" title="中断源分类和优先级"></a>中断源分类和优先级</h2><ul><li><p><strong>由外围设备引起的中断</strong></p></li><li><p><strong>由处理机本身产生的中断</strong></p><p>如算术溢出、除数为零、数据校验错等</p></li><li><p><strong>由存储器产生的中断</strong></p><p>如地址越界、页面失效、访问存储器超时等</p></li><li><p><strong>由控制器产生的中断</strong></p><p>如非法指令、堆栈溢出、时间片到、切换到特权态</p></li><li><p><strong>由总线产生的中断</strong></p><p>如输入输出总线出错、存储总线出错等</p></li><li><p><strong>实时过程控制产生的中断</strong></p></li><li><p><strong>实时钟的定时中断</strong></p></li><li><p><strong>多处理机系统中从其他处理机发送来的中断</strong></p></li><li><p><strong>程序调试过程中由断点产生的中断</strong></p></li><li><p><strong>硬件故障中断</strong></p></li><li><p><strong>电源故障中断</strong></p></li></ul><p>安排中断优先顺序主要由下列因素来决定：</p><ul><li>中断源的急迫性</li><li>设备的工作速度</li><li>数据恢复的难易程度</li><li>要求处理机提供的服务量</li></ul><p>按照中断优先级响应中断请求的原则：</p><ul><li>CPU同时接受到几个中断时，首先响应优先级最高的中断请求</li><li>正在进行的中断过程不能被新的同级或低级中断请求中断</li><li>正在进行的低优先级中断服务能被高级中断请求中断</li></ul><p><img src="/2022/06/24/CSAreview/image-20220623124639438.png" alt></p><h2 id="中断处理过程及软硬件分配"><a href="#中断处理过程及软硬件分配" class="headerlink" title="中断处理过程及软硬件分配"></a>中断处理过程及软硬件分配</h2><blockquote><font color="red">硬件实现：保存中断点和进入中断服务程序入口</font>    <font color="orange">软件实现：中断服务和返回到中断点</font></blockquote><p>1  <font color="red">现行指令结束，且没有更紧急的服务请求</font></p><p>2  <font color="red">关CPU中断</font></p><p>3  <font color="red">保存断点，主要保存PC中的内容</font></p><p>4  撤销中断源的中断请求</p><p>5  保存硬件现场，主要是PSW及SP等</p><p>6  识别中断源</p><p>7  改变设备的屏蔽状态</p><p>8  <font color="red">进入中断服务程序入口</font></p><p>9  保存软件现场，在中断服务程序中使用的通用寄存器等</p><p>10 <font color="orange">开CPU中断，可以响应更高级别的中断请求</font></p><p>11 <font color="orange">中断服务，执行中断服务程序</font></p><p>12 <font color="orange">关CPU中断</font></p><p>13 恢复软件现场</p><p>14 恢复屏蔽状态</p><p>15 恢复硬件现场</p><p>16 开CPU中断</p><p>17 <font color="orange">返回到中断点</font></p><h2 id="中断响应时间"><a href="#中断响应时间" class="headerlink" title="中断响应时间"></a>中断响应时间</h2><p>从中断源向处理机发出中断服务请求开始，到处理机开始执行这个中断源的中断服务程序时为止</p><h2 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h2><p><strong>设置中断屏蔽位</strong></p><p><a href="https://blog.csdn.net/shuimu12345678/article/details/7693997">几个例子(最后一个有问题)</a></p><p>同时来按响应优先级响应</p><p>到开中断的时候看<font color="red">屏蔽码</font>，未屏蔽的按响应优先级去处理</p><p>执行过程中来新请求看屏蔽码去处理</p><p>执行完返回到入口位置再去响应剩下的请求</p><p><strong>改变处理机优先级</strong></p><p>处理机、每个中断源的硬件中断和中断向量都设置优先级</p><p>处理机只能响应硬件中断优先级比他高的中断（响应优先级按硬件中断优先级排），然后把自己的优先级变成该中断源对应的中断向量的优先级</p><p><img src="/2022/06/24/CSAreview/image-20220623144801528.png" alt="一个例子 好好理解"></p><h2 id="通道处理机的作用和功能"><a href="#通道处理机的作用和功能" class="headerlink" title="通道处理机的作用和功能"></a>通道处理机的作用和功能</h2><p>分担CPU的输入输出负担</p><ul><li>接受CPU发来的指令，选择一台指定的外围设备与通道相连接</li><li>执行CPU为通道组织的通道程序</li><li>管理外围设备的有关地址</li><li>管理主存缓冲区的地址</li><li>控制外围设备与主存缓冲区之间数据交换的个数</li><li>指定传送工作结束时要进行的操作</li><li>检查外围设备的工作状态是正常或故障</li><li>在数据传输过程中完成必要的格式变换</li></ul><h2 id="通道处理机的工作过程"><a href="#通道处理机的工作过程" class="headerlink" title="通道处理机的工作过程"></a>通道处理机的工作过程</h2><ul><li>在用户程序中使用访管指令进入管理程序，由CPU通过管理程序组织一个通道程序，并启动通道</li><li>通道处理机执行CPU为它组织的通道程序，完成指定的数据输入输出工作</li><li>通道程序结束后向CPU发送中断请求，CPU响应该中断请求，第二次进入操作系统，调用管理程序进行处理</li></ul><p><strong>字节多路通道</strong>：每连接一个中低速外围设备，传送一个字节，再连接下一个设备传送一个字节</p><p><strong>选择通道</strong>：每连接一个高速外围设备，传送n个字节，再连接下一个设备传送n个字节</p><p><strong>数组多路通道</strong>：每连接一个高速设备，传送一个数据块，再连接下一个设备传送一个数据块</p><h2 id="通道处理机流量分析"><a href="#通道处理机流量分析" class="headerlink" title="通道处理机流量分析"></a>通道处理机流量分析</h2><blockquote><p>通道流量：单位时间内能够传送的最大数据量</p><p>通道最大流量：通道在满负荷工作状态下的流量</p></blockquote><p>$T_S$ 设备选择时间    $T_D$ 传送一个字节所用的时间</p><p>$p$ 一个通道连接的设备台数    $n$ 每一个设备传送的字节个数</p><p>$k$ 一个数据块中的字节个数</p><p><strong>字节多路通道</strong></p><script type="math/tex; mode=display">f_{BYTE}=\sum_{i=1}^p{f_i}\\f_{MAX.BYTE}=\frac{p\cdot n}{(T_S+T_D)\cdot p\cdot n}=\frac{1}{T_S+T_D}字节/秒</script><p><strong>选择通道</strong></p><script type="math/tex; mode=display">f_{SELECT}=\max_i\{f_i|i=1,...,p\}\\f_{MAX.SELECT}=\frac{p\cdot n}{(\frac{T_S}{n}+T_D)\cdot p\cdot n}=\frac{1}{\frac{T_S}{n}+T_D}字节/秒</script><p><strong>数组多路通道</strong></p><script type="math/tex; mode=display">f_{BLOCK}=\max_i\{f_i|i=1,...,p\}\\f_{MAX.BLOCK}=\frac{p\cdot n}{(\frac{T_S}{k}+T_D)\cdot p\cdot n}=\frac{1}{\frac{T_S}{k}+T_D}字节/秒</script><p>为保证通道不丢失数据，通道的实际流量应不大于通道最大流量</p><blockquote><p><strong>出现设备请求未响应</strong></p><p>原因分析：对所有设备的请求时间间隔取最小公倍数，在这一段时间内通道的流量是平衡的，但在任意一台设备的任意两次时间传送请求之间并不能保证都能得到通道的响应</p><p>解决方法：</p><ul><li>增加通道的最大工作流量</li><li>动态改变设备的优先级</li><li>增加缓冲存储器</li></ul></blockquote><h1 id="第五章-标量处理机"><a href="#第五章-标量处理机" class="headerlink" title="第五章 标量处理机"></a>第五章 标量处理机</h1><h2 id="指令的重叠执行方式"><a href="#指令的重叠执行方式" class="headerlink" title="指令的重叠执行方式"></a>指令的重叠执行方式</h2><p>指令的三个阶段：取指令，指令分析，指令执行</p><p><strong>顺序执行方式</strong></p><p><img src="/2022/06/24/CSAreview/image-20220623164109907.png" alt></p><p><strong>一次重叠执行方式</strong></p><p><img src="/2022/06/24/CSAreview/image-20220623164119702.png" alt></p><p><strong>二次重叠执行方式</strong></p><p><img src="/2022/06/24/CSAreview/image-20220623164140247.png" alt></p><h2 id="先行控制技术的基本结构"><a href="#先行控制技术的基本结构" class="headerlink" title="先行控制技术的基本结构"></a>先行控制技术的基本结构</h2><p><img src="/2022/06/24/CSAreview/image-20220623164743931.png" alt></p><h2 id="流水线的基本原理"><a href="#流水线的基本原理" class="headerlink" title="流水线的基本原理"></a>流水线的基本原理</h2><p>把一个重复的过程分解为若干个子过程，每个子过程可以与其他子过程同时进行</p><p>每个流水段的末尾或开头必须设置一个流水寄存器</p><p><img src="/2022/06/24/CSAreview/image-20220623173344173.png" alt></p><h2 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h2><p><strong>线性和非线性</strong></p><ul><li><p>线性流水线：每一个流水段都流过且仅流过一次，能用流水线连接图唯一表示</p></li><li><p>非线性流水线：某些流水段之间有反馈回路或前馈回路，必须用流水线连接图和流水线预约表共同表示</p></li></ul><p><strong>单功能和多功能</strong></p><ul><li><p>单功能流水线：只能完成一种固定功能的流水线</p></li><li><p>多功能流水线：流水线的各段通过不同连接实现不同功能</p></li></ul><p><strong>静态和动态</strong></p><ul><li><p>静态流水线：同一段时间内，各个功能段只能按照一种方式连接，实现一种固定功能</p></li><li><p>动态流水线：同一时间段内，各个功能段可以按照不同方式连接，同时执行多种功能</p></li></ul><p><img src="/2022/06/24/CSAreview/image-20220623174426636.png" alt></p><h2 id="线性流水线的性能分析"><a href="#线性流水线的性能分析" class="headerlink" title="线性流水线的性能分析"></a>线性流水线的性能分析</h2><p><strong>吞吐率 Throughput</strong></p><script type="math/tex; mode=display">TP=\frac{任务数}{完成所有任务用时}=\frac{n}{T_k}</script><p>各流水段时间相等时</p><p><img src="/2022/06/24/CSAreview/image-20220623175511210.png" alt></p><script type="math/tex; mode=display">TP=\frac{n}{(k+n-1)\Delta t}\quadTP_{max}=\lim_{n\to\infty}{TP}=\frac{1}{\Delta t}</script><p>各流水段时间不等时</p><p><img src="/2022/06/24/CSAreview/image-20220623175102825.png" alt></p><script type="math/tex; mode=display">TP=\frac{n}{\sum_{i=1}^k{t_i}+(n-1)\max{(\Delta t_1,...,\Delta t_k)}}\quadTP_{max}=\lim_{n\to\infty}{TP}=\frac{1}{\max{(\Delta t_1,...,\Delta t_k)}}</script><p><strong>加速比 Speedup</strong></p><script type="math/tex; mode=display">S=\frac{顺序执行时间}{流水线执行时间}=\frac{T_0}{T_k}</script><p><strong>效率 Efficiency</strong></p><script type="math/tex; mode=display">E=\frac{n个任务占用的时空区}{k个流水段总的时空区}=\frac{T_0}{k\cdot T_k}</script><h2 id="非线性流水线的调度"><a href="#非线性流水线的调度" class="headerlink" title="非线性流水线的调度"></a>非线性流水线的调度</h2><p>找出一个最小的循环周期，按照这个周期向流水线输入新任务，流水线的各个功能段都不会发生冲突，且流水线的吞吐率和效率最高</p><p><strong>禁止向量</strong>：预约表中每一行任意两个<code>X</code>之间距离的集合</p><p><strong>冲突向量</strong>：$C=(C_mC_{m-1}…C_2C_1)$，m是禁止向量中的最大值</p><p><strong>状态图</strong>：将冲突向量逻辑右移，若移出去的位是1，则表示用相应启动距离向流水线输入新任务时会产生功能段冲突；若移出去的位是0，则表示不会产生功能段冲突，将右移结果与初始冲突向量逻辑或，结果为新的状态</p><p><strong>简单循环</strong>：在状态图中各种冲突向量只经过一次的启动循环</p><p><strong>启动距离</strong>：连续输入两个任务之间的时间间隔</p><h2 id="全局相关"><a href="#全局相关" class="headerlink" title="全局相关"></a>全局相关</h2><p><strong>动态分支预测技术</strong></p><ul><li>根据近期转移是否成功的记录来预测下一次转移的方向<ul><li>最近的一次或几次转移是否成功的信息记录在转移指令中</li><li>用一个高速缓冲栈保存条件转移指令地转移目标地址</li><li>用Cache保存转移目标地址之后的n条指令</li></ul></li><li>所有的动态转移预测方法都能够随程序的执行过程动态地改变转移的预测方向</li></ul><p><strong>静态分支预测技术</strong></p><ul><li>转移预测的方向是确定的，在程序实际执行过程中转移预测的方向不能改变</li><li>可以只用软件实现，也可用硬件来实现，还可以在转移的两个方向上都预取指令</li></ul><p><strong>提前形成条件码</strong></p><ul><li>乘除法，两个源操作数的符号相同结果为正，相反结果为负</li><li>乘法，有一个操作数为0，乘积为0</li><li>除法，被除数为0，商为0；除数为0，结果溢出</li><li>同号加或异号减，结果符号与第一操作数相同</li><li>异号加或同号减，结果符号与绝对值大的操作数相同</li><li>溢出及是否为0可通过一个比较器提前产生</li></ul><h1 id="第六章-向量处理机"><a href="#第六章-向量处理机" class="headerlink" title="第六章 向量处理机"></a>第六章 向量处理机</h1><h2 id="向量处理机的两种基本结构"><a href="#向量处理机的两种基本结构" class="headerlink" title="向量处理机的两种基本结构"></a>向量处理机的两种基本结构</h2><p><strong>存储器-存储器结构</strong></p><p>利用几个独立的存储器模块来支持相对独立的数据并发访问，从而达到所要求的存储器带宽</p><p><strong>寄存器-寄存器结构</strong></p><p>构造一个具有所要求带宽的高速中间存储器，并实现该高速中间存储器与主存储器之间的快速数据交换</p><h2 id="向量处理方式"><a href="#向量处理方式" class="headerlink" title="向量处理方式"></a>向量处理方式</h2><p><strong>横向处理方式</strong>：向量计算按行的方式从左到右进行</p><p><strong>纵向处理方式</strong>：向量计算按列的方式自上而下进行</p><p><strong>纵横处理方式</strong>：分组处理，组内纵向，组间横向</p><h2 id="向量链接技术的基本原理和执行时间的计算"><a href="#向量链接技术的基本原理和执行时间的计算" class="headerlink" title="向量链接技术的基本原理和执行时间的计算"></a>向量链接技术的基本原理和执行时间的计算</h2><blockquote><p>向量运算中的数据相关和功能部件冲突</p><p><img src="/2022/06/24/CSAreview/image-20220623203234718.png" alt></p></blockquote><p><strong>两条流水线的链接技术</strong>：当前一条指令的结果寄存器可以作为后继指令的操作数寄存器时，多条有数据相关的向量指令并行执行</p><p><strong>执行时间的计算</strong></p><p><img src="/2022/06/24/CSAreview/image-20220623203807011.png" alt></p><p>向量长度N    相加6拍    相乘7拍    在存储器读数6拍    打入寄存器1拍    启动功能部件1拍</p><ul><li><p>三条指令串行</p><script type="math/tex; mode=display">[(1+6+1)+N-1]+[(1+6+1)+N-1]+[(1+7+1+N-1)]=3N+22</script></li><li><p>前两条指令并行，第三条串行</p><script type="math/tex; mode=display">[(1+6+1)+N-1]+[(1+7+1)+N-1]=2N-15</script></li><li><p>采用向量链接技术</p><script type="math/tex; mode=display">1\left\{\begin{aligned}启动访存\\送浮加部件\end{aligned}\right\}+6\left\{\begin{aligned}访存\\浮加\end{aligned}\right\}+1\left\{\begin{aligned}存V_3\\存V_2\end{aligned}\right\}+1\left\{\begin{aligned}送浮乘部件\\送浮乘部件\end{aligned}\right\}+7\left\{\begin{aligned}浮乘\end{aligned}\right\}+1\left\{\begin{aligned}存V_4\end{aligned}\right\}+N-1=N+16</script></li></ul><h2 id="向量循环开采技术"><a href="#向量循环开采技术" class="headerlink" title="向量循环开采技术"></a>向量循环开采技术</h2><p>当向量的长度大于向量寄存器的长度时，必须把长向量分成长度固定的段，采用循环结构处理这个长向量</p><h2 id="向量处理机的性能评价"><a href="#向量处理机的性能评价" class="headerlink" title="向量处理机的性能评价"></a>向量处理机的性能评价</h2><p><strong>向量指令处理时间 $T_{vp}$</strong></p><script type="math/tex; mode=display">T_{vp}=T_s+T_{vf}+(n-1)T_c</script><p>$T_s$为向量流水线的建立时间    $T_{vf}$为向量流水线的流过时间    $T_c$为流水线的时钟周期</p><script type="math/tex; mode=display">T_{vp}=(T_{start}+n)T_c</script><p>启动时间$T_{start}$为从第一条向量指令开始执行到还差一个时钟周期就产生第一个结果所需的时钟周期数</p><p>编队：能在一个时钟周期内一起开始执行的几条向量指令（同一编队中的向量指令一定不存在流水部件冲突和数据相关性）</p><script type="math/tex; mode=display">T_{all}=\sum编队=\sum_{i=1}^m{T_{vp}^{(i)}}=\sum_{i=1}^m(T_{start}^{(i)}+n)T_c=(T_{start}+mn)T_c</script><p>当向量长度$n$大于向量寄存器长度$MVL$时需要分段开采</p><script type="math/tex; mode=display">T_{all}=\lceil\frac{n}{MVL}\rceil\times(T_{start}+T_{loop})+mn</script><p><strong>最大性能 $R_\infty$</strong></p><p>当向量长度为无穷大时向量处理机的最高性能</p><script type="math/tex; mode=display">R_{\infty}=\lim_{n\to\infty}\frac{向量执行序列中浮点运算次数\times 时钟频率}{向量指令序列执行所花费的时钟周期数}</script><p><img src="/2022/06/24/CSAreview/image-20220623215300972.png" alt="一个例子"></p><p><strong>半性能向量长度 $n_{1/2}$</strong></p><p>当向量处理机的性能为其最大性能的一半所需要的向量长度</p><p><img src="/2022/06/24/CSAreview/image-20220623215442195.png" alt="接上例"></p><p><strong>向量长度临界值 $n_v$</strong></p><p>对于某一计算任务而言，向量方式的处理速度优于标量串行方式处理速度时所需要的最小向量长度</p><p><img src="/2022/06/24/CSAreview/image-20220623215740472.png" alt="继续接上例"></p><h1 id="第七章-互联网络"><a href="#第七章-互联网络" class="headerlink" title="第七章 互联网络"></a>第七章 互联网络</h1><h2 id="互连网络的作用"><a href="#互连网络的作用" class="headerlink" title="互连网络的作用"></a>互连网络的作用</h2><p>互连网络是一种由开关元件按照一定的拓扑结构和控制方式构成的网络</p><ul><li><p>用来实现计算机系统中节点之间的相互连接</p></li><li><p>已成为并行处理系统的核心组成部分</p></li><li><p>对整个计算机系统的性能价格比有着决定性影响</p></li></ul><h2 id="互连函数"><a href="#互连函数" class="headerlink" title="互连函数"></a>互连函数</h2><p><strong>恒等函数</strong> 输入输出相同</p><script type="math/tex; mode=display">I(x_{n-1}x_{n-2}...x_0)=x_{n-1}x_{n-2}...x_0</script><p><strong>交换函数</strong> 第k位取反</p><script type="math/tex; mode=display">C_k(x_{n-1}x_{n-2}...x_0)=x_{n-1}x_{n-2}...\bar{x_k}...x_0</script><p><strong>均匀洗牌函数</strong> 循环左移一位</p><script type="math/tex; mode=display">\sigma(x_{n-1}x_{n-2}...x_1x_0)=x_{n-2}...x_1x_0x_{n-1}</script><p><strong>子洗牌</strong> 低k位循环左移一位</p><script type="math/tex; mode=display">\sigma_{(k)}(x_{n-1}...x_k{x_{k-1}...x_0})=x_{n-1}...x_k{x_{k-2}...x_0x_{k-1}}</script><p><strong>超洗牌</strong> 高k位循环左移一位</p><script type="math/tex; mode=display">\sigma^{(k)}({x_{n-1}...x_{n-k}}x_{n-k-1}...x_0)={x_{n-2}...x_{n-k}x_{n-1}}x_{n-k-1}...x_0</script><p><strong>逆混洗</strong> 循环右移一位</p><script type="math/tex; mode=display">\sigma^{-1}(x_{n-1}x_{n-2}...x_1x_0)=x_0x_{n-1}x_{n-2}...x_1</script><p><strong>蝶式互连函数</strong> 最高位和最低位互换</p><script type="math/tex; mode=display">\beta(x_{n-1}x_{n-2}...x_1x_0)=x_0x_{n-2}...x_1x_{n-1}</script><p><strong>子蝶式</strong> 低k位中的最高位和最低位互换</p><script type="math/tex; mode=display">\beta_{(k)}(x_{n-1}...x_k{x_{k-1}...x_0})=x_{n-1}...x_k{x_0x_{k-2}...x_1x_{k-1}}</script><p><strong>超蝶式</strong> 高k位中的最高位和最低位互换</p><script type="math/tex; mode=display">\beta^{(k)}({x_{n-1}...x_{n-k}}x_{n-k-1}...x_0)={x_{n-k}x_{n-2}...x_{n-k+1}x_{n-1}}x_{n-k-1}...x_0</script><p><strong>反位序函数</strong> 位置全部颠倒</p><script type="math/tex; mode=display">\rho(x_{n-1}...x_0)=x_0...x_{n-1}</script><p><strong>子反位序</strong> 低k位的位置颠倒</p><script type="math/tex; mode=display">\rho_{(k)}(x_{n-1}...x_k{x_{k-1}...x_0})=x_{n-1}...x_k{x_0...x_{k-1}}</script><p><strong>超反位序</strong> 高k位的位置颠倒</p><script type="math/tex; mode=display">\rho^{(k)}({x_{n-1}...x_{n-k}}x_{n-k-1}...x_0)={x_{n-k}...x_{n-1}}x_{n-k-1}...x_0</script><p><strong>移数函数</strong> 算每个位置的十进制</p><script type="math/tex; mode=display">\alpha(x)=(x\pm k)\mod N</script><p><strong>PM2I函数</strong> 一种移位函数</p><script type="math/tex; mode=display">PM2_{+i}(x)=(x+2^i)\mod N\\PM2_{-i}(x)=(x-2^i)\mod N</script><h2 id="静态互连网络的基本类型"><a href="#静态互连网络的基本类型" class="headerlink" title="静态互连网络的基本类型"></a>静态互连网络的基本类型</h2><blockquote><p>各节点之间有固定的连接通路，且在运行中不能改变</p></blockquote><p><strong>线性阵列</strong></p><p><img src="/2022/06/24/CSAreview/image-20220624110211231.png" alt></p><p><strong>环和带弦环</strong></p><p><img src="/2022/06/24/CSAreview/image-20220624110425325.png" alt></p><p><strong>循环移数网络</strong></p><p>在环上每个节点到所有与其距离为2的整数幂的节点之间增加一条附加链</p><p><img src="/2022/06/24/CSAreview/image-20220624110625741.png" alt></p><p><strong>树形和星形</strong></p><p><img src="/2022/06/24/CSAreview/image-20220624111046914.png" alt></p><p><strong>胖形树</strong></p><p><img src="/2022/06/24/CSAreview/image-20220624111116460.png" alt></p><p><strong>网格形与环网形</strong></p><p><img src="/2022/06/24/CSAreview/image-20220624111211738.png" alt></p><p><strong>超立方体</strong></p><p>n立方体把两个n-1立方体中相对应的节点用链路连接起来</p><p><img src="/2022/06/24/CSAreview/image-20220624111359629.png" alt></p><p><strong>带环立方体</strong></p><p>用n个节点构成的环取代n立方体中的每个节点</p><p><img src="/2022/06/24/CSAreview/image-20220624111509035.png" alt></p><h2 id="动态互连网络"><a href="#动态互连网络" class="headerlink" title="动态互连网络"></a>动态互连网络</h2><blockquote><p>由交换开关构成、可按运行程序的要求动态地改变连接状态</p><p><img src="/2022/06/24/CSAreview/image-20220624134121505.png" alt></p></blockquote><p><strong>多级立方体网络</strong></p><ul><li><p>采用2功能（直送和交换）的2x2开关</p></li><li><p>当第$i$级开关处于交换状态时，实现$Cube_i$互连函数</p></li><li>一个N输入的多级立方体网络有$\log_2 N$级，每级用$N/2$个2x2开关模块</li></ul><p><img src="/2022/06/24/CSAreview/image-20220624133953925.png" alt></p><p><strong>Omega网络</strong> 多级混洗交换网络</p><ul><li>采用4功能的2x2开关</li><li>级间互连采用<strong>均匀洗牌</strong>连接方式</li><li>一个N输入的多级立方体网络有$\log_2 N$级，每级用$N/2$个2x2开关模块</li></ul><p><img src="/2022/06/24/CSAreview/image-20220624140450988.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>ComputerSystemArchitecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU软件工程复习笔记</title>
    <link href="/2022/06/17/SEreview/"/>
    <url>/2022/06/17/SEreview/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><h2 id="Error-Fault-Failure的含义与联系"><a href="#Error-Fault-Failure的含义与联系" class="headerlink" title="Error, Fault, Failure的含义与联系"></a>Error, Fault, Failure的含义与联系</h2><p>错误Error：软件开发过程中人为产生的错误</p><p>缺陷Fault：在实现软件功能的时候存在的问题 是静态的</p><p>失败Failure：在运行时软件违背了它应该有的行为 是动态的</p><p>联系：人为错误 —可能导致—&gt; 故障 —可能导致—&gt; 失效</p><blockquote><p>故障是系统的内部视图，从开发人员的角度看待系统</p><p>失效是系统的外部视图，它是用户所看到的问题</p><p>并非每一个故障都对应一个失效</p></blockquote><h2 id="高质量软件的三个方面"><a href="#高质量软件的三个方面" class="headerlink" title="高质量软件的三个方面"></a>高质量软件的三个方面</h2><p><strong>产品的质量</strong></p><p>用户：外部特性。如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的</p><p>开发者：内部特性，比如缺陷的数量</p><p><strong>过程的质量</strong></p><p>量化模型CMM</p><p><strong>商业环境背景下的质量</strong></p><p>考虑的是产品的技术价值，假定改进的技术质量会自动转化为商业价值</p><h2 id="系统的要素"><a href="#系统的要素" class="headerlink" title="系统的要素"></a>系统的要素</h2><p>对象（实体）+ 活动 + 关系 + 系统边界</p><h2 id="Wasserman规范"><a href="#Wasserman规范" class="headerlink" title="Wasserman规范"></a>Wasserman规范</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>在某种概括层次上对问题的描述，使得我们能够集中于问题的关键方面而不会陷入细节</p><h3 id="分析、设计方法和符号描述系统"><a href="#分析、设计方法和符号描述系统" class="headerlink" title="分析、设计方法和符号描述系统"></a>分析、设计方法和符号描述系统</h3><p>使用标准对程序进行描述，不仅提供了交流媒介，还利于建立模型并检查模型的完整性和一致性</p><h3 id="用户界面原型化"><a href="#用户界面原型化" class="headerlink" title="用户界面原型化"></a>用户界面原型化</h3><p>构建一个系统的小版本用于帮助用户或客户表示系统的关键需求、证明设计或方法的可行性</p><h3 id="软件体系结构"><a href="#软件体系结构" class="headerlink" title="软件体系结构"></a>软件体系结构</h3><p>不仅对实现和测试的方便性很重要，而且对维护和修改系统的速度和有效性也很重要</p><h3 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h3><p>活动中的组织和规范 不同的软件类型需要不同的过程</p><p><img src="/2022/06/17/SEreview/image-20220616095800122.png" alt="不同开发中的差别"></p><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>复用以前开发项目中的项来利用应用程序之间的共性</p><blockquote><p>复用的不仅仅是代码</p></blockquote><h3 id="测度"><a href="#测度" class="headerlink" title="测度"></a>测度</h3><p>用通用数学语言描述行动和结果，使过程和产品的特定特性更加可见</p><h3 id="工具和集成环境"><a href="#工具和集成环境" class="headerlink" title="工具和集成环境"></a>工具和集成环境</h3><p>标准化的集成开发环境可以增强软件开发，还允许我们检验每个软件工程环境提供的服务，决定哪一个环境最适合于给定的问题或应用程序的开发</p><blockquote><p>CASE计算机辅助软件工程</p></blockquote><h1 id="第二章-过程和生命周期的建模"><a href="#第二章-过程和生命周期的建模" class="headerlink" title="第二章 过程和生命周期的建模"></a>第二章 过程和生命周期的建模</h1><h2 id="过程的含义和重要性"><a href="#过程的含义和重要性" class="headerlink" title="过程的含义和重要性"></a>过程的含义和重要性</h2><p>过程：一组有序的任务，涉及活动、约束和资源使用的一系列步骤</p><p>重要性：</p><ul><li>通用性：软件过程可以让一系列开发活动保持一致性和结构性</li><li>指导性：软件过程使我们可以分析、检查、理解、控制和改善软件开发活动</li></ul><h2 id="软件生命周期及各阶段文档"><a href="#软件生命周期及各阶段文档" class="headerlink" title="软件生命周期及各阶段文档"></a>软件生命周期及各阶段文档</h2><blockquote><p>软件生命周期：软件产品从概念到实现、交付、使用和维护的整个开发过程</p></blockquote><ol><li><p>需求分析<br>完成需求规格说明书（SRS）</p></li><li><p>系统设计<br>完成系统结构图（SAD）</p></li><li><p>程序设计<br>完成模块功能与数据描述文档</p></li><li><p>软件开发<br>完成开发记录文档</p></li><li><p>单元测试<br>按照程序设计中的要求进行测试，完成单元测试文档</p></li><li><p>集成测试<br>按照SAD测试，完成集成测试文档</p></li><li><p>系统测试<br>按照SRS进行测试，完成系统测试文档</p></li><li><p>系统提交<br>提交系统说明文档</p></li><li><p>维护<br>提交维护记录文档</p></li></ol><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><p>需求分析——《SRS》</p><p>系统设计——《SAD》</p><p>程序设计——《算法和数据描述文档》</p><p>编码——《源程序及注释》</p><p>单元测试和集成测试——《单元测试报告》</p><p>系统测试——《系统测试报告》</p><p>验收测试——《验收测试报告》</p><p>运行与维护——《维护报告》</p><p>优点：</p><ul><li>为项目提供了按阶段划分的检查点</li><li>当前一阶段完成后，只需要关注后续阶段</li><li>简单性：很容易向用户解释</li><li>提供了模板，使分析、设计、编码、测试和支持的方法有共同的指导</li></ul><p>缺点：</p><ul><li>不能适应用户需求的变化，不能反映实际的代码开发方式（迭代）</li><li>各个阶段的划分完全固定，阶段之间产生大量文档，极大地增加了工作量</li><li>由于开发模型是线性的，用户只有在整个过程末期才能见到开发成果，增加了开发风险</li><li>通过过多的强制完成日期和里程碑来跟踪各个项目阶段</li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>原型：一种部分开发的产品，用来让用户和开发者共同研究、提出意见，为最终的产品定型。</p><p>优点：</p><ul><li>有助于增进软件人员和用户对系统服务需求的理解</li><li>提供了一种有力的学习手段</li><li>容易确定系统的性能、服务的可应用性、设计的可行性和产品的结果</li><li>原型的最终版本可作为最终产品或最终系统的一部分</li></ul><p>缺点：</p><ul><li>文档容易被忽略</li><li>建立原型的许多工作会被浪费掉</li><li>项目难以规划和管理</li></ul><h2 id="阶段化开发"><a href="#阶段化开发" class="headerlink" title="阶段化开发"></a>阶段化开发</h2><p>缩短循环周期，使系统一部分一部分地交付，从而在系统其余部分正在开发的同时，用户已经获得了一部分功能</p><p><img src="/2022/06/17/SEreview/image-20220616132506585.png" alt="阶段化开发模型"></p><h3 id="增量开发"><a href="#增量开发" class="headerlink" title="增量开发"></a>增量开发</h3><p>需求文档中指定的系统按功能划分为子系统，定义发布时首先定义一个小的功能子系统，然后在每一个新的发布中增加新功能</p><p><img src="/2022/06/17/SEreview/image-20220616132747265.png" alt></p><h3 id="迭代开发"><a href="#迭代开发" class="headerlink" title="迭代开发"></a>迭代开发</h3><p>一开始就提交一个完整的系统，然后在每一个新的发布中改变每个子系统的功能</p><p><img src="/2022/06/17/SEreview/image-20220616132802346.png" alt></p><h3 id="增量-迭代结合"><a href="#增量-迭代结合" class="headerlink" title="增量+迭代结合"></a>增量+迭代结合</h3><p>一个新发布的版本可能包含新功能，并对已有功能做了改进</p><h2 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h2><p>把开发活动和风险管理结合起来，以将风险减到最小并控制风险</p><p>每次迭代有四个任务，依次是（四个象限）：计划、目标/可选方案、风险评估、 开发与测试</p><p>共有四次迭代，依次是（每个象限的四重循环）：操作概念、软件需求、软件设计、开发与测试</p><p><img src="/2022/06/17/SEreview/image-20220616133031881.png" alt="螺旋模型"></p><h2 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h2><p><strong>4条原则</strong></p><ul><li>个人和交互的价值 &gt; 过程和工具</li><li>生产运行的软件 &gt; 编写各种文档</li><li>与客户合作 &gt; 合同谈判</li><li>响应变化 &gt; 遵循计划</li></ul><p><strong>总体目标</strong></p><p>尽可能早地、持续地交付有价值的软件</p><p><strong>极限编程 XP</strong></p><p>交流、简单性、勇气、反馈</p><p><strong>水晶法 Crystal</strong></p><p>每一个不同的项目都需要一套不同的策略、约定和方法论</p><p><strong>并列争球法 Scrum</strong></p><p>使用迭代的方法，把每30天一次的迭代成为一个冲刺sprint，并按需求的优先级别来实现产品</p><p><strong>自适应软件开发 ASD</strong></p><h2 id="静态建模：Lai表示法"><a href="#静态建模：Lai表示法" class="headerlink" title="静态建模：Lai表示法"></a>静态建模：Lai表示法</h2><p>该模型范式中可由人员完成角色，由资源完成活动，最后导致软件工件/制品的产生。过程模型可以用角色、活动、加工项(工件)来显示彼此之间的关系，用状态表显示每个加工项(工件)在特定时间的完成情况</p><h2 id="动态建模：系统动力学"><a href="#动态建模：系统动力学" class="headerlink" title="动态建模：系统动力学"></a>动态建模：系统动力学</h2><p>推演过程，观察到资源流是如何通过活动成为输出的</p><h1 id="第三章-计划和管理项目"><a href="#第三章-计划和管理项目" class="headerlink" title="第三章 计划和管理项目"></a>第三章 计划和管理项目</h1><h2 id="活动图计算关键路径-CPM"><a href="#活动图计算关键路径-CPM" class="headerlink" title="活动图计算关键路径 CPM"></a>活动图计算关键路径 CPM</h2><p>对于每个活动，列出它的前驱，并计算最早开始时间、最晚开始时间和时差，然后确定出关键路径</p><blockquote><p>活动图上的<strong>结点</strong>为<strong>里程碑</strong>，<strong>边</strong>为<strong>活动</strong></p></blockquote><p>正推求最早开始时间</p><script type="math/tex; mode=display">ET_{B\cdot}=\max(ET_{AB}+w_{AB})</script><p>倒推求最晚开始时间</p><script type="math/tex; mode=display">LT_{AB}=\min(LT_{B\cdot}-w_{AB})</script><p>关键路径上的活动</p><script type="math/tex; mode=display">ET_{AB}=LT_{AB}</script><p>P97 习题2，3 <a href="https://blog.csdn.net/zhangt2333/article/details/107029298/">详解</a></p><h2 id="CPM-条状图"><a href="#CPM-条状图" class="headerlink" title="CPM 条状图"></a>CPM 条状图</h2><p>水平条表示每个活动的工期，星号组成的那些条表明它是关键路径，由虚线和 F 描述的活动不在关键路径上，F 表示时差或浮动时间。</p><p><img src="/2022/06/17/SEreview/image-20220616140227523.png" alt="CPM条状图"></p><h2 id="甘特图-Gantt"><a href="#甘特图-Gantt" class="headerlink" title="甘特图 Gantt"></a>甘特图 Gantt</h2><p>通过活动列表和时间刻度表示出特定项目的顺序和持续时间，用颜色或图标来指明完成的程度</p><p><img src="/2022/06/17/SEreview/image-20220616141045881.png" alt="甘特图"></p><h2 id="项目人员"><a href="#项目人员" class="headerlink" title="项目人员"></a>项目人员</h2><p><img src="/2022/06/17/SEreview/image-20220616141405286.png" alt="工作风格"></p><h2 id="项目组织"><a href="#项目组织" class="headerlink" title="项目组织"></a>项目组织</h2><p><img src="/2022/06/17/SEreview/image-20220616165311883.png" alt="组织结构的比较"></p><p>结构化较强的团队：</p><p>按时完成任务，但工作比较循规蹈矩，项目普通但是功能完备。适合人员较多，项目稳定性和一致性高，使用较正规的结构。</p><p>结构化较弱的团队：</p><p>不能按时完成任务但是创造性强，涉及大量的不确定性因素时采用较为民主的方法和相关的团队结构</p><h3 id="主程序员负责制小组-chief-programmer-team"><a href="#主程序员负责制小组-chief-programmer-team" class="headerlink" title="主程序员负责制小组 chief programmer team"></a>主程序员负责制小组 chief programmer team</h3><p>由一个人总体负责系统的设计和开发，其他的小组成员向该主程序员汇报，主程序员对每一个决定由最终决策权</p><p><img src="/2022/06/17/SEreview/image-20220616142446215.png" alt="主程序员负责制小组的组织结构"></p><p>优点：</p><ul><li>通过让主程序员负责所有决策，项目过程中需要的交流量最小化</li><li>迅速做出决定，效率高</li></ul><p>缺点：</p><ul><li>创造性低</li><li>对主程序员要求高，个人主观性强</li></ul><h3 id="忘我方法-egoless-approach"><a href="#忘我方法-egoless-approach" class="headerlink" title="忘我方法 egoless approach"></a>忘我方法 egoless approach</h3><p>每个人平等地担负责任，而且过程与个人是分开的，批评是针对产品和结果的，并不涉及个人，结构是民主式的，小组成员投票产生决策</p><h2 id="工作量估算"><a href="#工作量估算" class="headerlink" title="工作量估算"></a>工作量估算</h2><h3 id="专家判断"><a href="#专家判断" class="headerlink" title="专家判断"></a>专家判断</h3><p>缺点：专家判断不仅受到差异性和主观性的影响，还受到对当前数据依赖性的影响。大部分专家判断技术过于简单化，没有将大量可能影响项目所需工作量的因素考虑在内</p><p><strong>类推法</strong></p><p>做出3种预测：一个悲观的预测$(x)$，一个乐观的预测$(y)$，最可能的猜测$(z)$</p><p>通过公式$(x+4y+z)/6$计算这些数的beta概率分布的平均值</p><p><strong>Delphi技术</strong></p><p>专家秘密地进行个人预测，然后计算平均估算并提交给专家组，直到没有专家修正为止</p><p><strong>Wolverton模型</strong></p><p>软件成本2<em>3矩阵：老问题O/新问题N </em> 容易的E/适中的M/困难的H</p><p>把将要实现的软件系统划分成模块，然后根据代码行估算每一个模块的规模，使用矩阵计算每一个模块的成本，然后把所有模块的成本求和</p><h3 id="算法方法"><a href="#算法方法" class="headerlink" title="算法方法"></a>算法方法</h3><script type="math/tex; mode=display">E=(a+bS^c)m(X)</script><p>其中 $S$ 是估算的系统规模，而 $a, b, c$ 是常量，$X$ 是从 $x_1$ 到 $x_n$ 的一个成本因素的向量，$m$ 是基于这些因素的一个调整因子</p><h4 id="Walston-and-Felix-1977"><a href="#Walston-and-Felix-1977" class="headerlink" title="Walston and Felix 1977"></a>Walston and Felix 1977</h4><script type="math/tex; mode=display">E=5.25S^{0.91}</script><p>P98 习题6</p><h4 id="COCOMO-模型"><a href="#COCOMO-模型" class="headerlink" title="COCOMO 模型"></a>COCOMO 模型</h4><script type="math/tex; mode=display">E=bS^cm(X)</script><p>【阶段1】</p><p>项目通常构建原型以解决包含用户界面、软件和系统交互、性能和技术成熟性等方面在内的高风险问题</p><p>使用应用点AP进行规模测量</p><p>① 计算应用中将要包含的屏幕、报告和第三代语言的构件数目</p><p>② 将每个应用元素分类为简单、适中或难3个级别</p><p><img src="/2022/06/17/SEreview/image-20220616191008771.png" alt></p><p><img src="/2022/06/17/SEreview/image-20220616191029343.png" alt></p><p>③ 把加权的报告或屏幕求和，以得到一个单独的应用点的数。如果对象种有 $r\%$ 将从以前的项目中复用，则新的应用点的数目可以计算为 $新应用点=应用点\times(100-r)/100$ </p><p>④ 根据开发人员的经验和能力、CASE成熟度和能力，使用一个称为生产率比率的调整因子</p><p><img src="/2022/06/17/SEreview/image-20220616191051314.png" alt></p><p>⑤ 所需的人月数是新的应用点数除以生产率因子</p><p>【阶段2】</p><p>早期设计阶段，已经决定将项目开发向前推进，但设计人员必须研究几种可选的体系结构和操作的概念</p><p>使用功能点FP进行规模测量</p><p>【阶段3】</p><p>后体系结构阶段，开发已经开始，且已经知道相当多的信息</p><p>根据功能点或代码行来进行规模估算，而且可以较为轻松地估算很多成本因素</p><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p><strong>风险影响</strong>：与风险有关的损失</p><p><strong>风险概率</strong>：从0到1对风险进行的测量</p><blockquote><p>当风险概率为1时，则称该风险为<strong>问题</strong></p></blockquote><p><strong>风险暴露</strong> </p><script type="math/tex; mode=display">风险暴露=风险影响\times 风险概率</script><p>即数学期望，用于量化风险所造成的影响</p><p><strong>风险管理活动</strong></p><p><img src="/2022/06/17/SEreview/image-20220616192823806.png" alt="风险管理的步骤"></p><p><strong>降低风险的3种策略</strong></p><ul><li>避免风险：改变性能或功能需求</li><li>转移风险：把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失</li><li>假设风险会发生，接受并用项目资源控制风险</li></ul><p><strong>风险杠杆</strong></p><script type="math/tex; mode=display">风险杠杆=(降低前的风险暴露-降低后的风险暴露)/(降低风险的成本)</script><p>决策如何降低风险时，考虑降低风险的成本，如果杠杆值不够高，那么要寻求代价更低或更有效的风险降低技术</p><blockquote><p>在某些情况下可以选取一种<strong>开发过程</strong>来帮助我们降低风险</p><p>例如，<strong>原型化</strong>可以改善对需求和设计的理解</p><p>Boehm的十大风险事项</p><div class="table-container"><table><thead><tr><th>风险</th><th>推荐的风险管理技术</th></tr></thead><tbody><tr><td>人员短缺</td><td>配备最强能力的人员；合适地安排工作；团队建设；增强士气；交叉培训；预先安排关键人员</td></tr><tr><td>不现实的进度和预算</td><td>详细的、多源的成本和进度估算；根据成本进行设计；增量开发；软件复用；精简需求</td></tr><tr><td>开发错误的软件功能</td><td>组织分析；人物分析；明确表示操作概念；用户调查；原型化；早期用户手册</td></tr><tr><td>开发错误的用户界面</td><td>原型化；场景；任务分析</td></tr><tr><td>华丽的计划</td><td>精简需求；原型化；成本-收益分析；根据成本进行设计</td></tr><tr><td>持续的需求变化</td><td>提高变化阈值；信息隐藏；增量开发</td></tr><tr><td>外部执行的任务未达到要求</td><td>引用检查；对审核先给予奖励；奖惩合同；优胜劣汰的设计或原型化；团队建设</td></tr><tr><td>外部提供的构件达不到要求</td><td>基准；审查；引用检查；兼容性分析</td></tr><tr><td>实时性能达不到要求</td><td>模拟；基准；建模；原型化；使用仪器；调优</td></tr><tr><td>超出计算机科学的能力</td><td>技术分析；成本-收益分析；原型化；引用检查</td></tr></tbody></table></div></blockquote><h1 id="第四章-获取需求"><a href="#第四章-获取需求" class="headerlink" title="第四章 获取需求"></a>第四章 获取需求</h1><h2 id="需求过程"><a href="#需求过程" class="headerlink" title="需求过程"></a>需求过程</h2><p><img src="/2022/06/17/SEreview/image-20220616194632755.png" alt="获取需求的过程"></p><p>① 原始需求获取：客户给出的需求</p><p>② 问题分析：理解需求并通过建模或模型化方式进行描述</p><p>③ 规格说明：利用符号描述系统将定义规范化表示</p><p>④ 需求确认：检查规格说明是否与客户需求匹配</p><p>⑤ 形成软件需求规格说明书<strong>SRS</strong></p><p><strong>敏捷需求建模</strong></p><p>适用范围：小团队，不确定的需求</p><p>方法：递增地收集和实现需求，增量式开发</p><p><strong>“重量级”过程</strong></p><p>适用范围：大团队，确定的需求</p><p>特点：开发人员将编码推迟到已经对需求进行了建模和分析，详细的设计已经完成，其中每一步都需要模型，且模型之间是相关的、相互配合的，以便于使设计完全实现需求</p><h2 id="需求引发的手段"><a href="#需求引发的手段" class="headerlink" title="需求引发的手段"></a>需求引发的手段</h2><blockquote><p><strong>风险承担者</strong></p><p>委托人（要为开发的软件支付费用的人）</p><p>客户（软件开发之后购买软件的人）</p><p>用户（熟悉当前系统并将使用最终系统的人）</p><p>领域专家（对软件必须自动化的问题很熟悉的人）</p><p>市场研究人员（进行调查来确定未来趋势和潜在客户需求的人）</p><p>律师或审计人员（对政府、安全性以及法律的需求熟悉的人）</p><p>软件工程师或其他技术专家</p></blockquote><ul><li><p>与风险承担者进行会谈</p></li><li><p>评审可用文档</p></li><li><p>观察当前系统</p></li><li><p>做用户的学徒，在用户执行任务的时候详细学习</p></li><li><p>以小组的方式与用户和风险承担者进行交谈，以便相互启发</p></li><li><p>使用特定领域的策略，确保风险承担者考虑与特殊情形相关的特定类型的需求</p></li><li><p>与当前的和潜在的用户集体讨论如何改进打算要构建的产品</p></li></ul><p><img src="/2022/06/17/SEreview/image-20220616200854552.png" alt="可能的需求源"></p><h2 id="需求的类型"><a href="#需求的类型" class="headerlink" title="需求的类型"></a>需求的类型</h2><p><strong>功能需求</strong>：描述系统内部功能或系统与外部功能的交互作用，涉及系统对输入的反应、实体状态变化、输出结果</p><p><strong>质量需求(非功能需求)</strong>：描述软件解决方案必须拥有的质量特性，如性能、易使用性、高可靠性或低维护代价</p><p><strong>设计约束</strong>：已经做出的设计决策或限制问题解决方案集的设计决策，如平台或构件接口的选择</p><p><strong>过程约束</strong>：对用于构建系统的技术和资源的限制</p><blockquote><p>功能需求定义问题解决方案空间的边界，质量需求、设计约束以及过程约束通过将可接受的、喜欢的解决方案与无用的产品加以区分，进一步限制了解决方案空间</p></blockquote><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>请求客户对需求进行优先级划分</p><ol><li><p>（必需的）绝对要满足的的需求</p></li><li><p>（值得要的）非常值得要的但并非必需的需求</p></li><li><p>（可选的）可要可不要的需求</p></li></ol><h3 id="两种需求文档"><a href="#两种需求文档" class="headerlink" title="两种需求文档"></a>两种需求文档</h3><p><strong>需求定义</strong>：客户想要的每一件事情的完整列表</p><p>面向业务相关的人员，例如委托人、客户、用户</p><p><strong>需求规格说明</strong>：将需求重新陈述为关于要构建的系统将如何运转的规格说明</p><p>面向技术性人员，例如设计人员、测试人员、项目经理</p><p><img src="/2022/06/17/SEreview/image-20220616203951052.png" alt="需求定义与需求规格说明"></p><p>区别：需求定义可以处于环境域的任何地方，需求规格说明仅仅限制在环境域和系统域的交集处（共享的接口）</p><blockquote><p>在将需求细化为规格说明时，没有丢失或改变信息</p><p>在定义文档中的每一条需求与规格说明文档的需求之间必须有直接的对应关系</p></blockquote><h2 id="需求的特性"><a href="#需求的特性" class="headerlink" title="需求的特性"></a>需求的特性</h2><p>正确的</p><p>一致的</p><p>无二义性的</p><p>完备的</p><p>可行的</p><p>相关的</p><p>可测试的</p><p>可跟踪的</p><h2 id="建模表示法"><a href="#建模表示法" class="headerlink" title="建模表示法"></a>建模表示法</h2><blockquote><p>7种基本的表示法范型 + 最适合的问题类型和描述 + 具体例子</p></blockquote><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><p>一种表示概念模型的图形表示法范型</p><p><strong>实体</strong>表示为矩形，代表具有共同性质和行为的现实世界对象构成的集合</p><p><strong>属性</strong>是实体上的注释，描述实体相关的数据或性质</p><p><strong>联系</strong>表示为两个实体之间的边，边的中间有一个菱形，说明联系的类型</p><p><img src="/2022/06/17/SEreview/image-20220616210103433.png" alt="十字转门问题的E-R图"></p><blockquote><p>主要说明实体之间是如何联系的，而没有关于实体行为的任何信息</p><p>适合在需求过程的早期用于建模问题，因为它们提供要解决的问题的总体概况，而且当问题的需求发生变化时该视图是相对稳定的</p></blockquote><h4 id="例子：UML类图"><a href="#例子：UML类图" class="headerlink" title="例子：UML类图"></a>例子：UML类图</h4><p>每一个方框是一个<strong>类</strong>，表示一组相似类型的实体</p><p>一个类具有<strong>名称</strong>、<strong>属性</strong>集和类的属性上的<strong>操作</strong>集</p><p><strong><u>类范围属性</u></strong>用带下划线的属性表示，是被类的所有实例共享的数据值</p><p><strong><u>类范围操作</u></strong>用带下划线的操作表示，作用于一个新的实例或整个实例集</p><p>两个类之间的连线为<strong>关联</strong>，表示类的实体之间的联系</p><p>一端带有空心菱形的关联为<strong>聚合关联</strong>，表示 A &lt;—has a— B</p><p>一端带有实心菱形的聚合为<strong>组装关联</strong>，表示 A &lt;—由— B 组成</p><p>一端带有三角形的关联为<strong>泛化关联</strong>，表示 A &lt;—是— B 的父类，一个子类继承其父类的所有属性、操作和关联</p><p><img src="/2022/06/17/SEreview/image-20220617220938624.png" alt></p><h3 id="事件踪迹"><a href="#事件踪迹" class="headerlink" title="事件踪迹"></a>事件踪迹</h3><blockquote><p>是关于现实世界实体之间交换的事件序列的图形描述</p></blockquote><p>每一条竖线表示不同实体的时间线，其名字出现在线的顶部</p><p>每一条水平线表示两个实体之间的一个事件或交互</p><p>时间按从顶到下的踪迹进展</p><p><img src="/2022/06/17/SEreview/image-20220616213227305.png" alt="十字转门问题中的事件踪迹"></p><blockquote><p>广泛应用于开发人员和客户中，因为除了计时问题，事件踪迹的语义相对精简，还简单、易于理解。但对于文档化系统的行为并不是非常有效的，因为场景数目会难以处理</p><p>最好用在项目的开始以对关键需求达成共识，并帮助开发人员识别正在建模的问题中的重要实体</p></blockquote><h4 id="例子：消息时序图-MSC"><a href="#例子：消息时序图-MSC" class="headerlink" title="例子：消息时序图 MSC"></a>例子：消息时序图 MSC</h4><p><img src="/2022/06/17/SEreview/image-20220616214727566.png" alt></p><blockquote><p>只用于描述关键的场景，而不是说明整个问题</p></blockquote><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><blockquote><p>描述系统与其环境之间的所有对话，用于在单个模型中表示一组事件踪迹</p></blockquote><p>每一个节点称为<strong>状态</strong>，表示存在于事件发生之间的一个稳定的条件集合</p><p>每一个边称为<strong>转移</strong>，表示由于一个事件的发生而产生的行为或条件的变化</p><p>每一个转移都标记有触发事件，还可能有输出事件，输出时间是在转移发生时产生的</p><p><img src="/2022/06/17/SEreview/image-20220616215721040.png" alt="十字转门的有限状态机模型"></p><blockquote><p>特别适合的建模模型是：随着系统的执行过程，对于同样的输入，系统响应是如何变化的</p></blockquote><h4 id="例子：-UML状态图"><a href="#例子：-UML状态图" class="headerlink" title="例子： UML状态图"></a>例子： UML状态图</h4><blockquote><p>精细地将问题的动态行为模块化，标识为单个类的对象的行为，这种模块化使得难以了解对象之间是如何交互的</p></blockquote><p>圆角矩形表示<strong>状态</strong></p><p>实心圆表示<strong>起点</strong></p><p>内部包含实心圆的圆表示<strong>终点</strong></p><p>一个超状态可能实际上包含多个并发的子状态机，由虚线分开</p><p><img src="/2022/06/17/SEreview/image-20220616221052346.png" alt="Publication类的UML状态图"></p><p>状态转移标记的语法为：<code>event(args) [condition] /action* ^Object.event(args)*</code></p><p>触发<strong>事件</strong>是一个可能携带参数的消息</p><p>激活<strong>条件</strong>由方括号括起来，是关于对象属性值的谓词</p><p>如果一个转移发生，其<strong>动作</strong>表示对象属性的赋值</p><p>如果该转移发生，他可能生成任意多个<strong>输出事件</strong></p><h4 id="例子：Petri网"><a href="#例子：Petri网" class="headerlink" title="例子：Petri网"></a>例子：Petri网</h4><blockquote><p>用于建模并发活动以及它们之间的交互</p></blockquote><p>圆圈称为<strong>位置</strong>，表示活动或条件</p><p>条表示<strong>变迁</strong></p><p>有向的箭头称为<strong>弧</strong>，将变迁与其输入位置和输出位置连接起来</p><p>位置中放置的是<strong>令牌</strong>，作为变迁的启动条件。当变迁被触发时，清除每一个输入位置中的令牌，并将令牌插入每一个输出位置</p><p>为每一条弧分配一个<strong>权重</strong>，指出在变迁触发的时候令牌的变化数目</p><p>如果变迁的每一个输入位置包含足够的令牌，则一个变迁是<strong>可激活的</strong></p><p><img src="/2022/06/17/SEreview/image-20220616222301050.png" alt="描述借书的Petri网"></p><blockquote><p>并发和同步的特征对于建模发生顺序不重要的时间特别有用</p></blockquote><h3 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图 DFD"></a>数据流图 DFD</h3><blockquote><p>建模功能以及从一个功能到另一个功能的数据流</p></blockquote><p>一个泡泡表示一个<strong>加工</strong>或<strong>功能</strong>，它转换数据</p><p>箭头表示<strong>数据流</strong>，进入泡泡的箭头表示其功能的输入，从泡泡出去的箭头表示其功能的输出</p><p><strong>数据存储</strong>是一个正式的库或信息库，表示为两个平行的条</p><p>数据源或数据接收器表示为矩形，称为<strong>参与者</strong>，提供输入数据或接受输出结果的实体</p><p><img src="/2022/06/17/SEreview/image-20220617101428726.png" alt="图书馆问题的数据流图"></p><blockquote><p>优点：提供了两种直观模型，一种是关于被提议系统的高层功能的，一种是各种加工之间的数据依赖关系</p><p>缺点：对于不太熟悉正在建模问题的软件开发人员而言数据流图是更加含糊不清的</p><p>最好由熟悉正在建模的应用领域的用户使用，并且最好作为问题的早期模型使用</p></blockquote><h4 id="例子：UML用例图"><a href="#例子：UML用例图" class="headerlink" title="例子：UML用例图"></a>例子：UML用例图</h4><p>根据系统和系统的环境之间的交互，描述可观察到的、用户发起的功能</p><p>大的方框表示<strong>系统的边界</strong></p><p>方框外的小人表示<strong>参与者</strong>，包括人或系统</p><p>方框之内的椭圆是<strong>用例</strong>，表示必需的主要功能及其变种</p><p>参与者与用例之间的线表明参与者<strong>参与</strong>了该用例</p><p>如果存在一个若干用例<strong>共有的</strong>步骤序列，则将该序列抽取出来形成一个子用例，以被基用例调用 <code>基用例 --&lt;&lt;include&gt;&gt;--&gt; 子用例</code></p><p>一个用例还可以附加上一个<strong>扩充的</strong>子用例，在该用例的后面增加功能 <code>基用例 &lt;--&lt;&lt;extend&gt;&gt;-- 扩充子用例</code></p><p><img src="/2022/06/17/SEreview/image-20220617102147669.png" alt="图书馆用例"></p><h3 id="函数和关系"><a href="#函数和关系" class="headerlink" title="函数和关系"></a>函数和关系</h3><blockquote><p>基于数学的规格说明和设计技术称为形式化方法，可以自动化地检查很多形式化规格说明的一致性、完备性、非确定性、可达状态以及类型正确性</p><p>将需求或软件行为建模为一组数学函数或关系，当组合在一起的时候，将系统输入映射到系统输出</p></blockquote><p>一些函数说明系统的执行状态，一些函数说明输出</p><p>当一个输入值映射到多个输出值时，使用关系而不使用函数</p><p><img src="/2022/06/17/SEreview/image-20220617102956548.png" alt="十字转门问题的两个函数"></p><blockquote><p>函数规格说明有助于系统地、直观地测试一致性和完备性</p></blockquote><h4 id="例子：判定表"><a href="#例子：判定表" class="headerlink" title="例子：判定表"></a>例子：判定表</h4><blockquote><p>是函数规格说明的表格式表示，将事件和条件映射到适当的反应或动作上</p></blockquote><p>所有可能的输入事件、条件、动作都列在表的左边；输入事件和条件列在水平线的上面，动作列在水平线的下面</p><p>每一个列表示将一组条件映射到其对应结果的规则</p><p><code>T</code> 表示该行的输入条件为真；<code>F</code> 表示该行的输入条件为假；<code>-</code> 表示条件的值无关紧要</p><p><code>X</code> 表示只要其对应的输入条件成立，该行的动作就应该执行</p><p><img src="/2022/06/17/SEreview/image-20220617103628270.png" alt="图书馆函数的判定表"></p><blockquote><p>优点：很容易地检查是否考虑了条件的每一个组合以确定规格说明是否完备；通过识别同一输入条件地多个实例以及删除任何冲突的输出进行一致性检查；搜索表中的模式以了解个别输入条件与个别动作之间相互关联的程度</p></blockquote><h4 id="例子：Parnas表"><a href="#例子：Parnas表" class="headerlink" title="例子：Parnas表"></a>例子：Parnas表</h4><p>使用行和列将函数的定义分割为不同的情况，表的每一个条目要么指定部分地识别某些情况的一个输入条件，要么指定某些情况的输出值。与判定表不同的是，Parnas表的输入和输出是纯数学表达式</p><p><img src="/2022/06/17/SEreview/image-20220617104337769.png" alt="calc due date的Parnas表"></p><p>要注意如何对行和列的头进行组织，以涵盖所有可能的条件组合</p><blockquote><p>与状态机模型相比，这种模型结构的优点是，每一个输出变量的定义都局部化在一个不同的表中，而不是散布在模型中</p></blockquote><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><blockquote><p>描述性的表示法更适合于表达全局性质或约束，如E-R图、逻辑</p></blockquote><p><strong>一阶逻辑</strong></p><p>包含类型变量、常量、函数、谓词（$&gt;, &lt;, =, \wedge, \vee , \neg, \Rightarrow, \Leftrightarrow$）、量词（$\exists, \forall$）</p><p><img src="/2022/06/17/SEreview/image-20220617105503052.png" alt="十字转门的一阶逻辑表示"></p><p><strong>时态逻辑</strong></p><p>引入额外的逻辑连接符用以约束变量是如何随着时间的变化改变其值的</p><p><img src="/2022/06/17/SEreview/image-20220617105851624.png" alt="时态逻辑连接符"></p><p><img src="/2022/06/17/SEreview/image-20220617105909206.png" alt="十字转门的时态逻辑表示"></p><h4 id="例子：对象约束语言OCL"><a href="#例子：对象约束语言OCL" class="headerlink" title="例子：对象约束语言OCL"></a>例子：对象约束语言OCL</h4><p>专门为表述对象模型（如ER图）上的约束而设计的一种语言</p><p>以UML注释的形式出现在UML图中，或在支持文档中列举</p><p>能增强UML的很多模型：可以表示类图中的不变量、前置条件以及后置条件，状态图中的不变量、状态转移条件，消息时序图中事件的条件</p><h4 id="例子：Z"><a href="#例子：Z" class="headerlink" title="例子：Z"></a>例子：Z</h4><p>将集合论的变量定义组织到一个问题的完整的抽象数据类型模型当中，并使用逻辑来表示每一个操作的前置条件和后置条件</p><p>Z利用抽象方法将规格说明分解为可管理规模的模块，称为模式</p><p><img src="/2022/06/17/SEreview/image-20220617111722202.png" alt="Z符号"></p><h3 id="代数规格说明"><a href="#代数规格说明" class="headerlink" title="代数规格说明"></a>代数规格说明</h3><p>通过指定操作对之间的相互作用，而不是建模单个操作，来指定操作的行为</p><p>但对于一个操作集，构造一个完备的、一致的、正确的公理集是很难的</p><h4 id="例子：SDL数据"><a href="#例子：SDL数据" class="headerlink" title="例子：SDL数据"></a>例子：SDL数据</h4><p>用于创建规格说明和描述语言中的用户定义数据类型以及参数化的数据类型</p><p><img src="/2022/06/17/SEreview/image-20220617125850196.png" alt="图书馆问题的SDL数据规格说明"></p><h2 id="规格说明和描述语言SDL"><a href="#规格说明和描述语言SDL" class="headerlink" title="规格说明和描述语言SDL"></a>规格说明和描述语言SDL</h2><p>SDL包括3个主要的图，外加定义复杂数据类型的代数规格说明</p><ul><li>SDL系统图(DFD)</li><li>SDL方框图(DFD)</li><li>SDL进程图(状态机)</li></ul><p><img src="/2022/06/17/SEreview/image-20220617130316394.png" alt="SDL图形表示法"></p><h2 id="快速原型化"><a href="#快速原型化" class="headerlink" title="快速原型化"></a>快速原型化</h2><p><strong>抛弃型原型 throwaway</strong></p><p>仅用于了解问题、快速解决问题，用完抛弃</p><p><strong>演化型原型 evolutionary</strong></p><p>不仅用于了解问题、解决问题，还要演变为最终产品</p><blockquote><p>探索需求问题的两种方式 —— 建模 or 原型化？</p><p>取决于问题是什么，用模型表示更合适还是用软件表示更合适，构建模型或构建软件哪个更快</p><p>用原型更容易回答关于用户界面的问题；用模型更容易回答关于事件发生顺序这样的约束问题，或者关于活动的同步问题</p></blockquote><h1 id="第五章-设计体系结构"><a href="#第五章-设计体系结构" class="headerlink" title="第五章 设计体系结构"></a>第五章 设计体系结构</h1><h2 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h2><p><img src="/2022/06/17/SEreview/image-20220617132016163.png" alt="软件体系结构开发过程"></p><p>① 建模：根据需求描述的系统的关键特性尝试可能的分解</p><p>② 分析：分析初步的体系结构，主要关注系统级别的决策</p><p>③ 文档化：确定各个不同的模型视图</p><p>④ 评审：检查体系结构是否满足需求</p><p>⑤ 形成软件体系结构文档 SAD</p><h2 id="体系结构风格"><a href="#体系结构风格" class="headerlink" title="体系结构风格"></a>体系结构风格</h2><h3 id="管道和过滤器"><a href="#管道和过滤器" class="headerlink" title="管道和过滤器"></a>管道和过滤器</h3><p><img src="/2022/06/17/SEreview/image-20220617133532836.png" alt="管道和过滤器"></p><p>优点：</p><ul><li>简单易懂</li><li>可复用</li><li>可扩展性</li><li>并发性</li><li>便于系统分析</li></ul><p>缺点：</p><ul><li>批处理方式不适合交互式应用系统</li><li>没有通用的数据传输标准，每个过滤器都要解析和反解析数据，阻碍系统性能</li><li>难以进行错误处理</li></ul><h3 id="客户-服务器"><a href="#客户-服务器" class="headerlink" title="客户-服务器"></a>客户-服务器</h3><p><img src="/2022/06/17/SEreview/image-20220617134315361.png" alt="三层客户-服务器体系结构"></p><p>优点：</p><ul><li>有利于分布式数据的组织和管理</li><li>支持构件重用</li><li>构件之间彼此独立、充分隔离，转移计算机进程可以提高系统性能</li><li>提高系统模块化</li><li>在进程分配活动上赋予设计人员更大的灵活性</li></ul><p>缺点：</p><ul><li>数据安全性不高</li><li>维护成本高</li><li>开发成本高</li></ul><h3 id="对等网络-P2P"><a href="#对等网络-P2P" class="headerlink" title="对等网络 P2P"></a>对等网络 P2P</h3><p>每个构件本身既是客户端又是服务器 文件共享网络</p><p>优点：</p><ul><li>可扩展性，用户的加入增加了系统容量</li><li>数据被很多同级构件复制并且分布其间，对于构件和网络故障容错性高</li><li>非中心离散化避免出现服务器性能瓶颈</li><li>有效利用网络中的闲置资源进行计算、存储</li><li>数据传播直接在节点之间进行，速度快</li></ul><p>缺点：</p><ul><li>无法确保传输数据的安全性和质量</li><li>版权问题、管理困难、垃圾信息、占用带宽、病毒</li><li>脆弱性，易被黑客攻击</li></ul><h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布-订阅"></a>发布-订阅</h3><p>构件之间通过对事件的广播和反应实现交互 隐含调用</p><p>优点：</p><ul><li>为系统演化和可定制性提供了强有力的支持</li><li>可复用</li><li>低耦合，发布者只发布然后等待反应，订阅者只对事件做出反应</li></ul><p>缺点：</p><ul><li>不能独立地测试</li><li>消耗一定的时间和内存</li><li>过度使用会导致程序难以跟踪维护</li></ul><h3 id="信息库"><a href="#信息库" class="headerlink" title="信息库"></a>信息库</h3><p>由中心数据存储以及与其相关联的访问构件组成</p><p>两种类型构件的交互：访问数据的构件是主动/被动的——传统数据库/黑板类型</p><p><img src="/2022/06/17/SEreview/image-20220617144738428.png" alt="典型的黑板系统"></p><p>优点：</p><ul><li>便于多用户共享大量数据</li><li>便于将构件作为知识源添加到系统中去</li></ul><p>缺点：</p><ul><li>设计难度大，需要同步机制和加锁机制保证数据的完整性和一致性</li><li>不同知识源间共享的数据结构要达成一致</li></ul><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>将系统的软件单元按层次化组织，每一层为它的上层提供服务，同时作为下层的客户</p><p>优点：</p><ul><li>将系统分解从而完成复杂的业务逻辑</li><li>开发人员可以只关注其中某一层</li><li>可移植性</li><li>可维护性</li><li>降低层与层之间的依赖</li><li>有利于标准化</li></ul><p>缺点：</p><ul><li>层次之间频繁的调用和数据传输降低了系统性能</li><li>不是所有系统都能按层次划分</li><li>多层结构难以调试</li></ul><h3 id="组合体系结构风格"><a href="#组合体系结构风格" class="headerlink" title="组合体系结构风格"></a>组合体系结构风格</h3><p><img src="/2022/06/17/SEreview/image-20220617150040972.png" alt="发布-订阅、客户-服务器和信息库体系结构风格的组合"></p><h2 id="满足质量属性的策略"><a href="#满足质量属性的策略" class="headerlink" title="满足质量属性的策略"></a>满足质量属性的策略</h2><h3 id="可修改性"><a href="#可修改性" class="headerlink" title="可修改性"></a>可修改性</h3><p>使受直接影响的软件单元数量最少，将设计中的预期改变集中在一起：</p><ul><li>预测预期改变</li><li>保持高内聚性</li><li>足够高的通用性</li></ul><p>使受间接影响的软件单元数量最少，减少单元之间的依赖关系：</p><ul><li>降低耦合度</li><li>单元间只通过接口交互</li><li>多重接口</li></ul><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>包括响应时间、吞吐量、负载</p><ul><li>增加计算资源</li><li>提高资源利用率（增加软件并行程度）</li><li>有效管理资源分配</li><li>降低对资源的需求</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>高免疫力：能阻挡攻击企图</p><ul><li>在设计中保证包含所有安全性特征</li><li>将可能被攻击者利用的安全性弱点最小化</li></ul><p>高弹性：能快速容易地从攻击中恢复</p><ul><li>把功能分段</li><li>使系统能在一小段时间里快速恢复功能和性能</li></ul><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>与软件本身内部是否有错误有关</p><p>主动故障检测</p><ul><li><p>周期性检查</p></li><li><p>使用某种形式的冗余 n版本编程</p></li></ul><p>故障恢复</p><ul><li>撤销事务</li><li>检验点/回退</li><li>备份</li><li>服务降级</li><li>修正和继续</li><li>报告</li></ul><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>与软件容忍错误或外部环境异常时的表现有关</p><ul><li>互相怀疑</li></ul><h3 id="易使用性"><a href="#易使用性" class="headerlink" title="易使用性"></a>易使用性</h3><ul><li>用户界面放置于自己的软件单元中方便为不同用户定制</li><li>能够检测和响应任何预期的用户输入</li><li>维护一个环境模型支持系统发起的活动要求</li></ul><h3 id="商业目标"><a href="#商业目标" class="headerlink" title="商业目标"></a>商业目标</h3><ul><li>购买与开发</li><li>最初的开发成本与维护成本</li><li>新的技术与已知的技术</li></ul><h2 id="故障树分析"><a href="#故障树分析" class="headerlink" title="故障树分析"></a>故障树分析</h2><ul><li>给割集树的顶点分配节点，使得该节点与故障树顶部的第一个逻辑门相对应</li><li>自顶向下地进行，按以下步骤扩展割集树<ul><li>扩展或门节点得到两个子节点，分别是或门的两个子节点</li><li>扩展与门节点得到一个合成的子节点，由与门的两个子节点组合而成</li><li>扩展组合节点中的一个逻辑门产生子节点，并把该组合节点中的其他逻辑门传播到各子节点中去</li></ul></li><li>持续进行，直到所有的子节点都是基本事件节点或者基本事件的合成节点</li></ul><p><img src="/2022/06/17/SEreview/image-20220615214338880.png" alt="由故障树生成割集树"></p><h2 id="KWIC的不同设计方案对比"><a href="#KWIC的不同设计方案对比" class="headerlink" title="KWIC的不同设计方案对比"></a>KWIC的不同设计方案对比</h2><p>信息库</p><p><img src="/2022/06/17/SEreview/image-20220617152630013.png" alt="KWIC的共享数据解决方案"></p><p>数据抽象</p><p><img src="/2022/06/17/SEreview/image-20220617152706591.png" alt="KWIC的数据模块解决方案"></p><p>隐含调用</p><p><img src="/2022/06/17/SEreview/image-20220617152828776.png" alt="KWIC的隐含调用解决方案"></p><p>管道和过滤器</p><p><img src="/2022/06/17/SEreview/image-20220617152902068.png" alt="KWIC的管道和过滤器解决方案"></p><h2 id="成本效益分析"><a href="#成本效益分析" class="headerlink" title="成本效益分析"></a>成本效益分析</h2><p>计算效益</p><p>计算投资回报 ROI=效益/成本</p><p>计算投资回收期</p><h2 id="体系结构设计评审"><a href="#体系结构设计评审" class="headerlink" title="体系结构设计评审"></a>体系结构设计评审</h2><p>确认：设计是否符合客户指定的需求</p><p>验证：设计是否遵循了良好的设计原则，且该设计文档是否适合用户的需要</p><p>主动设计评审：评审人员通过在SAD中寻找信息来回答相关问题</p><p>被动评审过程：评审人员在阅读文档时发现问题</p><h1 id="第六章-设计模块"><a href="#第六章-设计模块" class="headerlink" title="第六章 设计模块"></a>第六章 设计模块</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>高内聚低耦合</p><h4 id="耦合度"><a href="#耦合度" class="headerlink" title="耦合度"></a>耦合度</h4><ol><li><p>内容耦合：A模块实际上修改了B模块，B模块完全依赖于A模块</p></li><li><p>公共耦合：不同模块可以从公共数据存储区来访问和修改数据</p></li><li><p>控制耦合：一个模块通过传递参数或返回代码来控制另一个模块的活动</p></li><li><p>标记耦合：使用一个复杂的数据结构进行模块间传递消息，并且传递的是该数据结构本身</p></li><li><p>数据耦合：模块间传递的是数据值，是最受欢迎的耦合</p></li><li><p>非耦合：模块相互之间没有信息传递，但是不太现实</p></li></ol><h4 id="内聚度"><a href="#内聚度" class="headerlink" title="内聚度"></a>内聚度</h4><ol><li>巧合内聚：模块各部分不相关，只为方便或偶然性原因放入同一模块</li><li><p>逻辑内聚：模块中各部分只通过代码的逻辑结构相关联</p></li><li><p>时态内聚：数据和功能仅仅因在一个任务中同时被使用而形成联系</p></li><li><p>过程内聚：功能组合在一起只是为了确保确定的顺序</p></li><li><p>通信内聚：各部分访问和操作同一数据集</p></li><li>功能内聚：模块中包含所有必需元素，且每个处理元素对功能都是必须的，每个模块执行且只执行设计的功能</li><li>信息内聚：在功能内聚的基础上，进行数据抽象化和基于对象的设计</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><h3 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h3><h3 id="增量式开发"><a href="#增量式开发" class="headerlink" title="增量式开发"></a>增量式开发</h3><p>使用图 </p><ul><li><p>创建有高扇入、低扇出的软件单元</p></li><li><p>使用夹层法消除循环</p></li></ul><h3 id="抽象-1"><a href="#抽象-1" class="headerlink" title="抽象"></a>抽象</h3><h3 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h3><h2 id="面向对象的设计-OO"><a href="#面向对象的设计-OO" class="headerlink" title="面向对象的设计 OO"></a>面向对象的设计 OO</h2><h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p><img src="/2022/06/17/SEreview/image-20220617163506348.png" alt="类继承（左）和对象组合（右）"></p><p>继承：通过扩展和重载现有类的行为来创建新的类</p><ul><li>子类对象从父类继承的方法在运行时不会再改变，具有更小的灵活性</li><li>理解和预测通过继承方式构造的类会更容易</li><li>通过选择性地覆载被继承的定义，可以改变和特化继承方法的行为</li></ul><p>组合：通过组合简单的类来形成一个新类</p><ul><li>保持被复用代码的封装性</li><li><p>允许动态替换对象构件</p></li><li><p>对象组合引入了一层间接性，会影响程序运行时性能</p></li></ul><h3 id="可替换性"><a href="#可替换性" class="headerlink" title="可替换性"></a>可替换性</h3><p>子类必须保持其父类的行为，这样客户端代码才能把他的实例也当成其父类的实例来同等对待</p><p>利斯科夫替换原则的主要用途是确定在什么时候一个对象可以安全地被另一个对象所替换</p><h3 id="德米特法则"><a href="#德米特法则" class="headerlink" title="德米特法则"></a>德米特法则</h3><p>“不要和陌生人说话”通过把组合类中作用在类构件上的每个方法都包含进来降低它们的依赖程度，使组合类的客户代码仅仅需要知道组合本身，而不需要知道组合的构件</p><p><img src="/2022/06/17/SEreview/image-20220617165501086.png" alt="对比设计和依赖关系"></p><h3 id="依赖倒置"><a href="#依赖倒置" class="headerlink" title="依赖倒置"></a>依赖倒置</h3><p>消除类形成的依赖循环</p><p>① 创建用户可以依赖的接口</p><p>② 将客户类和接口打包成新的客户模块</p><p>③ 为服务器类创建包装类，实现第一步中创建的接口</p><p><img src="/2022/06/17/SEreview/image-20220617165807071.png" alt="依赖倒置的3个步骤"></p><h3 id="过程中的UML"><a href="#过程中的UML" class="headerlink" title="过程中的UML"></a>过程中的UML</h3><p>需求：用例图、活动图、领域模型</p><p>体系结构：构件图、部署图</p><p>设计：类图、对象图；顺序图、通信图；活动图、状态图；包图</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p>类作用域的：<u>操作方法名</u></p><p>公共的：<code>+</code></p><p>私有的：<code>-</code></p><p>受保护的：<code>#</code></p><p><img src="/2022/06/17/SEreview/image-20220617170824823.png" alt="类的关系模型"></p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>当多个子类对同样的方法有着相似但不是完全相同的实现时，将重复的代码结构放在抽象类中，让子类继承它</p><p>优点：</p><ul><li>封装不变部分，扩展可变部分</li><li>提取公共代码便于维护</li><li>行为由父类控制，子类实现</li></ul><p>缺点：</p><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大</li></ul><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>当在不同条件下创建不同实例时，创建一个抽象类来定义一个抽象的构造函数（工厂方法），然后子类覆载工厂方法来构造特定的对象</p><p>优点：</p><ul><li>调用者创建一个对象只需知道名称</li><li>扩展性高</li><li>屏蔽产品的具体实现，调用者只关心产品接口</li></ul><p>缺点：</p><ul><li>每次增加一个产品都需要增加一个具体类和对象实现工厂，增加了系统的复杂度，同时也增加了系统具体类的依赖</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>当有多种算法可用，但直到运行时才知道最好的时，将每个算法都封装为单独的对象，任意替换</p><p>优点：</p><ul><li>算法可以自由切换</li><li>避免使用多重条件判断</li><li>扩展性高</li></ul><p>缺点：</p><ul><li>策略类会增多</li><li>所有策略类都需要对外暴露</li></ul><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p>当要动态扩展对象的功能时，装饰基类充当抽象角色，装饰类扩展基类引用并继承它所装饰的对象</p><p>优点：</p><ul><li>装饰类和被装饰类可以独立发展，不会相互耦合</li><li>装饰模式是继承的一个替代模式</li><li>装饰模式可以动态扩展一个实现类的功能</li></ul><p>缺点：</p><ul><li>多层装饰比较复杂</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>是发布-订阅风格的应用。一个对象的状态发生改变，进行广播，所有的依赖对象都将得到通知</p><p>优点：</p><ul><li>观察者和被观察者是抽象耦合的</li><li>建立了一套触发机制</li></ul><p>缺点：</p><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，广播会花费很多时间</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃</li><li>没有相应的机制让观察者知道目标对象是怎么发生变化的，而仅知道观察目标发生了变化</li></ul><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>表示树形结构时，树枝和叶子间实现统一接口，树枝内部组合该接口</p><p>优点：</p><ul><li>客户端模块只和新接口交互，调用简单</li><li>组合对象的类结构改变不会对客户端产生影响</li><li>降低了客户端模块与组合对象之间的耦合度</li></ul><p>缺点：</p><ul><li>违背利斯科夫替换原则，子类会继承没有意义的操作</li><li>只强调组合结点的统一性，而忽略了安全性</li><li>增加一个新的操作就需要向组合对象的每个类增加一个新方法</li></ul><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>将数据结构与数据操作分离，使用访问者模式将每个操作实现为抽象类Visitor的一个单独子类，并且子类都拥有将这些操作应用于每个构件类型的方法accept()</p><p>优点：</p><ul><li>操作更加内聚</li><li>不触及组合对象代码的情况下增加新操作</li></ul><p>缺点：</p><ul><li>违反迪米特原则，具体元素对访问者公布细节</li></ul><h2 id="模式与框架"><a href="#模式与框架" class="headerlink" title="模式与框架"></a>模式与框架</h2><p>模式是抽象体系结构元素的模板，可用来指导生成设计</p><p>框架是针对特定应用领域的大规模的可复用设计</p><h1 id="第七章-编写程序"><a href="#第七章-编写程序" class="headerlink" title="第七章 编写程序"></a>第七章 编写程序</h1><h2 id="编程标准"><a href="#编程标准" class="headerlink" title="编程标准"></a>编程标准</h2><p>最关键的是需要在程序设计构件和程序代码构件之间建立直接的对应关系，设计低耦合、高内聚、定义明确的接口</p><h3 id="对自身的作用"><a href="#对自身的作用" class="headerlink" title="对自身的作用"></a>对自身的作用</h3><ul><li>帮助自己组织想法避免错误</li><li>一些过程包括编写代码文档的方法，使得它更清晰且易于遵循</li><li>有助于将设计转化成代码，维护设计构件和代码构件的一致性</li></ul><h3 id="对他人的作用"><a href="#对他人的作用" class="headerlink" title="对他人的作用"></a>对他人的作用</h3><ul><li>易于维护</li><li>易于测试</li><li>易于重用</li></ul><h2 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h2><h3 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h3><p>代码重组 模块化 通用性 注释体现构件耦合 内聚度</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>选择算法时要在执行时间、设计质量、标准和客户需求之间平衡考虑</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>保持程序简单 用数据结构来决定程序结构</p><h3 id="通用策略"><a href="#通用策略" class="headerlink" title="通用策略"></a>通用策略</h3><p>局部化输入和输出</p><p>包含伪代码</p><p>改正和重写，而不是打补丁</p><p>复用</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="内部文档"><a href="#内部文档" class="headerlink" title="内部文档"></a>内部文档</h3><p>头注释块HCB </p><p>其他程序注释</p><p>有意义的变量名和语句标记</p><p>安排格式以增强理解</p><p>文档化数据</p><h3 id="外部文档"><a href="#外部文档" class="headerlink" title="外部文档"></a>外部文档</h3><p>描述问题、算法、数据</p><h2 id="编程过程"><a href="#编程过程" class="headerlink" title="编程过程"></a>编程过程</h2><p>理解问题 - 制定计划 - 执行计划 - 回顾</p><h3 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h3><p>一种轻量级的软件开发方法，属于敏捷开发方法。它将复杂的开发过程分解为一个个相对比较简单的小周期，通过交流、反馈等方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。</p><h3 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h3><p>结对编程属于主要的敏捷开发方法，开发方式是两个程序员共同开发程序，一个负责编写程序，另一个负责复审和测试，两个人定期交换角色</p><p>优点：提高生产率和质量（但证据不充分）</p><p>缺点：会抑制问题求解的基本步骤，扰乱对问题的关注</p><h1 id="第八章-测试程序"><a href="#第八章-测试程序" class="headerlink" title="第八章 测试程序"></a>第八章 测试程序</h1><h2 id="故障类型"><a href="#故障类型" class="headerlink" title="故障类型"></a>故障类型</h2><p><strong>算法故障</strong>：由于处理步骤中的某些错误，构件对于给定的输入没有产生正确的输出</p><p><strong>语法故障</strong>：编程语言语法出错</p><p><strong>计算故障 精度故障</strong>：个公式的实现是错误的，或者计算结果没有达到要求的精度</p><p><strong>文档故障</strong>：文档与程序不一致</p><p><strong>压力故障 过载故障</strong>：对数据结构的使用超出了承载能力</p><p><strong>能力故障 边界故障</strong>：系统活动到达指定的极限时，性能会变得不可接受</p><p><strong>计时故障 协调故障</strong>：几个同时执行或按仔细定义顺序执行的进程之间协调不当</p><p><strong>吞吐量故障 性能故障</strong>：系统不能以需求规定的速度执行</p><p><strong>恢复故障</strong>：当系统失效后不能表现得像设计人员希望的或客户要求的那样</p><p><strong>硬件和系统软件故障</strong>：提供的硬件或者系统软件实际上并没有按照文档中的操作条件或步骤运作</p><p><strong>标准和过程故障</strong>：代码没有遵循组织机构的标准和过程</p><h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><p><img src="/2022/06/17/SEreview/image-20220617201020078.png" alt="测试步骤"></p><ol><li><p>模块测试、构件测试、单元测试</p><p>将每个程序构件与系统中的其他构件隔离，对其本身进行测试</p></li><li><p>集成测试</p><p>验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作</p></li><li><p>功能测试</p><p>对系统进行评估，以确定集成的系统确实执行了需求规格说明中描述的功能。其结果是一个可运转的系统</p></li><li><p>性能测试</p><p>测试系统的软硬件性能是否符合需求规格说明文档。其结果是一个确认的系统</p></li><li><p>验收测试</p><p>确定系统是按照用户的期望运转的</p></li><li><p>安装测试</p><p>确保系统在实际环境中按照应有的方式运转</p></li></ol><h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><p>将测试的对象看作是一个密闭的黑盒，向闭盒提供输入的数据，并记录产生的输出。测试目标是确保针对每种输入，观察到的输出与预期的输出相匹配。黑盒测试参考的文档是系统设计和程序设计阶段的文档。</p><p>优点：免于受强加给测试对象内部结构和逻辑的约束，更偏向于功能性的测试。</p><p>缺点：</p><ul><li><p>以SRS 为依据，有一定的盲目性和不确定性，不可能揭示所有的错误。</p></li><li><p>没办法总是使用这种方式进行完备的测试。</p></li><li><p>不容易找到具有代表性的测试用例证明所有情况</p></li></ul><h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><p>将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。</p><p>优点：可以测试一个模块的细节</p><p>缺点：</p><ul><li><p>以模块内部逻辑为依据，当内部逻辑过于复杂时，不能给出合适的测试用例</p></li><li><p>对于大量递归、循环和分支的构件，测试完所有的分支是不现实的</p></li></ul><blockquote><p>实际测试方法依赖诸多因素</p><ul><li>可能的逻辑路径数目</li><li>输入数据的性质</li><li>涉及计算量</li><li>算法复杂性</li></ul></blockquote><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="代码评审"><a href="#代码评审" class="headerlink" title="代码评审"></a>代码评审</h3><p>代码<strong>走查</strong>相对不正式</p><p>代码<strong>审查</strong>相对正式，事先准备关注问题清单，依据清单比对代码和文档的一致性</p><p>好处：一个故障在开发过程中发现的越早，它就越容易纠正，所造成的损失也就越小</p><h3 id="测试程序构件"><a href="#测试程序构件" class="headerlink" title="测试程序构件"></a>测试程序构件</h3><p><strong>测试点</strong>或<strong>测试用例</strong>：用于测试程序的输入数据的一个特定选择。测试是测试用例的有限集合</p><p>测试的<strong>完全性</strong>：证明测试数据展现了所有可能的行为</p><ul><li>语句测试：构件中的每条语句至少执行一次</li><li>分支测试：对代码中的每个判断点，每个分支至少选择一次</li><li>路径测试：通过代码的每一条不同路径至少执行一次</li></ul><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><p>每一个处于系统层次中最底层的构件先被单独测试，接着测试调用了前面已测试构件的构件</p><p>优点：适合面向对象的程序；编写<strong>构件驱动程序</strong>很简单</p><p>缺点：顶层构件通常是最重要的，但是却是最后测试的</p><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>顶层构件先独立进行测试，然后将将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试</p><p>优点：功能性的设计故障或主要问题可以在测试的早期进行处理</p><p>缺点：<strong>桩</strong>不容易编写，桩的正确性影响测试的有效性；可能需要大量的桩</p><h3 id="一次性集成"><a href="#一次性集成" class="headerlink" title="一次性集成"></a>一次性集成</h3><p>先测试每一个构件，然后将所有的构件一次性的集成。只适用于小型系统</p><p>缺点：同时需要桩和驱动程序；很难发现失效原因；很难将接口故障和其他故障区分开</p><h3 id="三明治集成"><a href="#三明治集成" class="headerlink" title="三明治集成"></a>三明治集成</h3><p>将系统分成三层，目标层处于中间，在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成。测试集中于目标层</p><p>改进的：允许在较上层的构件和其他构件合并之前先对它们进行测试，保证每个模块得到单独测试</p><h2 id="面向对象测试和传统测试之间的区别"><a href="#面向对象测试和传统测试之间的区别" class="headerlink" title="面向对象测试和传统测试之间的区别"></a>面向对象测试和传统测试之间的区别</h2><p>测试用例的充分性</p><p>面向对象趋向于小粒度，其单元测试较为容易，但是集成测试涉及面变得更加广泛</p><p>需求分析和验证、测试用例生成、源码分析和覆盖分析</p><h2 id="故障播种"><a href="#故障播种" class="headerlink" title="故障播种"></a>故障播种</h2><p>测试小组1 检测到故障 $x$ 个</p><p>测试小组2 检测到故障 $y$ 个</p><p>两个小组都检测到的故障有 $q$ 个</p><script type="math/tex; mode=display">E_1=x/n=q/y \\E_2=y/n=q/x</script><p>程序中的故障总数的估算值 $n=\frac{q}{E_1E_2}$</p><h2 id="可信度"><a href="#可信度" class="headerlink" title="可信度"></a>可信度</h2><p>假定要在一个程序中播种 $S$ 个故障，并且断言该程序中实际只有 $N$ 个故障，$n$ 表示测试过程中发现的实际的故障数，可信度为</p><script type="math/tex; mode=display">C=\cases{1,n>N\\\frac{S}{S-N+1},n\le N}</script><p>Richards对其进行修改，可以用检测到的播种故障数 $s$ 估算可信度级别，而不管是否已经找出了所有故障</p><script type="math/tex; mode=display">C=\cases{1, n>N\\\frac{C_S^{s-1}}{C_{S+N+1}^{N+s}}}, n\le N</script><blockquote><p>当 $N=0$ 时，$C=\frac{s}{S+1}$</p></blockquote><h1 id="第九章-测试系统"><a href="#第九章-测试系统" class="headerlink" title="第九章 测试系统"></a>第九章 测试系统</h1><h2 id="软件故障根源"><a href="#软件故障根源" class="headerlink" title="软件故障根源"></a>软件故障根源</h2><p>需求分析：不正确、遗漏或者不清晰的需求</p><p>系统设计：对需求设计的误读，不正确或不清晰的设计规格说明</p><p>程序设计：对系统设计的误读，不正确或不清晰的设计规格说明</p><p>程序实现：对程序设计的误读，不正确的文档，不正确的语法语义</p><p>单元/集成测试：不完全的测试过程，改正已有故障时引入新故障</p><p>系统测试：不完全的测试过程，改正已有故障时引入新故障</p><p>维护：需求变化，错误的用户文档，负面的人为因素，改正已有故障时引入新故障</p><h2 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h2><p><img src="/2022/06/17/SEreview/image-20220617211330607.png" alt="测试过程的步骤"></p><p>① 功能测试：根据SRS测试系统功能</p><p>② 性能测试：将集成的构件与非功能系统需求进行比较 得到经验证的、确认的系统</p><p>③ 验收测试：客户根据需求测试 得到验收过的系统</p><p>④ 安装测试：在用户环境下进行测试 得到使用中的系统</p><p><strong>集成计划</strong>定义要测试的子系统，并描述如何、何处、何时和由谁进行测试</p><p>一个子系统为一次<strong>旋转spin</strong></p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>版本：针对特定系统的特定配置</p><p>发布：针对旧版本的改进版本</p><p><strong>回归测试</strong>用于识别在改正当前故障的同时可能引入的新故障</p><ul><li>插入新代码</li><li>测试被新代码影响的功能</li><li>测试版本m的基本功能，验证正常工作</li><li>继续版本m+1的功能测试</li></ul><p>控制版本和发布的3种方式：</p><ul><li><p><strong>delta</strong> 差别文件描述如何将主版本转换到不同版本的编辑命令</p><p>优点：对公共功能的改变只需改变主版本；占存储空间小</p><p>缺点：若主版本丢失或损坏则所有版本丢失；将每一个变种表示为从主版本的转换是很困难的</p></li><li><p>为每一个不同的版本或发布保留<strong>单独文件</strong></p></li><li><p><strong>条件编译</strong> 单个代码构件代表所有的版本，让编译器决定哪些语句适用于哪些版本</p></li></ul><h2 id="测试小组"><a href="#测试小组" class="headerlink" title="测试小组"></a>测试小组</h2><p>专业测试人员：集中于测试开发、方法和过程</p><p>分析员：以需求创建者的立场参与测试</p><p>系统设计人员：了解系统运作，可以使测试工作更有目的性</p><p>配置管理代表：出现失效或变化请求时安排变动，使变动反映在文档、需求、设计、代<br>码或者其他开发制品中</p><p>用户：对所发布的软件进行评估</p><h2 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h2><p>对需求的语义进行检查，输入称为原因，输出和转换称为结果，反应这些关系的布尔逻辑图</p><p>验证参数还会产生中间节点</p><p><img src="/2022/06/17/SEreview/image-20220617213850588.png" alt="因果图的表示法"></p><p><img src="/2022/06/17/SEreview/image-20220617213912239.png" alt="额外的表示法"></p><p>判定表产生测试用例</p><p>原因被调用或真(I) 原因被禁止或假(S) 不关心(X)</p><p>特定的结果出现(P) 未出现(A)</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>性能测试所针对的是非功能需求。它需要确保这个系统的可靠性、可用性与可维护性。</p><p>压力测试(短时间内加载极限负荷，验证系统能力)</p><p>容量测试(验证系统处理巨量数据的能力)</p><p>配置测试(测试各种软硬件配置)</p><p>兼容性测试(如果它与其他系统交互时)</p><p>回归测试(如果这个系统要替代一个现有系统时)</p><p>安全性测试(确保安全性需求得到满足)</p><p>计时测试(评估涉及对用户的响应时间和一个功能的执行时间的需求)</p><p>环境测试(考察系统在安装场所的执行能力)</p><p>质量测试(评估系统的可靠性、可维护性、可用性)</p><p>恢复测试(强调系统对出现故障或丢失数据、电源、设备或服务时的反应)</p><p>维护测试(核实诊断辅助工具是否存在能否正常运行)</p><p>文档测试(确保已经编写了必需文档)</p><p>人为因素测试/可使用性测试(检查涉及系统用户界面的需求)</p><h2 id="可靠性、可用性和可维护性"><a href="#可靠性、可用性和可维护性" class="headerlink" title="可靠性、可用性和可维护性"></a>可靠性、可用性和可维护性</h2><p>平均无故障时间MTTF 平均修复时间MTTR</p><p>平均是小间隔时间MTBF=MTTF+MTTR</p><p><strong>可靠性</strong>：一个系统对于给定时间间隔内、在给定条件下无失效运作的概率(0~1)</p><p>R=MTTF/(1+MTTF)</p><p><strong>可用性</strong>：在给定的时间点上，一个系统能够按照规格说明正确运作的概率(0/1)</p><p>A=MTBF/(1+MTBF)</p><p><strong>可维护性</strong>：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率(0~1)</p><p>M=1/(1+MTTR)</p><h2 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h2><p>基准测试：由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估</p><p>试验性测试：假设系统已经永久安装，执行系统，依赖系统的日常工作进行测试，相对基<br>准测试不是非常的正式与结构化</p><ul><li>$\alpha$​测试：在向客户发布一个系统之前，先让来自自己组织机构或公司的用户来测试这个系统</li><li>$\beta$测试：客户的试验</li></ul><p>并行测试：新系统与先前版本并行运转，使用户进行比较和对照</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>SoftwareEngineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU编译原理复习笔记</title>
    <link href="/2022/06/12/CompilerReview/"/>
    <url>/2022/06/12/CompilerReview/</url>
    
    <content type="html"><![CDATA[<h1 id="简答与计算"><a href="#简答与计算" class="headerlink" title="简答与计算"></a>简答与计算</h1><h2 id="画图表示编译过程的各阶段（必考）"><a href="#画图表示编译过程的各阶段（必考）" class="headerlink" title="画图表示编译过程的各阶段（必考）"></a>画图表示编译过程的各阶段（必考）</h2><p><img src="https://img2.baidu.com/it/u=1304873391,2773252053&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=580&amp;h=498" alt></p><h2 id="编译的前端和后端，一遍扫描"><a href="#编译的前端和后端，一遍扫描" class="headerlink" title="编译的前端和后端，一遍扫描"></a>编译的前端和后端，一遍扫描</h2><p>编译前端：与源语言有关但与目标机无关的部分，如词法分析、语法分析、语义分析与中间代码生成、与机器无关的优化</p><p>编译后端：与目标机有关的部分，如与目标机有关的优化、目标代码生成</p><p>一遍扫描：在语法分析的同时计算属性值，而不是语法分析构造语法树之后进行属性的计算，而且无需构造实际的语法树</p><h2 id="判断文法二义性"><a href="#判断文法二义性" class="headerlink" title="判断文法二义性"></a>判断文法二义性</h2><p>如果一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的</p><p>例$S\to iSeS|iS|i $，句子$iiiei$，画出两棵不同的语法树</p><h2 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h2><p>一个上下文无关文法$G$是一个四元式$(V_T,V_N,S,P)$，其中</p><ul><li><p>$V_T$：终结符集合</p></li><li><p>$V_N$：非终结符集合</p></li><li><p>$S$：文法的开始符号，属于非终结符</p></li><li><p>$P$：产生式集合，$S$必须在某个产生式的左部出现一次</p></li></ul><h2 id="短语-句柄-素短语"><a href="#短语-句柄-素短语" class="headerlink" title="短语 句柄 素短语"></a>短语 句柄 素短语</h2><p><a href="https://blog.csdn.net/qq_43543789/article/details/105850628">详解</a></p><p>短语：$S\Rightarrow^* \alpha A\delta$且$A\Rightarrow^+\beta$，则$\beta$是句型$\alpha\beta\delta$相对于非终结符$A$的短语</p><p>直接短语：$S\Rightarrow^* \alpha A\delta$且$A\Rightarrow\beta$</p><p>句柄：一个句型的最左直接短语</p><p>素短语：至少含有一个终结符的短语，且除它自身之外不再含有任何更小的素短语</p><blockquote><p>画出语法树</p><p>短语：以某非终结符为根的子树叶节点组成的字符串</p><p>直接短语：只有两代的子树叶节点组成的字符串</p><p>句柄：最左的二层子树叶节点组成的字符串</p><p>素短语：从短语集合中找出所有含终结符的短语，然后选出除它自身外不再含素短语的</p></blockquote><h2 id="描述算符优先算法"><a href="#描述算符优先算法" class="headerlink" title="描述算符优先算法"></a>描述算符优先算法</h2><p>用于分析任一产生式右部都不含两个连续的非终结符且任何终结符对仅满足$=,&lt;,&gt;$一种关系的算符优先文法</p><p>从算符优先文法构造优先关系表。使用一个符号栈，存放终结符和非终结符。从左到右扫描输入串，比较输入串符号与栈中终结符的优先关系，找到最左素短语则进行归约，直到扫描结束符号栈呈现<code>#N#</code>说明分析正确</p><h2 id="描述LR语法分析算法"><a href="#描述LR语法分析算法" class="headerlink" title="描述LR语法分析算法"></a>描述LR语法分析算法</h2><p>L表示从左到右扫描输入串，R表示构造一个最右推导的逆过程</p><p>根据文法产生式构造LR分析表，包括Action表和Goto表。使用一个分析栈，存放状态序列和已归约串。从左到右扫描输入串，根据分析栈的栈顶状态和输入串符号，参考LR分析表，进行输入串字符的移入或归约，通过不断改变分析栈内容，最终将句子归约至开始符号，LR分析结束。</p><h2 id="解释综合属性"><a href="#解释综合属性" class="headerlink" title="解释综合属性"></a>解释综合属性</h2><p>在语法树中，一个结点的综合属性的值由其子结点的属性值确定</p><h2 id="解释继承属性"><a href="#解释继承属性" class="headerlink" title="解释继承属性"></a>解释继承属性</h2><p>在语法树中，一个结点的继承属性由此结点的父节点和/或兄弟结点的某些属性确定</p><h2 id="解释S-属性文法"><a href="#解释S-属性文法" class="headerlink" title="解释S-属性文法"></a>解释S-属性文法</h2><p>S-属性文法是只含有综合属性的文法</p><h2 id="解释L-属性文法"><a href="#解释L-属性文法" class="headerlink" title="解释L-属性文法"></a>解释L-属性文法</h2><p>L-属性文法中的每个产生式，其语义规则中的属性要么是综合属性，要么是仅依赖于左边兄弟结点、父结点的继承属性</p><h2 id="解释语法制导翻译"><a href="#解释语法制导翻译" class="headerlink" title="解释语法制导翻译"></a>解释语法制导翻译</h2><p>对单词符号串进行语法分析，构造语法分析树，然后根据需要遍历语法树并在语法树的各结点处按语义规则进行计算</p><h2 id="语法制导翻译中-M-to-varepsilon-的作用"><a href="#语法制导翻译中-M-to-varepsilon-的作用" class="headerlink" title="语法制导翻译中$M\to \varepsilon$的作用"></a>语法制导翻译中$M\to \varepsilon$的作用</h2><p>使所有嵌入的动作都出现在产生式的末尾，这样就可以自下而上处理继承属性</p><h2 id="结合例子谈回填思想"><a href="#结合例子谈回填思想" class="headerlink" title="结合例子谈回填思想"></a>结合例子谈回填思想</h2><p>生成一个跳转指令时暂时不确定它的目标标号，则建立一个链表暂存这些指令，同一个链表中所有的跳转指令具有相同的目标标号，待能确定正确的目标标号后再去填写链表中的指令</p><h2 id="符号表作用"><a href="#符号表作用" class="headerlink" title="符号表作用"></a>符号表作用</h2><ul><li><p>收集符号属性</p></li><li><p>上下文语义的合法性检查的依据</p></li><li><p>目标代码生成阶段地址分配的依据</p></li></ul><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ul><li><p>传地址：将实参的地址传递给相应的形参</p></li><li><p>得结果：每个形参有两个单元，第一个存实参地址，第二个存实参的值。对形参的访问看作对第二个单元的访问，最终结果应当传递回去</p></li><li><p>传值：将实参的值传递给相应的形参</p></li><li><p>传名：将被调用段的过程抄到调用出现的位置，形参都替换成相应的实参</p></li></ul><h2 id="Display表及作用"><a href="#Display表及作用" class="headerlink" title="Display表及作用"></a>Display表及作用</h2><p>是一个指针数组，称为嵌套层次显示表，自顶向下依次存放现行层、直接外层直至最外层的每层过程的最新活动记录的基地址</p><p>提高访问非局部量的速度</p><h2 id="C语言活动记录结构"><a href="#C语言活动记录结构" class="headerlink" title="C语言活动记录结构"></a>C语言活动记录结构</h2><p><img src="/2022/06/12/CompilerReview/e9002cf9747eab9fb03d97806977d47e8db0f5e4.png" alt></p><p>四个项目</p><ul><li><p>连接数据，有两个</p><ul><li><p>老SP值，即前一活动记录的地址</p></li><li><p>返回地址</p></li></ul></li><li><p>参数个数</p></li><li><p>形式单元：存放实在参数的值或地址</p></li><li><p>局部数据区：过程的局部变量、数组内情向量和临时工作单元</p></li></ul><h2 id="允许过程嵌套的活动记录结构"><a href="#允许过程嵌套的活动记录结构" class="headerlink" title="允许过程嵌套的活动记录结构"></a>允许过程嵌套的活动记录结构</h2><h3 id="法一：静态链"><a href="#法一：静态链" class="headerlink" title="法一：静态链"></a>法一：静态链</h3><p><img src="/2022/06/12/CompilerReview/01df8542cd8217f8ee616f06634f5738c678cc5f.png" alt></p><p>引入一个称为静态链的指针，指向直接外层的最新活动记录的基地址</p><h3 id="法二：Display表"><a href="#法二：Display表" class="headerlink" title="法二：Display表"></a>法二：Display表</h3><p><img src="/2022/06/12/CompilerReview/13e7b6b105358128f3ef4090e11980e01940fe23.png" alt></p><p>连接数据新增全局display地址，为调用过程的display表地址</p><h2 id="优化的基本概念"><a href="#优化的基本概念" class="headerlink" title="优化的基本概念"></a>优化的基本概念</h2><p>目的：产生更高效的代码</p><p>原则：</p><ul><li><p>等价原则：优化后不应改变程序运行结果</p></li><li><p>有效原则：优化后产生的目标代码运行时间较短，占用的存储空间较小</p></li><li><p>合算原则：应尽可能以较低的代价取得较好的优化效果</p></li></ul><p>手段：</p><ul><li><p>删除公共子表达式</p></li><li><p>复写传播</p></li><li><p>删除无用代码</p></li><li><p>代码外提</p></li><li><p>强度削弱</p></li><li><p>删除归纳变量</p></li></ul><h2 id="根据语言求上下文无关文法"><a href="#根据语言求上下文无关文法" class="headerlink" title="根据语言求上下文无关文法"></a>根据语言求上下文无关文法</h2><p>$L(G)=\{a^n b^n|n\ge 1\}$    $S\to aSb|ab$</p><p>$L(G)=\{a^n b^n|n\ge 0\}$    $S\to aSb|\varepsilon$</p><p>$L(G)=\{a^n b^m a^m b^n|m\ge 0, n\ge 0\}$    $S\to aSb|A,A\to bAa|\varepsilon$</p><h2 id="写正规式"><a href="#写正规式" class="headerlink" title="写正规式"></a>写正规式</h2><p>字母表包含$\{a,b\}$，偶数个$a$的正规式 $b^*(ab^*ab^*)^*$</p><p>以$01$结尾的二进制数串 $(0|1)^*01$</p><p>能被5整除的十进制整数 $(1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)^*(0|5)|(0|5)$</p><p>包含奇数个$1$或奇数个$0$的二进制数串 <a href="https://blog.csdn.net/qq_40727897/article/details/106558109">解析</a> $0^*1(0^*|10^*1)^*|1^*0(1^*|01^*0)^*$</p><p>所有大于101的二进制整数  $11(0|1)|1(0|1)^*(0|1)(0|1)(0|1)$</p><h2 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h2><ul><li><p>把所有非终结符按任一种顺序排列成$P_1,P_2,…,P_n$</p></li><li><p>按序处理</p><ul><li><p>使$P_i\rightarrow\alpha$ 中的 $\alpha$ 仅含有 $P_j,(j\ge i)$</p></li><li><p>消除$P_i$的直接左递归</p></li></ul></li><li><p>化简，取出从开始符号出发永远到达不了的非终结符的产生规则</p></li></ul><blockquote><p>消除直接左递归</p><script type="math/tex; mode=display">P\rightarrow P\alpha|\beta</script><p>改写为</p><script type="math/tex; mode=display">P\rightarrow\beta P'\\P'\rightarrow\alpha P'|\varepsilon</script></blockquote><h2 id="提左公因子消除回溯"><a href="#提左公因子消除回溯" class="headerlink" title="提左公因子消除回溯"></a>提左公因子消除回溯</h2><script type="math/tex; mode=display">A\rightarrow\delta\beta_1|\delta\beta_2|...|\delta\beta_n|\gamma_1|\gamma_2|...|\gamma_n\ (其中，每个\gamma不以\delta开头)</script><p>改写为</p><script type="math/tex; mode=display">A\rightarrow\delta A'|\gamma_1|\gamma_2|...|\gamma_m\\A'\rightarrow\beta_1|\beta_2|...|\beta_n</script><h2 id="中缀式改后缀式"><a href="#中缀式改后缀式" class="headerlink" title="中缀式改后缀式"></a>中缀式改后缀式</h2><p>法一</p><ul><li><p>遇操作数直接输出</p></li><li><p>栈为空时 运算符直接入栈</p></li><li><p>遇<code>(</code> 入栈</p></li><li><p>遇<code>)</code> 弹出栈中<code>(</code>以上元素 但不输出括号</p></li><li><p>遇运算符 弹出栈顶优先级高于或等于它的 再入栈</p></li><li><p>遇末尾 弹出所有元素</p></li></ul><p>法二</p><ul><li><p>先按照运算符的优先级对中缀表达式加括号</p></li><li><p>将运算符移到括号的后面</p></li><li><p>去掉括号</p></li></ul><blockquote><p>优先级（由高到低）</p><ul><li><p><code>()</code>圆括号 <code>[]</code>下标运算符 <code>-&gt;</code></p></li><li><p><code>!</code>逻辑非 <code>~</code>按位取反 <code>++</code>前缀增量 <code>--</code>前缀减量 <code>-</code>负号 <code>(type)</code>类型转换 <code>*</code>指针 <code>&amp;</code>地址 <code>sizeof</code>长度</p></li><li><p><code>*</code>乘法 <code>/</code>除法 <code>%</code>取余</p></li><li><p><code>+</code>加法 <code>-</code>减法</p></li><li><p><code>&lt;&lt;</code>左移 <code>&gt;&gt;</code>右移</p></li><li><p><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code> 关系运算符</p></li><li><p><code>==</code> <code>!=</code> 关系运算符</p></li><li><p><code>&amp;</code> 按位与</p></li><li><p><code>^</code> 按位异或</p></li><li><p><code>|</code> 按位异或</p></li><li><p><code>&amp;&amp;</code> 逻辑与</p></li><li><p><code>||</code> 逻辑或</p></li><li><p><code>?:</code> 条件</p></li><li><p><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code> <code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> 赋值运算符</p></li><li><p><code>,</code>逗号运算符</p></li></ul></blockquote><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>给出正规式</p><p><strong>① 构造NFA</strong></p><ul><li><p>使初态终态唯一 引入新的初态X和终态Y</p></li><li><p>分裂 使每条弧上或为$\varepsilon$或为单个字符</p><p><img src="/2022/06/12/CompilerReview/ac183e9cdc67ae5b36315e4e2fafed5aa93eeaa9.png" alt></p></li></ul><p><strong>② 确定化 子集法</strong></p><p><img src="/2022/06/12/CompilerReview/2ad055334c2f7b73c63f2cec74feb1c23001f397.png" alt></p><p><img src="/2022/06/12/CompilerReview/ada378e0a42a5e3d918fde33f84ae0965ab10dff.png" title alt width="268"></p><p><strong>③ 最小化</strong></p><p><img src="/2022/06/12/CompilerReview/fe98ef80f50ad4ea6f535b9d9d3427d16a1da31c.png" alt></p><h2 id="LL-1-分析"><a href="#LL-1-分析" class="headerlink" title="LL(1)分析"></a>LL(1)分析</h2><p>给出文法</p><p><strong>① 构造FIRST集合</strong></p><p><img src="/2022/06/12/CompilerReview/06169247eaa3a40a3d265787019097ba1c7172ae.png" alt></p><p><strong>② 构造FOLLOW集合</strong></p><p><img src="/2022/06/12/CompilerReview/b3b5cf033ac9e3f49644ea22820e85db080170e8.png" alt></p><p><strong>③ 判断是否为LL(1)文法</strong></p><p><img src="/2022/06/12/CompilerReview/901d953afd67934025b806d4ad036ce0d5b35288.png" alt></p><p><strong>④ 构造LL(1)分析表（可能涉及消除二义文法冲突）</strong></p><p><img src="/2022/06/12/CompilerReview/f4b6499a851457a84294413574501e50d19b7edd.png" alt></p><p><strong>⑤ 识别句子</strong></p><p><img src="/2022/06/12/CompilerReview/7edc31dc26a130d59601f960ff698d77cb10202a.png" alt></p><h2 id="LR分析"><a href="#LR分析" class="headerlink" title="LR分析"></a>LR分析</h2><p>给出文法</p><p><strong>① 构造拓广文法</strong></p><p>给文法添加一条产生式$S’\rightarrow S$，其中$S$是原文法的开始符号，使初始状态唯一</p><p><strong>② 构造拓广文法的LR(0)/LR(1)项目集规范族</strong></p><p><img src="/2022/06/12/CompilerReview/240a8d1157ce2c062f92a4d917a6df19b885a6d7.png" alt></p><p>LR(1)还要求FIRST集合</p><blockquote><p>$A\rightarrow\varepsilon$的LR项目表示为$A\to\cdot (,\#)$</p></blockquote><p><img src="/2022/06/12/CompilerReview/c2a722845c35a37ed64b781e7647f34a6b4cdf8d.png" alt></p><p><strong>③ 判断是否为LR(0)/LR(1)文法</strong></p><p><strong>LR(0)</strong></p><ul><li><p>一个项目集中是否既有移进项目又有归约项目</p></li><li><p>一个项目集中是否含有两个或两个以上的归约项目</p></li></ul><p><strong>LR(1)</strong></p><ul><li>一个项目集中是否有移进-归约或归约-归约冲突（确保生成的分析表中每个单元格内的值唯一）</li></ul><p><strong>④ 构造LR(0)/LR(1)分析表（可能涉及消除二义文法冲突）</strong></p><p><img src="/2022/06/12/CompilerReview/dc470cb04114c7bffc1389c13c3f3d0da2ea12a3.png" alt></p><p><img src="/2022/06/12/CompilerReview/3821191c8c5ff20331a43ad8bcba05d41e90c555.png" alt></p><p><strong>⑤ 识别句子</strong></p><p><img src="/2022/06/12/CompilerReview/a5fbe899c1ffc1b640a7564336708afd65efabb2.png" alt></p><h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><p>给出翻译模式和高级语言程序，翻译句子为三地址代码或四元式序列</p><p>一般涉及多种类型句子的综合，也可能涉及声明语句填写符号表</p><p><strong>说明语句</strong></p><p><img src="/2022/06/12/CompilerReview/065df6ad635f931a5c16d35250c9dec3b1cd9105.png" alt></p><p><strong>IF 语句</strong></p><p><code>if E then S1 else S2</code></p><ul><li><p>翻译E</p></li><li><p>回填E的真出口，E的假出口未知</p></li><li><p>翻译S1</p></li><li><p>遇到else，S1结束，生成一条无条件转移四元式，但出口未知</p></li><li><p>回填E的假出口</p></li><li><p>翻译S2</p></li><li><p>回填S1结束后的转移出口</p></li></ul><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">if</span> A&gt;B or C <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">if</span> D&lt;E <span class="hljs-keyword">then</span> F:=F+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> F:=F-<span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> F:=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>三地址代码</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">100    if A&gt;B goto (104)<br>101    goto (102)<br>102    if C goto (104)<br>103    goto (112)<br>104    if D&lt;E goto (106)<br>105    goto (109)<br>106    T1:=F+1<br>107    F:=T1<br>108    goto (113)<br>109    T2:=F-1<br>110    F:=T2<br>111    goto (113)<br>112    F:=0<br>113<br></code></pre></div></td></tr></table></figure><p>四元式形式</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">100    (j&gt;, A, B, 104)    <br>101    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 102)<br>102    (jnz, C, <span class="hljs-built_in">_</span>, 104)// 注意一下jnz<br>103    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 112)<br>104    (j&lt;, D, E, 106)<br>105    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 109)<br>106    (+, F, 1, T1)<br>107    (:=, T1, <span class="hljs-built_in">_</span>, F)<br>108    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 113)<br>109    (-, F, 1, T2)<br>110    (:=, T2, <span class="hljs-built_in">_</span>, F)<br>111    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 113)<br>112    (:=, 0, <span class="hljs-built_in">_</span>, F)<br>113<br></code></pre></div></td></tr></table></figure><p><strong>WHILE 语句</strong></p><p><code>while E do S1</code></p><ul><li><p>翻译E</p></li><li><p>回填E的真出口</p></li><li><p>翻译S1</p></li><li><p>无条件转移到E代码段的第一条四元式</p></li><li><p>回填E的假出口</p></li></ul><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">while</span> a&lt;b <span class="hljs-keyword">do</span><br>    a:=a+<span class="hljs-number">3</span><br>    b:=b-<span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure><p>三地址代码</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">100    if a&lt;b goto (102)<br>101    goto (107)<br>102    T1:=a+3<br>103    a:=T1<br>104    T2:=b-3<br>105    b:=T2<br>106    goto (100)<br>107<br></code></pre></div></td></tr></table></figure><p>四元式形式</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">100    (j&lt;, a, b, 102)<br>101    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 107)<br>102    (+, a, 3, T1)<br>103    (:=, T1, <span class="hljs-built_in">_</span>, a)<br>104    (-, b, 3, T2)<br>105    (:=, T2, <span class="hljs-built_in">_</span>, b)<br>106    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 100)<br>107<br></code></pre></div></td></tr></table></figure><p><strong>多类型句子的综合</strong></p><figure class="highlight fortran"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs fortran"><span class="hljs-keyword">while</span> A&lt;C and B&lt;D <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> A=<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> C:=C+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">while</span> A&lt;=D <span class="hljs-keyword">do</span> A:=A+<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>三地址代码</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">100    if A&lt;C goto (102)<br>101    goto (115)<br>102    if B&lt;D goto (104)<br>103    goto (115)<br>104    if A=1 goto (106)<br>105    goto (109)<br>106    T1:=C+1<br>107    C:=T1<br>108    goto (100)// 已更正 不是goto(114)<br>109    if A&lt;=D goto (111)<br>110    goto (100)// 通通是S1.next的值<br>111    T2:=A+2<br>112    A:=T2<br>113    goto (109)<br>114    goto (100)<br>115<br></code></pre></div></td></tr></table></figure><p>四元式形式</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">100    (j&lt;, A, C, 102)<br>101    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 115)<br>102    (j&lt;, B, D, 104)<br>103    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 115)<br>104    (j=, A, 1, 106)<br>105    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 109)<br>106    (+, C, 1, T1)<br>107    (:=, T1, <span class="hljs-built_in">_</span>, C)<br>108    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 100)<br>109    (j&lt;=, A, D, 111)<br>110    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 100)<br>111    (+, A, 2, T2)<br>112    (:=, T2, <span class="hljs-built_in">_</span>, A)<br>113    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 109)<br>114    (j, <span class="hljs-built_in">_</span>, <span class="hljs-built_in">_</span>, 100)<br>115<br></code></pre></div></td></tr></table></figure><p>补个语法树的全过程分析草图</p><blockquote><p>星星说涉及到的翻译模式都会给，时间充裕可以一步一步慢慢来</p></blockquote><p><img src="/2022/06/12/CompilerReview/image-20220615143931892.png" alt></p><h2 id="优化和目标代码生成"><a href="#优化和目标代码生成" class="headerlink" title="优化和目标代码生成"></a>优化和目标代码生成</h2><p>给出基本块代码</p><p><strong>① 构造DAG</strong></p><p><img src="/2022/06/12/CompilerReview/c02aacfc1e0b4f46c384d5878579b6f64dfc690a.png" alt></p><blockquote><p>结点的左右位置要与操作数对应</p></blockquote><p><img src="/2022/06/12/CompilerReview/4ad72908693a7949c8209ca36025a0d0b6e6006d.png" alt></p><p><strong>② 写出优化后的中间代码</strong></p><p>按照构造其结点的顺序生成中间代码，有常数的直接用常数</p><p>如果DAG某内部结点上附有多个标识符，由于计算该结点值的表达式是一个公共子表达式，当我们把该结点重新写成中间代码时，就可以删除多余运算</p><p><img src="/2022/06/12/CompilerReview/f8481e898fe11cced4a6d4c4ecf7b6b3b944a1d5.png" alt></p><p><strong>③ 写出DAG目标优化后的中间代码</strong></p><p><strong>DAG结点计算顺序</strong></p><p>N个内部节点，线性表T[N]记录顺序，从后往前填写</p><figure class="highlight tex"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tex">while(存在不在T中的结点)&#123;<br>        找不在T中但其所有父结点在T中，或者没有父结点的内部节点n，n填入T<br>        while(n的左孩子m不是叶结点且它的所有父结点在T中)&#123;<br>                m填入T<br>                n=m<br>        &#125;<br>&#125;<br>// 有点像拓扑排序<br></code></pre></div></td></tr></table></figure><p><img src="/2022/06/12/CompilerReview/c5c984191a055350b3399398953b25fddf08dc1f.png" alt></p><p>还可进一步删除中间代码序列中其他情况的无用赋值</p><ul><li><p>如果DAG中某结点上附加的标识符在该基本块后面不会被引用，那么就不生成对该标识符赋值的中间代码</p></li><li><p>如果某结点上不附有任何标识符或者其上附加的标识符在基本块后面不会被引用，而且它也没有前驱结点，这意味着基本块内和基本块后面都不会引用该结点的值，那么就不生成计算该结点值的代码</p></li><li><p>如果有两条相邻的代码<code>A := C op D</code>和<code>B := A</code>，其中第一条代码计算出来的A值只在第二条代码中被引用，那么把相应结点重写成中间代码时，原来的两条代码将变换成<code>B := C op D</code></p></li></ul><p><img src="/2022/06/12/CompilerReview/acfaebf4d3d95cb8beb73433ce6ce548196d4e7e.png" alt></p><p><strong>④ 根据变量活跃性和寄存器信息写出目标代码</strong></p><p><strong>计算待用信息和活跃信息算法</strong></p><p><img src="/2022/06/12/CompilerReview/3cd82233ff42c057e6242c8f070eabe73e96a5c4.png" alt></p><p><strong>寄存器分配算法</strong></p><p><img src="/2022/06/12/CompilerReview/91b605b3a18acc4318152afbe23d3eef2b48ae58.png" alt></p><p><strong>生成必要的存数指令</strong></p><p><img src="/2022/06/12/CompilerReview/cc68fda86c2586630d363bc42305465c966664d5.png" alt></p><p><strong>代码生成算法</strong></p><p><img src="/2022/06/12/CompilerReview/2b0e559d67b4b0247aae92d99a7610a9d43b17f0.png" alt></p><p>处理完<strong>每个产生式</strong>后检查，如果寄存器中的某变量在基本块出口之后是活跃的，则需要用<code>ST</code>指令将其存储到主存单元中</p><p><img src="/2022/06/12/CompilerReview/image-20220615111044280.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为云环境下Docker+Tomcat+Nginx实现负载均衡</title>
    <link href="/2022/05/10/nginx-load-balancing/"/>
    <url>/2022/05/10/nginx-load-balancing/</url>
    
    <content type="html"><![CDATA[<p>负载均衡：</p><ul><li><p>在多台服务器之间有效地分配客户端请求或网络负载</p></li><li><p>通过仅向正常服务器发送请求确保高可用性和可靠性</p></li><li><p>业务不中断地情况下，按需弹性分配服务器资源</p></li></ul><p>以减少宕机时间、提供系统可用性、动态扩展性能、加快访问速度。</p><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>要求部署一台Nginx和三台Tomcat服务器，且Ngnix需要实现三种策略：</p><ul><li>轮询</li><li>权重，三台Tomcat服务器的权重为1， 3， 5</li><li>IP Hash</li></ul><h3 id="购买云服务器和公网IP"><a href="#购买云服务器和公网IP" class="headerlink" title="购买云服务器和公网IP"></a>购买云服务器和公网IP</h3><p>买的是华为云的弹性云服务器，配置选基础的就可以，因为只是实验用途，所以计费模式选的按需计费</p><p>然后镜像的话选CentOS7就行，一开始选的Ubuntu发现教程很少，然后换成CentOS8发现后续过程会出现一些权限问题（qwq踩坑达人</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510092220245.png" alt="ECS"></p><p>还需要买一个弹性公网IP，不然在服务器上没法上网（好像</p><p>带宽也就选的默认的5Mb/s</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510092438751.png" alt="IP"></p><p>然后恭喜你就会拥有一台云服务器！</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510092809159.png" alt="Cloud Server"></p><p>设置安全组入规则，为了后续的端口正常访问</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220518075854144.png" alt></p><p>可以点击远程登录就可以对它操作啦</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510092910944.png" alt></p><p>这里有两种登录方式，推荐第一种CloudShell哦，那里面可以直接CV复制粘贴，还有资源管理器的可视化显示</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510093107230.png" alt="CloudShell"></p><p>输入之前设置的密码就可以登录成功啦</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yum -y install docker<br><span class="hljs-meta">#</span><span class="bash"> 启动docker守护进程</span><br>systemctl start docker.service<br><span class="hljs-meta">#</span><span class="bash"> 拉取最基础的image镜像</span><br>docker pull centos<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510093242537.png" alt></p><h3 id="拉取Tomcat-Nginx镜像"><a href="#拉取Tomcat-Nginx镜像" class="headerlink" title="拉取Tomcat Nginx镜像"></a>拉取Tomcat Nginx镜像</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker pull tomcat<br>docker pull nginx<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510093338112.png" alt="docker images"></p><h3 id="创建Tomcat-Nginx容器"><a href="#创建Tomcat-Nginx容器" class="headerlink" title="创建Tomcat Nginx容器"></a>创建Tomcat Nginx容器</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker run -itd --name myNginx -p 8081:80 nginx:latest /bin/bash<br>docker run -itd --name myTomcat1 -p 8086:8080 tomcat:latest /bin/bash<br>docker run -itd --name myTomcat2 -p 8087:8080 tomcat:latest /bin/bash<br>docker run -itd --name myTomcat3 -p 8088:8080 tomcat:latest /bin/bash<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510093530469.png" alt="docker ps"></p><h3 id="部署Nginx容器"><a href="#部署Nginx容器" class="headerlink" title="部署Nginx容器"></a>部署Nginx容器</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;nginx Container ID&gt; /bin/bash<br>/usr/sbin/nginx<br>exit<br></code></pre></div></td></tr></table></figure><p>打开浏览器，输入<code>你的公网IP地址:设置的端口号</code>查看是否部署成功</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510093812534.png" alt="Nginx"></p><h3 id="部署Tomcat容器"><a href="#部署Tomcat容器" class="headerlink" title="部署Tomcat容器"></a>部署Tomcat容器</h3><p>总共要部署三个，操作都是一样的哦</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;Tomcat Container ID&gt; /bin/bash<br>ls<br>mv webapps webapps1<br>mv webapps.dist webapps<br>cd bin<br>./startup.sh<br>exit<br></code></pre></div></td></tr></table></figure><p>打开浏览器，输入<code>你的公网IP地址:设置的端口号</code>查看是否部署成功</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510094007030.png" alt="Tomcat"></p><h3 id="修改Tomcat默认主页内容"><a href="#修改Tomcat默认主页内容" class="headerlink" title="修改Tomcat默认主页内容"></a>修改Tomcat默认主页内容</h3><p>现在三个Tomcat服务器上的主页内容都是一样的，如果通过Nginx代理访问的话无法区分它们，所以要修改它们的主页内容</p><p>分别进入三个Tomcat容器修改网页代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;Tomcat container ID&gt; /bin/bash<br>cd webapps/ROOT<br>vim index.jsp<br></code></pre></div></td></tr></table></figure><p>加一小段不同的字就行</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510094227832.png" alt="webapps/ROOT/index.jsp"></p><blockquote><p>输入<code>vim</code>命令后会出现命令不存在的情况，需要在服务器内安装vim</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">apt-get update<br>apt-get install vim<br></code></pre></div></td></tr></table></figure><p>网络原因可能会很慢，但是耐心等待就好</p></blockquote><p>最终的修改效果如下：</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510094538618.png" alt="Tomcat#1"></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510094552343.png" alt="Tomcat#2"></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510094603926.png" alt="Tomcat#3"></p><h3 id="Nginx负载均衡配置"><a href="#Nginx负载均衡配置" class="headerlink" title="Nginx负载均衡配置"></a>Nginx负载均衡配置</h3><p>首先进入Nginx容器，编辑配置文件，开启Nginx代理转发</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>cd /etc/nginx/conf.d<br>vim default.conf<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510094933520.png" alt="/etc/nginx/conf.d/default.conf"></p><h4 id="轮询法"><a href="#轮询法" class="headerlink" title="轮询法"></a>轮询法</h4><p>将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p><p>修改upstream模块</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>cd /etc/nginx<br>vim nginx.conf<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221259505.png" alt="nginx.conf"></p><p>重启Nginx服务器</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker restart &lt;Nginx container ID&gt;<br>docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>/usr/sbin/nginx<br></code></pre></div></td></tr></table></figure><p>浏览器访问Nginx服务器，并刷新进行多次访问</p><p>发现访问顺序为<code>Tomcat#1-#2-#3</code></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221555369.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221608386.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221614928.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221631025.png" alt></p><h4 id="权重法"><a href="#权重法" class="headerlink" title="权重法"></a>权重法</h4><p>权重（weight）默认值为1，权重越高，被分配的请求数量越多，将请求顺序且按照权重分配到后端再进行轮询。</p><p>修改upstream模块</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>cd /etc/nginx<br>vim nginx.conf<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221647717.png" alt="nginx.conf"></p><p>重启Nginx服务器</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker restart &lt;Nginx container ID&gt;<br>docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>/usr/sbin/nginx<br></code></pre></div></td></tr></table></figure><p>浏览器访问Nginx服务器，并刷新进行多次访问</p><p>9次访问中<code>Tomcat#1</code>1次，<code>Tomcat#2</code>3次，<code>Tomcat#3</code>5次，与设置的权重相符</p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221826380.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221833802.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221840710.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221847168.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221854042.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221900113.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221906531.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221913498.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221920069.png" alt></p><h4 id="IP-HASH法"><a href="#IP-HASH法" class="headerlink" title="IP_HASH法"></a>IP_HASH法</h4><p>根据获取请求客户端的IP地址，通过哈希函数计算得到一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客户端要访问服务器的序号。每个请求固定访问同一个后端服务器，这样可以做到会话保持，解决session同步问题。</p><p>修改upstream模块</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>cd /etc/nginx<br>vim nginx.conf<br></code></pre></div></td></tr></table></figure><p><img src="/2022/05/10/nginx-load-balancing/image-20220510221936993.png" alt="nginx.conf"></p><p>重启Nginx服务器</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">docker restart &lt;Nginx container ID&gt;<br>docker exec -it &lt;Nginx container ID&gt; /bin/bash<br>/usr/sbin/nginx<br></code></pre></div></td></tr></table></figure><p>浏览器访问Nginx服务器，并刷新进行多次访问</p><p>发现一直访问的是<code>Tomcat#1</code></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510222036840.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510222043581.png" alt></p><p><img src="/2022/05/10/nginx-load-balancing/image-20220510222048670.png" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>CloudComputing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>This is NACHOS#4</title>
    <link href="/2022/04/24/This-is-NACHOS-4/"/>
    <url>/2022/04/24/This-is-NACHOS-4/</url>
    
    <content type="html"><![CDATA[<p>通过考察系统加载应用程序过程，如何为其分配内存空间、创建页表并建立虚页与实页帧的映射关系</p><ul><li>理解Nachos的内存管理方法</li><li>理解系统对空闲帧的管理方法</li><li>理解如何加载另一个应用程序并为其分配地址空间，以支持多进程机制</li><li>理解进程的pid</li><li>理解进程退出所要完成的工作</li></ul><h2 id="Nachos多进程机制的实现"><a href="#Nachos多进程机制的实现" class="headerlink" title="Nachos多进程机制的实现"></a>Nachos多进程机制的实现</h2><h3 id="理解Nachos的内存管理方法"><a href="#理解Nachos的内存管理方法" class="headerlink" title="理解Nachos的内存管理方法"></a>理解Nachos的内存管理方法</h3><p>阅读protest.cc中函数<code>StartProcess(char* filename)</code>中为可执行程序分配内存空间的过程</p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220424160510637.png" alt="StartProcess()"></p><p>阅读为程序分配内存空间，创建页表的过程<code>AddrSpace::AddrSpace()</code></p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220424160530614.png" alt="AddrSpace()"></p><p>可知Nachos为每个进程从0号页框开始按序分配，且物理页框和虚拟页框保持一致。这样的内存分配方法只适用于单进程，因为如果有多道进程并行时，后创建的进程也从0开始分配内存，这将会覆盖掉先前的进程，导致系统问题。而且这样的内存分配方法使物理地址和逻辑地址的对应关系失去了意义。</p><h3 id="理解系统对空闲帧的管理方法"><a href="#理解系统对空闲帧的管理方法" class="headerlink" title="理解系统对空闲帧的管理方法"></a>理解系统对空闲帧的管理方法</h3><p>为了避免分配内存空间的过程中出现内存交换的问题，在为进程分配物理页框的时候我们只能为其分配空闲帧，所以需要对空闲帧进行管理，便于查找使用</p><p>参考在文件系统中对空闲磁盘块的管理方法，我们同样使用位图这一数据结构对物理内存进行管理，在类<code>AddrSpace</code>中实例化类<code>BitMap</code>的一个全局对象<code>freeBitMap</code></p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220406193915090.png" alt="Declare freeBitMap"></p><p>初始化该位图，<code>NumPhyPages</code>为宏定义的物理页框数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">BitMap* AddrSpace::freeBitMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BitMap</span>(NumPhysPages);<br></code></pre></div></td></tr></table></figure><p>当需要检索空闲帧时，调用<code>BitMap::Find()</code>方法，返回值为一个空闲帧号，同时将该空闲帧置1标记为已占用；若返回值为<code>-1</code>，则没有空闲帧</p><p>当需要释放<code>i</code>号帧时，调用<code>BitMap::Clear(i)</code>，将<code>i</code>号帧置0标记为空闲</p><h3 id="多进程机制下为应用程序分配地址空间"><a href="#多进程机制下为应用程序分配地址空间" class="headerlink" title="多进程机制下为应用程序分配地址空间"></a>多进程机制下为应用程序分配地址空间</h3><p>修改<code>AddrSpace::AddrSpace()</code>，在分配物理页框的时候，查找空闲帧进行分配</p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220424160629019.png" alt="AddrSpace()"></p><p>同时，在<code>AddrSpace::~AddrSpace()</code>的析构过程中，需要将该进程的内存空间释放</p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220424160654825.png" alt="~AddrSpace()"></p><h3 id="多进程机制下将可执行文件写入内存"><a href="#多进程机制下将可执行文件写入内存" class="headerlink" title="多进程机制下将可执行文件写入内存"></a>多进程机制下将可执行文件写入内存</h3><p>Nachos在写入内存之前将整个内存空间都置0，是为了将未初始化的数据段和栈段置0，然后再将代码段和已初始化的数据段写入内存</p><p>在单进程机制下这样做是没有问题的，但在多进程机制中这样做则会清空整个内存，导致其他正在运行中的进程出错，所以需要将该条语句删除</p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220406200030431.png" alt="zero out"></p><p>在写入内存的过程中，Nachos直接将逻辑地址作为物理地址写入，对于原本一一对应的映射关系下是可行的，但在多进程机制下需要进行修改</p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220406200410702.png" alt="copy into memory"></p><p>将逻辑地址转换为物理地址：先将逻辑地址分成页号和页内偏移量两部分，根据页号查询页表得到块号，则物理地址=块号+页内偏移量。</p><p>已知逻辑地址<code>virtualAddr = noffH.code.virtualAddr</code>，则逻辑页号为<code>virtualPage = virtualAddr / pageSize</code>， 查询页表可得物理块号<code>physicalPage = pageTable[virtualPage]</code>；页内偏移量为<code>pageOffset = virtualAddr % pageSize</code></p><p>则物理地址<code>physicalAddr = physicalPage * pageSize + pageOffset</code></p><p><img src="/2022/04/24/This-is-NACHOS-4/image-20220406201011849.png" alt="copy into memory"></p><h2 id="理解进程的pid"><a href="#理解进程的pid" class="headerlink" title="理解进程的pid"></a>理解进程的pid</h2><p>pid(Process Identification) 是进程标识符，每个进程都有唯一的pid，进程创建时由系统分配</p><p>SpaceId是为可执行程序分配并装入内存空间时进程地址空间的首地址。由于该首地址是唯一的，理论上可以使用该值作为pid，但该值不连续且值过大，并不是非常合适</p><p>可以借鉴UNIX的思想，只要为每个进程分配一个唯一的整数作为pid就可以，例如0~99预留为核心进程使用，用户进程号从100开始使用</p><h2 id="理解进程退出所要完成的工作"><a href="#理解进程退出所要完成的工作" class="headerlink" title="理解进程退出所要完成的工作"></a>理解进程退出所要完成的工作</h2><p>根据进程创建时系统为其所做的工作，当一个进程退出时，应当释放其所占用的内存空间及页表等信息，并且收回为其分配的pid，供后续进程使用</p>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>OperatingSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>This Is NACHOS#3</title>
    <link href="/2022/04/06/This-is-NACHOS-3/"/>
    <url>/2022/04/06/This-is-NACHOS-3/</url>
    
    <content type="html"><![CDATA[<p>该实验将体验Nachos的用户程序、应用进程进程及Nachos系统调用的相关概念,为后续实验中实现系统调用Exec()与Exit()奠定基础</p><p>通过该实验，你需要</p><ul><li>理解Nachos可执行文件的格式与结构</li><li>掌握Nachos应用程序的编程语法，了解用户进程是如何通过系统调用与操作系统内核进行交互的</li><li>掌握如何利用交叉编译生成Nachos的可执行程序</li><li>理解系统如何为应用程序创建进程，并启动进程</li><li>理解如何将用户线程映射到核心线程，核心线程执行用户程序的原理与方法</li><li>理解当前进程的页表是如何与CPU使用的页表进行关联的</li></ul><h2 id="Nachos可执行程序的格式"><a href="#Nachos可执行程序的格式" class="headerlink" title="Nachos可执行程序的格式"></a>Nachos可执行程序的格式</h2><p>阅读../bin/noff.h</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220329092509056.png" alt="noff.h"></p><p>noff文件中包含三个段：</p><ul><li><code>code</code>代码段</li><li><code>initData</code>初始化数据段</li><li><code>uninitData</code>未初始化数据段</li></ul><p>noff文件头中包含用于区分的<code>noffMagic</code>，和三个段在虚拟空间中的起始位置<code>virtualAddr</code>、在文件中的起始位置<code>inFileAddr</code>、段大小<code>size</code></p><h2 id="Nachos应用程序与可执行程序"><a href="#Nachos应用程序与可执行程序" class="headerlink" title="Nachos应用程序与可执行程序"></a>Nachos应用程序与可执行程序</h2><p>阅读../test目录下的几个Nachos程序，以../test/halt.c为例</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220329093646986.png" alt="halt.c"></p><p>可以看出Nachos应用程序的编程语法为C，引入<code>syscall.h</code>头文件后，直接调用系统调用函数<code>Halt()</code>与操作内核进行交互，终止操作系统。</p><p>由于Nachos模拟了一个执行MIPS指令的CPU，因此需要将用户编写的Nachos应用程序编译成MIPS框架的可执行程序。Nachos提供了一个交叉编译程序<code>gcc-2.8.1-mips.tar.gz</code>，可将Nachos用户编写的应用程序编译成MIPS指令集的可执行程序，然后在Nachos中运行。阅读../test/Makefile可知</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220329095222763.png" alt="Makefile"></p><p>gcc MIPS交叉编译器将Nachos的应用程序编译成coff格式的可执行文件，然后利用../test/coff2noff将coff格式的可执行程序转换成Nachos CPU可识别的noff可执行程序。</p><p>在../test目录中通过下述命令生成<code>halt.c</code>对应的汇编代码<code>halt.s</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/usr/local/mips/bin/decstation-ultrix-gcc -I ../userprog -I ../threads -S halt.c<br></code></pre></div></td></tr></table></figure><p>分析该汇编代码，主函数main的栈帧（stack frame）如下创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">.frame$fp,40,$31# vars= 16, regs= 2/0, args= 16, extra= 0<br>.mask0xc0000000,-4<br>.fmask0x00000000,0<br>subu$sp,$sp,40<br>sw$31,36($sp)<br>sw$fp,32($sp)<br>move$fp,$sp<br>jal__main<br></code></pre></div></td></tr></table></figure><p>主函数main的栈帧如下撤销：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">$L1:<br>move$sp,$fp<br>lw$31,36($sp)<br>lw$fp,32($sp)<br>addu$sp,$sp,40<br>j$31<br>.endmain<br></code></pre></div></td></tr></table></figure><p>C语言程序中的语句对应的机器指令如下注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">jal__main<br># k = 3<br>li$2,3# 0x00000003<br>sw$2,24($fp)<br># i = 2<br>li$2,2# 0x00000002<br>sw$2,16($fp)<br># j = i-1<br>lw$2,16($fp)<br>addu$3,$2,-1<br>sw$3,20($fp)<br># k = i-j+k<br>lw$2,16($fp)<br>lw$3,20($fp)<br>subu$2,$2,$3<br>lw$3,24($fp)<br>addu$2,$3,$2<br>sw$2,24($fp)<br># Halt()<br>jalHalt<br></code></pre></div></td></tr></table></figure><p>在../userprog目录下运行Nachos应用程序halt，加上参数<code>-d m</code>输出显示Nachos模拟的MIPS CPU所执行的每条指令<code>nachos -d m x ../test/halt.noff</code>，运行结果如下：</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330191125366.png" alt="run halt"></p><h2 id="页表的系统转储"><a href="#页表的系统转储" class="headerlink" title="页表的系统转储"></a>页表的系统转储</h2><p>Nachos的存储管理采用分页管理方式，在类<code>AddrSpace</code>中添加成员函数<code>Print()</code>，在为一个应用程序新建一个地址空间后调用该函数，输出该程序的页表（页面与帧的映射关系），有助于后续程序的调试与开发。</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220406203528391.png" alt="AddrSpace::Print()"></p><p>测试。在../userprog中运行<code>nachos –x ../test/halt.noff</code>，从输出结果中可以看看程序halt的页面与帧（虚页与实页）的对应关系，以及Nachos为该程序分配的实页数为11</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330202104259.png" alt="halt&#39;s pageTable"></p><h2 id="Nachos应用程序的创建与执行"><a href="#Nachos应用程序的创建与执行" class="headerlink" title="Nachos应用程序的创建与执行"></a>Nachos应用程序的创建与执行</h2><p>在main.cc中，处理命令行参数<code>-x</code>时，调用../userprog/progtest.cc的<code>StartProcess(char *filename)</code>函数，为用户程序<code>filename</code>创建相应的进程，并启动该进程的执行</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330191759498.png" alt="main.cc &#39;-x&#39;"></p><p>阅读该函数并分析</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220406203513561.png" alt="StartProcess()"></p><h3 id="Nachos为应用程序创建进程的过程"><a href="#Nachos为应用程序创建进程的过程" class="headerlink" title="Nachos为应用程序创建进程的过程"></a>Nachos为应用程序创建进程的过程</h3><p>首先为程序分配内存空间，将用户程序装入所分配的内存空间，创建相应的页表，建立虚页与实页的映射关系</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">space = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AddrSpace</span>(executable)；<br></code></pre></div></td></tr></table></figure><p>然后将用户进程映射到一个核心线程</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">currentThread-&gt;space = space;<br></code></pre></div></td></tr></table></figure><p>初始化CPU的寄存器，包括数据寄存器、PC以及栈指针等</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">space-&gt;<span class="hljs-built_in">InitRegisters</span>();<br></code></pre></div></td></tr></table></figure><p>将用户进程的页表传递给系统核心（Machine类），以便CPU能从用户进程的地址空间中读取应用程序指令</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">space-&gt;<span class="hljs-built_in">RestoreState</span>();<br></code></pre></div></td></tr></table></figure><p>最后开始用户进程的执行，<code>Machine::Run()</code>从程序入口开始，完成取指令、译码、执行的过程，直到进程遇到<code>Exit()</code>语句或者异常才退出</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">machine-&gt;<span class="hljs-built_in">Run</span>();<br></code></pre></div></td></tr></table></figure><h3 id="系统为用户进程分配内存空间、建立页表的过程"><a href="#系统为用户进程分配内存空间、建立页表的过程" class="headerlink" title="系统为用户进程分配内存空间、建立页表的过程"></a>系统为用户进程分配内存空间、建立页表的过程</h3><p>阅读函数<code>AddrSpace::AddrSpace(OpenFile* executable)</code></p><p>首先读取可执行文件的文件头，判断是否为noff格式文件</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330194059550.png" alt="step1: Is the file .noff?"></p><p>计算该用户程序的代码段、数据段（包括初始化的全局变量与未初始化的全局变量，以及静态变量）、栈空间共需要的页数，判断是否有足够的内存空间分配</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330194331395.png" alt="step2: How big is address space?"></p><p>建立该用户程序运行进程的页表</p><blockquote><p>Nachos使用的页表中每个页表项结构如下：</p><ul><li><code>int virtualPage</code>：在虚拟内存中的页号</li><li><code>int physicalPage</code>：在物理内存中的页号</li><li><code>bool valid</code>：有效位，若置1则该页表项有效</li><li><code>bool readOnly</code>：只读位，若置1则该页不允许被修改</li><li><code>bool use</code>：使用位，当该页被访问或修改时置1</li><li><code>bool dirty</code>：脏位，当该页被修改时置1</li></ul></blockquote><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330194720015.png" alt="step3: set up the translation"></p><p>将整个内存地址空间置0，是为了将未初始化的数据段和栈段置0</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330195404955.png" alt="step4: zero out the entire address space"></p><p>将代码段和已初始化的数据段写入内存</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330195652777.png" alt="step5: copy into memory"></p><h3 id="理解应用进程如何映射到一个核心线程"><a href="#理解应用进程如何映射到一个核心线程" class="headerlink" title="理解应用进程如何映射到一个核心线程"></a>理解应用进程如何映射到一个核心线程</h3><p>线程类<code>Thread</code>维护一个私有变量<code>AddrSpace *space</code></p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330200024684.png" alt="Class Thread"></p><p><code>Thread</code>类的构造函数中，设置<code>space = NULL</code></p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220406203447807.png" alt="Thread::Thread()"></p><p>当线程与一个应用进程捆绑后，<code>space</code>指向系统为该进程所分配的内存空间，以便被调度时执行该进程所对应的应用程序</p><h3 id="理解当前进程的页表是如何与CPU使用的页表进行关联的"><a href="#理解当前进程的页表是如何与CPU使用的页表进行关联的" class="headerlink" title="理解当前进程的页表是如何与CPU使用的页表进行关联的"></a>理解当前进程的页表是如何与CPU使用的页表进行关联的</h3><p>系统核心类<code>Machine</code>中维护一个<code>pageTable</code>指针，指向当前正在运行的Nachos应用进程的页表</p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220330201115217.png" alt="class Machine"></p><p>阅读函数<code>AddrSpace::RestoreState()</code></p><p><img src="/2022/04/06/This-is-NACHOS-3/image-20220406203423599.png" alt="AddrSpace::RestoreState()"></p><p>直接将<code>machine</code>的<code>pageTable</code>指针指向了刚刚为用户进程创建的页表，实现了当前进程的页表与CPU使用的页表的关联</p>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>OperatingSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>This is NACHOS#2</title>
    <link href="/2022/03/30/This-is-NACHOS-2/"/>
    <url>/2022/03/30/This-is-NACHOS-2/</url>
    
    <content type="html"><![CDATA[<p>目前Nachos实现的文件系统存在诸多限制，其中之一是文件大小不能扩展，即无法在已经存在的文件尾部追加数据</p><p>该实验的任务就是让你修改Nachos的文件系统，以满足：</p><ul><li>文件创建时，其大小可初始化为0</li><li>当一个文件写入更多的数据时，其大小可随之增大</li><li>要求能够从一个文件的任意位置开始写入数据，即能够正确处理命令行参数<code>-ap</code> <code>-hap</code> <code>-nap</code></li></ul><p>例如，如果一个文件的大小为100字节，当从其偏移量50（第一个字节的偏移量是0）开始写入100个字节后，该文件的大小应该为150字节，如下图所示</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220330203148356.png" alt="文件的扩展"></p><p>Nachos的文件系统包括以下模块：</p><ul><li><code>class Disk</code>               //see ../machine</li><li><code>class SynchDisk</code>    //see ../filesys</li><li><code>class BitMap</code>          //see ../userprog</li><li><code>class FileHeader</code> //see ../filesys</li><li><code>class OpenFile</code>     //see ../filesys</li><li><code>class Directory</code>   //see ../filesys</li><li><code>class FileSystem</code> //see ../filesys</li></ul><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220330203354261.png" alt="Nachos文件系统结构"></p><p>通过该实验，你需要</p><ul><li>理解文件系统中文件操作的实现方法，如文件打开、读、写、扩展、定位、关闭等</li><li>理解如何管理硬盘空闲块</li><li>理解创建文件时，如何为文件分配目录项及文件头（FCB）</li><li>理解文件扩展时，如何为要扩展的数据查找并分配空闲块</li><li>理解文件扩展后，文件大小是如何记录与保存的</li><li>理解文件被删除后，如何回收为其分配的资源，如文件头、目录项、硬盘块等</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li><code>nachos [-d f] –ap Unix_filename Nachos_filename</code><br>该命令的功能是将一个UNIX文件（unix_filename）附加到一个Nachos文件（nachos_filename）的后面，目的是用来测试当我们在一个Nachos的文件尾部追加数据后，文件大小是否会增加。</li><li><code>nachos [-d f] –hap Unix_filename Nachos_filename</code><br>该命令的功能是从一个Nachos文件（nachos_filename）的中间（文件大小的1/2）位置开始，将一个UNIX文件（unix_filename）写入到该Nachos文件中。如果这个UNIX文件大于Nachos文件的一半，则该目录执行后，新的Nachos文件的大小将增加。</li><li><code>nachos [-d f] –nap Nachos_filename1 Nachos_filename1</code><br>该命令的功能是将一个Nachos文件（nachos_filename1）附加到一个Nachos文件（nachos_filename2）的后面，目的是用来测试当我们在一个Nachos的文件尾部写入数据时，文件大小是否会增加。</li></ul><p>执行上述命令时会出现如下错误</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323130711260.png" alt></p><p>在<code>./lab5/main.cc</code>中查看对命令行参数<code>-ap</code> <code>-hap</code> <code>-nap</code>的处理过程</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220322094739607.png" alt></p><p>发现<code>-ap</code> <code>-hap</code>与函数<code>Append(..)</code>有关，<code>-nap</code>与函数 <code>NAppend(..)</code>有关</p><p>跳转阅读<code>./lab5/fstest.cc</code>中的这两个函数，找到报错行149</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323131227511.png" alt></p><p>发现是由于写数据结果<code>result</code>和已读数据<code>amountRead</code>不一致导致的报错</p><p>找到<code>result</code>的产生位置，是<code>OpenFile::Write(..)</code>的返回结果</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323131500024.png" alt></p><p>进入<code>OpenFile::Write(..)</code>函数内部查看，<code>result</code>实则是<code>OpenFile::WirteAt(..)</code>函数的返回结果，该函数试图从当前文件头对应的文件的指定位置<code>position</code>开始写入缓冲区<code>from</code>中<code>numBytes</code>大小的内容</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323132028728.png" alt></p><p>分析该函数的实现：</p><ul><li><p>首先从当前文件的文件头中获取文件长度<code>fileLength</code></p></li><li><p>约束1：如果要写入的内容不存在<code>numBytes&lt;=0</code>或是开始写入的位置为文件尾或超出了文件尾<code>position&gt;=fileLength</code>，则直接退出</p></li><li><p>约束2：如果要写入的内容过多超出了原文件的长度<code>(position+numBytes)&gt;fileLength</code>，超出部分也不再写入</p></li></ul><p>这两个<code>if</code>约束导致目前Nachos实现的文件系统不能对文件的大小进行扩展，所以需要对其进行修改：</p><ul><li>修改上面的两个约束，使Nachos文件大小可以扩展</li><li>如果文件的最后一个扇区能够容纳扩展的数据，则要修改文件头中的文件长度，再将文件头写回硬盘</li><li>如果文件的最后一个扇区不能够容纳扩展的数据，则要为这些数据分配新的扇区，那么就需要修改硬盘的位图和文件头中的文件长度、分配的扇区数、分配的扇区号，再将修改的内容写回硬盘</li></ul><p>而在<code>Append(..)</code>与 <code>NAppend(..)</code>中将文件头写回硬盘的操作<code>OpenFile::WriteBack()</code>未被实现，需要我们补充</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323153623437.png" alt></p><p>因此文件扩展操作需要涉及的内容有：</p><ul><li><p>修改<code>OpenFile::WriteAt()</code>，允许从文件尾部开始写数据，并可为要写入的数据分配新的扇区</p></li><li><p>修改<code>FileSystem</code>类，添加空闲块位示图文件的硬盘读写操作</p></li><li><p>修改<code>OpenFile::OpenFile()</code>及<code>OpenFile::WriteBack()</code>，实现文件头的硬盘读写</p></li><li><p>修改<code>FileHeader::Allocate()</code>，为添加的数据分配硬盘块（扇区）</p></li><li><p>修改<code>Append()</code>和<code>NAppend()</code>，使下次的写指针指向新写入数据的尾部，并在扩展操作结束后调用<code>OpenFile::WriteBack()</code>将修改后的文件头写入硬盘</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="修改OpenFile-WriteAt"><a href="#修改OpenFile-WriteAt" class="headerlink" title="修改OpenFile::WriteAt()"></a>修改<code>OpenFile::WriteAt()</code></h3><p>修改两个约束</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((numBytes &lt;= <span class="hljs-number">0</span>) || (position &gt; fileLength))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br><span class="hljs-keyword">if</span>((position + numBytes) &gt; fileLength)&#123;<br>    <span class="hljs-keyword">int</span> incrementBytes = (position + numBytes) - fileLength;<br>    BitMap* freeBitMap = fileSystem-&gt;<span class="hljs-built_in">getBitMap</span>(); <span class="hljs-comment">// TODO </span><br>    <span class="hljs-keyword">bool</span> hdrRet = hdr-&gt;<span class="hljs-built_in">Allocate</span>(freeBitMap, fileLength, incrementBytes); <span class="hljs-comment">// TODO</span><br>    <span class="hljs-keyword">if</span>(!hdrRet)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    fileSystem-&gt;<span class="hljs-built_in">setBitMap</span>(freeBitMap); <span class="hljs-comment">//TODO</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于约束1，如果要写入的内容不存在<code>numBytes&lt;=0</code>或是开始写入的位置超出了文件尾<code>position&gt;fileLength</code>，则直接返回错误参数<code>-1</code>。这里保留了开始写入的位置为文件尾<code>position==fileLength</code>，说明文件需要扩展。</p><p>对于约束2，保留超出部分的数据<code>incrementBytes</code>；获得当前硬盘的位图<code>freeBitMap</code>；检查是否有足够的空间分配给超出部分的数据，返回结果<code>hdrRet</code>；如果没有足够空间，则返回错误参数<code>-1</code>；如果有足够的空间，则将更新后的位图写回硬盘</p><h3 id="修改FileSystem类"><a href="#修改FileSystem类" class="headerlink" title="修改FileSystem类"></a>修改<code>FileSystem</code>类</h3><p>添加<code>setBitMap()</code>和<code>getBitMap()</code></p><p>在类<code>FileSystem</code>的构造函数中，维护了一直处于打开状态的位图文件句柄<code>OpenFile* freeMapFile</code>，我们可以直接使用它们实现对DISK的位图文件的读写操作</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BitMap* <span class="hljs-title">FileSystem::getBitMap</span><span class="hljs-params">()</span></span>&#123;<br>    BitMap* freeBitMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BitMap</span>(NumSectors);<br>    freeBitMap-&gt;<span class="hljs-built_in">FetchFrom</span>(freeMapFile);<br>    <span class="hljs-keyword">return</span> freeBitMap;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileSystem::setBitMap</span><span class="hljs-params">(BitMap* freeMap)</span></span>&#123;<br>    freeMap-&gt;<span class="hljs-built_in">WriteBack</span>(freeMapFile);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>getBitMap()</code>调用了<code>../userprog/bitmap.cc</code>中<code>BitMap</code>类的<code>FetchFrom(OpenFile *)</code></p><p><code>setBitMap()</code>调用了<code>BitMap</code>类的<code>WriteBack(OpenFile *)</code>完成</p><h3 id="修改OpenFile-OpenFile-及OpenFile-WriteBack"><a href="#修改OpenFile-OpenFile-及OpenFile-WriteBack" class="headerlink" title="修改OpenFile::OpenFile()及OpenFile::WriteBack()"></a>修改<code>OpenFile::OpenFile()</code>及<code>OpenFile::WriteBack()</code></h3><p>分析<code>OpenFile</code>类的构造函数</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323153816341.png" alt></p><p>维护了一个<code>FileHeader</code>类对象<code>hdr</code>，从硬盘的指定扇区<code>sector</code>中读取了该文件的文件头，并将读写指针<code>seekPosition</code>设置为开始位置<code>0</code></p><p>考虑到类<code>FileHeader</code>中有函数<code>WriteBack(int sector)</code></p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323154355512.png" alt></p><p>为了将文件头写回硬盘，我们可以调用这个函数，实现<code>hdr-&gt;WriteBack(sector)</code></p><p>而该实现需要获得该文件头所在的扇区号，所以在<code>OpenFile</code>类中定义一个私有变量<code>hdrSector</code>并维护</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">OpenFile::<span class="hljs-built_in">OpenFile</span>(<span class="hljs-keyword">int</span> sector)<br>&#123; <br>    hdr = <span class="hljs-keyword">new</span> FileHeader;<br>    hdr-&gt;<span class="hljs-built_in">FetchFrom</span>(sector);<br>    seekPosition = <span class="hljs-number">0</span>;<br>    hdrSector = sector; <span class="hljs-comment">// ADD</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么，进而可以实现<code>OpenFile::WriteBack()</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenFile::WriteBack</span><span class="hljs-params">()</span></span>&#123;<br>    hdr-&gt;<span class="hljs-built_in">WriteBack</span>(hdrSector);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="修改FileHeader-Allocate"><a href="#修改FileHeader-Allocate" class="headerlink" title="修改FileHeader::Allocate()"></a>修改<code>FileHeader::Allocate()</code></h3><p>重载函数<code>FileHeader::Allocate(BitMap* freeMap, int fileSize, int incrementBytes)</code>，以根据要扩展的数据大小<code>incrementBytes</code>判断是否需要分配新的扇区块来返回结果，并更新文件头三元组</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FileHeader::Allocate</span><span class="hljs-params">(BitMap* freeMap, <span class="hljs-keyword">int</span> fileSize, <span class="hljs-keyword">int</span> incrementBytes)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(numSectors &gt; NumDirect)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>((fileSize == <span class="hljs-number">0</span>) &amp;&amp; (incrementBytes &gt; <span class="hljs-number">0</span>))&#123;<br>        <span class="hljs-keyword">if</span>(freeMap-&gt;<span class="hljs-built_in">NumClear</span>() &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        dataSectors[<span class="hljs-number">0</span>] = freeMap-&gt;<span class="hljs-built_in">Find</span>();<br>        numSectors = <span class="hljs-number">1</span>;<br>        numBytes = <span class="hljs-number">0</span>;<br>    &#125;<br>    numBytes = fileSize;<br>    <span class="hljs-keyword">int</span> offset = numBytes % SectorSize;<br>    <span class="hljs-keyword">int</span> newSectorBytes = incrementBytes - (SectorSize - (offset + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span>(newSectorBytes &lt;= <span class="hljs-number">0</span>)&#123;<br>        numBytes += incrementBytes;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> moreSectors = <span class="hljs-built_in">divRoundUp</span>(newSectorBytes, SectorSize);<br>    <span class="hljs-keyword">if</span>(numSectors + moreSectors &gt; NumDirect)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(freeMap-&gt;<span class="hljs-built_in">NumClear</span>() &lt; moreSectors)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numSectors; i&lt;numSectors+moreSectors; i++)<br>        dataSectors[i] = freeMap-&gt;<span class="hljs-built_in">Find</span>();<br>    numBytes += incrementBytes;<br>    numSectors += moreSectors;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>如果当前文件已分配的扇区数大于限制，则退出不予分配</li><li>如果当前文件是空文件且要写入数据，那么首先要为该文件分配一个空闲扇区，并更新文件头信息</li><li>如果当前文件最后一个扇区的剩余空间足以容纳要写入的<code>incrementBytes</code>个字节，就不需要为写入操作分配新的扇区，在最后一个扇区中写入数据即可。但要修改文件头中文件大小信息</li><li>如果当前文件最后一个扇区的剩余空间无法容纳要写入的<code>incrementBytes</code>个字节，就需要为写入操作分配新的扇区，通过计算得出需要分配的扇区数<code>moreSectors</code><ul><li>如果扩展后文件过大超出限制，则退出不予分配</li><li>如果硬盘中没有足够的空闲扇区，则退出无法分配</li><li>如果符合条件可以分配，则要更新文件头信息</li></ul></li></ul><h3 id="修改Append-和NAppend"><a href="#修改Append-和NAppend" class="headerlink" title="修改Append()和NAppend()"></a>修改<code>Append()</code>和<code>NAppend()</code></h3><p><code>Append()</code>和<code>NAppend()</code>调用了修改后的<code>OpenFile::WriteAt()</code>，<code>OpenFile::WriteAt()</code>调用了重载的<code>FileHeader::Allocate()</code>，<code>FileHeader::Allocate()</code>根据每次写入的数据修改文件头三元组，但一直在内存中，尚未写回硬盘，因此在<code>Append()</code>和<code>NAppend()</code>的写操作结束后，应该调用<code>OpenFile::WriteBack()</code>将修改后的文件头写回到硬盘的相应的扇区中</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">openFile-&gt;<span class="hljs-built_in">WriteBack</span>();<br></code></pre></div></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>为容易识别硬盘DISK信息的改变，修改<code>../file/test/</code>下的文件内容</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192417516.png" alt></p></li><li><p><code>nachos –f</code>  在硬盘DISK上初始化一个Nachos文件系统</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192531213.png" alt></p><p><code>nachos –D</code> </p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192624590.png" alt></p><p>考察Nachos在硬盘DISK上初始化的文件系统情况：</p><ul><li>空闲块位图的头文件（0号扇区）</li><li>空闲块位图文件数据块（2号扇区）</li><li>目录表头文件（1号扇区）</li><li>目录表数据块（3、4号扇区)</li></ul></li><li><p><code>nachos –cp test/small small</code>复制test目录下的UNIX文件small到DISK中</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192819418.png" alt></p><p><code>nachos –D</code> </p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192905582.png" alt></p><p>查看硬盘DISK中的文件信息：</p><ul><li><p>空闲块位图的头文件（0号扇区）</p></li><li><p>空闲块位图文件数据块（2号扇区）</p></li><li><p>目录表头文件（1号扇区）</p></li><li><p>目录表数据块（3、4号扇区）</p></li><li><p>文件small的头文件（5号扇区）</p></li><li><p>文件small的数据块（6号扇区）</p></li></ul></li><li><p><code>nachos –ap test/small small</code> 测试给一个已存在的文件追加数据</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193208886.png" alt></p><p><code>nachos –D</code>  查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193600435.png" alt></p><p>系统成功将small文件的内容扩展到small文件原扇区的剩余空间中</p></li><li><p><code>nachos –ap test/big small</code> 测试为文件分配新扇区的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193710627.png" alt></p><p><code>nachos –D</code> 以及 <code>hexdump -C DISK</code>查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193803974.png" alt></p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193915926.png" alt></p><p>系统将samll文件原扇区的剩余空间写满后，为small分配新的扇区块，写入big的内容</p></li><li><p><code>nachos –ap test/medium medium</code>，测试给一个空文件追加数据的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194032389.png" alt></p><p><code>nachos –D</code>  查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194152122.png" alt></p><p>如果DISK中不存在文件，将会自动创建一个空的文件，然后将源文件内容追加到Nachos空文件中</p></li><li><p><code>nachos –ap test/big small</code> 测试Nachos为small新分配的扇区块的位置</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194326272.png" alt></p></li><li><p><code>nachos –D</code>查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194427520.png" alt></p><p>在执行它之前，由于small的数据块之后的扇区是medium文件的文件头及其数据块，因此，系统会在medium文件之后为small分配新的扇区10</p><p>Nachos的文件系统采取索引分配文件数据块的方式，文件的数据块在硬盘上可以是非连续存放的，这使文件的扩展易于实现</p></li><li><p><code>nachos –hap test/medium small</code> 测试从small的中间写入文件的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195008517.png" alt></p><p><code>nachos –D</code> 查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195050848.png" alt></p><p>系统成功在small的中间写入文件<code>test/medium</code>的内容</p></li><li><p><code>nachos –nap medium small</code> 测试将一个nachos文件附加到另一个nachos文件的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195231325.png" alt></p><p><code>nachos –D</code> 查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195307639.png" alt></p><p>系统成功将nachos文件medium附加到nachos文件small的尾部</p></li><li><p><code>nachos –r small</code> 测试文件删除功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195352234.png" alt></p><p><code>nachos –D</code> 及<code>hexdump –C DISK</code>查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195423461.png" alt></p><p>原来的small文件相关信息都消失不见，其他文件信息保持不变</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195701406.png" alt></p><p>位示图数据块：值变为<code>0x31f</code>，即<code>1100011111</code>，表示5号、6号、7号扇区空闲，即为原small文件的文件头和数据部分占用的扇区</p><p>目录表数据块：<code>inUse</code>值变为0，表示为原small文件分配的目录项空闲，而其他内容保持不变</p><p>small的文件头以及small文件内容：均被保留</p></li><li><p>测试<code>nachos –l</code>（列目录）命令</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200257908.png" alt></p></li><li><p>测试<code>nachos –p</code> （显示文件内容）命令</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200330654.png" alt></p></li><li><p>反复运行<code>nachos –ap test/big small</code> 测试nachos文件系统中对一个文件长度的限制</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200607481.png" alt></p><p><code>nachos –D</code> 查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200721073.png" alt></p><p>一个文件最多可分配30个扇区，每个扇区128字节，因此理论上文件最大限制为3840B</p><p>但测试中small文件大小为3832B，因为写文件的过程中不是逐字节写入的，而是使用了一个10B大小的缓冲区。big文件大小为99B，所以在38次追加big文件后，small文件达到3762B，而在第39次追加big文件时，每10B写入small文件，当写入70B后达到3832B，这之后再想写入10B则会超过限额3840B，则不进行该次写入操作，最终small文件的大小即为3832B</p></li><li><p>反复运行<code>nachos –ap</code> 在硬盘DISK上新建文件，测试nachos文件系统中最多可创建多少个文件</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323201540449.png" alt></p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323201612333.png" alt></p><p>报错之后共有10个文件，因为nachos采用一级目录，最多有10个目录项，因此最多可存储10个文件</p></li><li><p>测试创建一个大小为0的文件</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323201937280.png" alt></p><p>将空文件<code>test/empty</code>复制到硬盘中，使用<code>nachos -D</code>查看DISK中的文件信息，发现empty文件的大小为0，没有为它分配数据块</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>OperatingSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>This is NACHOS#1</title>
    <link href="/2022/03/28/This-is-NACHOS-1/"/>
    <url>/2022/03/28/This-is-NACHOS-1/</url>
    
    <content type="html"><![CDATA[<p>Nachos模拟了一个硬盘，实现的文件系统比较简单，该实验将熟悉一些文件系统的操作命令，观察这些命令对硬盘（DISK）的影响，根据结果分析理解Nachos文件系统的实现原理。</p><p>该实验中需要理解一些Nachos文件的基本知识，特别是文件头（FCB或索引节点）的结构与作用，空闲块的标识方法，空闲块的分配与回收过程等。</p><p>文件的扩展实质上是从一个给定的位置开始对文件进行写操作，涉及到文件的打开、定位，空闲块的分配等操作，写操作结束后还需要将文件头、空闲块位示图写到硬盘中，以保存修改后的信息。</p><p>该实验完成后，需要你：</p><ul><li>理解Nachos硬盘是如何创建的</li><li>熟悉查看Nachos硬盘上的内容的方法</li><li>理解硬盘初始化的过程（如何在硬盘上创建一个文件系统）</li><li>了解Nachos文件系统提供了哪些命令，哪些命令已经实现，哪些需要你自己实现</li><li>理解已经实现的文件系统命令的实现原理</li><li>理解硬盘空闲块的管理方法</li><li>理解目录文件的结构与管理</li><li>理解文件的结构与文件数据块的分配方法</li><li>了解一个文件系统命令执行后，硬盘的布局</li><li>分析目前Nachos不能对文件进行扩展的原因，考虑解决方案</li></ul><h2 id="理解Nachos创建硬盘的过程与方法"><a href="#理解Nachos创建硬盘的过程与方法" class="headerlink" title="理解Nachos创建硬盘的过程与方法"></a>理解Nachos创建硬盘的过程与方法</h2><p>../lab5/main.cc调用了../threads/system.cc中的<code>Initialize()</code>创建了硬盘DISK</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316101048494.png" alt></p><p><code>SynchDisk</code>的初始化函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ../filesys/synchdisk.cc</span><br>SynchDisk::<span class="hljs-built_in">SynchDisk</span>(<span class="hljs-keyword">char</span>* name)<br>&#123;<br>    semaphore = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(<span class="hljs-string">&quot;synch disk&quot;</span>, <span class="hljs-number">0</span>);<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Lock</span>(<span class="hljs-string">&quot;synch disk lock&quot;</span>);<br>    disk = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Disk</span>(name, DiskRequestDone, (_int) <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化了物理硬盘的同步接口：用于同步的信号量和互斥锁</p><p>创建了模拟硬盘，其初始化函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ../machine/disk.cc</span><br>Disk::<span class="hljs-built_in">Disk</span>(<span class="hljs-keyword">char</span>* name, VoidFunctionPtr callWhenDone, _int callArg)<br>&#123;<br>    <span class="hljs-keyword">int</span> magicNum;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&quot;Initializing the disk, 0x%x 0x%x\n&quot;</span>, callWhenDone, callArg);<br>    handler = callWhenDone;<br>    handlerArg = callArg;<br>    lastSector = <span class="hljs-number">0</span>;<br>    bufferInit = <span class="hljs-number">0</span>;<br>    <br>    fileno = <span class="hljs-built_in">OpenForReadWrite</span>(name, FALSE);<br>    <span class="hljs-keyword">if</span> (fileno &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// file exists, check magic number </span><br><span class="hljs-built_in">Read</span>(fileno, (<span class="hljs-keyword">char</span> *) &amp;magicNum, MagicSize);<br><span class="hljs-built_in">ASSERT</span>(magicNum == MagicNumber);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// file doesn&#x27;t exist, create it</span><br>        fileno = <span class="hljs-built_in">OpenForWrite</span>(name);<br>magicNum = MagicNumber;  <br><span class="hljs-built_in">WriteFile</span>(fileno, (<span class="hljs-keyword">char</span> *) &amp;magicNum, MagicSize); <span class="hljs-comment">// write magic number</span><br><br><span class="hljs-comment">// need to write at end of file, so that reads will not return EOF</span><br>        <span class="hljs-built_in">Lseek</span>(fileno, DiskSize - <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">WriteFile</span>(fileno, (<span class="hljs-keyword">char</span> *)&amp;tmp, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));  <br>    &#125;<br>    active = FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>打开一个UNIX文件（若不存在则创建）用于读写，向该文件写入一个<code>magicNum</code>来标识该文件是一个硬盘存储文件，并在该文件最末尾写入<code>0</code>标记文件结束，腾出存储空间</p><h2 id="了解Nachos文件系统提供的命令并测试"><a href="#了解Nachos文件系统提供的命令并测试" class="headerlink" title="了解Nachos文件系统提供的命令并测试"></a>了解Nachos文件系统提供的命令并测试</h2><p>分析../lab5/main.cc</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316102901201.png" alt></p><p>Nachos文件系统提供的命令有：</p><ul><li><code>-cp</code>：复制UNIX文件到Nachos文件（正确运行）</li><li><code>-ap</code>：将UNIX文件内容增加到Nachos文件后（未正确运行）</li><li><code>-hap</code>：将Nachos文件内容剪掉后半部分再将UNIX文件内容增至其后（未正确运行）</li><li><code>-nap</code>：将Nachos文件内容增加到Nachos文件后（未正确运行）</li><li><code>-p</code>：打印Nachos文件内容（正确运行）</li><li><code>-r</code>：删除Nachos文件（正确运行）</li><li><code>-l</code>：列出Nachos文件列表（正确运行）</li><li><code>-D</code>：打印整个文件系统（正确运行）</li><li><code>-t</code>：性能测试（未正确运行）</li></ul><h2 id="理解Nachos硬盘格式化（创建文件系统）的处理过程"><a href="#理解Nachos硬盘格式化（创建文件系统）的处理过程" class="headerlink" title="理解Nachos硬盘格式化（创建文件系统）的处理过程"></a>理解Nachos硬盘格式化（创建文件系统）的处理过程</h2><p>分析../filesys/filesys.cc中的构造函数<code>FileSystem::FileSystem(..)</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ../filesys/filesys.cc</span><br>FileSystem::<span class="hljs-built_in">FileSystem</span>(<span class="hljs-keyword">bool</span> format)<br>&#123; <br>    <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Initializing the file system.\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (format) &#123;<br>        BitMap *freeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BitMap</span>(NumSectors);<br>        Directory *directory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Directory</span>(NumDirEntries);<br>        FileHeader *mapHdr = <span class="hljs-keyword">new</span> FileHeader;<br>        FileHeader *dirHdr = <span class="hljs-keyword">new</span> FileHeader;<br><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Formatting the file system.\n&quot;</span>);<br><br>    <span class="hljs-comment">// First, allocate space for FileHeaders for the directory and bitmap</span><br>    <span class="hljs-comment">// (make sure no one else grabs these!)</span><br>freeMap-&gt;<span class="hljs-built_in">Mark</span>(FreeMapSector);    <br>freeMap-&gt;<span class="hljs-built_in">Mark</span>(DirectorySector);<br><br>    <span class="hljs-comment">// Second, allocate space for the data blocks containing the contents</span><br>    <span class="hljs-comment">// of the directory and bitmap files.  There better be enough space!</span><br><br><span class="hljs-built_in">ASSERT</span>(mapHdr-&gt;<span class="hljs-built_in">Allocate</span>(freeMap, FreeMapFileSize));<br><span class="hljs-built_in">ASSERT</span>(dirHdr-&gt;<span class="hljs-built_in">Allocate</span>(freeMap, DirectoryFileSize));<br><br>    <span class="hljs-comment">// Flush the bitmap and directory FileHeaders back to disk</span><br>    <span class="hljs-comment">// We need to do this before we can &quot;Open&quot; the file, since open</span><br>    <span class="hljs-comment">// reads the file header off of disk (and currently the disk has garbage</span><br>    <span class="hljs-comment">// on it!).</span><br><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Writing headers back to disk.\n&quot;</span>);<br>mapHdr-&gt;<span class="hljs-built_in">WriteBack</span>(FreeMapSector);    <br>dirHdr-&gt;<span class="hljs-built_in">WriteBack</span>(DirectorySector);<br><br>    <span class="hljs-comment">// OK to open the bitmap and directory files now</span><br>    <span class="hljs-comment">// The file system operations assume these two files are left open</span><br>    <span class="hljs-comment">// while Nachos is running.</span><br><br>        freeMapFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(FreeMapSector);<br>        directoryFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(DirectorySector);<br>     <br>    <span class="hljs-comment">// Once we have the files &quot;open&quot;, we can write the initial version</span><br>    <span class="hljs-comment">// of each file back to disk.  The directory at this point is completely</span><br>    <span class="hljs-comment">// empty; but the bitmap has been changed to reflect the fact that</span><br>    <span class="hljs-comment">// sectors on the disk have been allocated for the file headers and</span><br>    <span class="hljs-comment">// to hold the file data for the directory and bitmap.</span><br><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Writing bitmap and directory back to disk.\n&quot;</span>);<br>freeMap-&gt;<span class="hljs-built_in">WriteBack</span>(freeMapFile); <span class="hljs-comment">// flush changes to disk</span><br>directory-&gt;<span class="hljs-built_in">WriteBack</span>(directoryFile);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DebugIsEnabled</span>(<span class="hljs-string">&#x27;f&#x27;</span>)) &#123;<br>    freeMap-&gt;<span class="hljs-built_in">Print</span>();<br>    directory-&gt;<span class="hljs-built_in">Print</span>();<br><br>        <span class="hljs-keyword">delete</span> freeMap; <br><span class="hljs-keyword">delete</span> directory; <br><span class="hljs-keyword">delete</span> mapHdr; <br><span class="hljs-keyword">delete</span> dirHdr;<br>&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// if we are not formatting the disk, just open the files representing</span><br>    <span class="hljs-comment">// the bitmap and directory; these are left open while Nachos is running</span><br>        freeMapFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(FreeMapSector);<br>        directoryFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(DirectorySector);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参数<code>format</code>表示是否将硬盘格式化，当命令行输入<code>-f</code>后则置其为<code>true</code></p><p>需要初始化磁盘使其包含一个空的目录<code>directory</code>和空闲块位图<code>freeMap</code></p><blockquote><p>Nachos模拟的硬盘DISK共有32个道，每个道有32个扇区，每个扇区128个字节，每个盘块仅包含一个扇区，所以共有1024个盘块，所以位图共1024位</p><p>Nachos文件系统采用单级目录结构，根目录中只有10个目录项，意味着Nachos的硬盘中最多可创建10个文件</p></blockquote><p>而这两个也被视作文件，同样需要文件头<code>mapHdr</code> <code>dirHdr</code></p><ol><li>为这两个文件头分配空间，位图的文件头被分配在0号扇区，目录的文件头被分配在1号扇区</li></ol><blockquote><p>思考：为什么将空闲块管理的位示图文件头与目录表文件头存放在0号和1号这两个特殊的扇区中？</p><p>初始化文件系统时，将这两个特殊的扇区设置为已使用，确保其他文件不会访问到。而对于一个真正的操作系统，由于系统启动时需要根据目录文件的文件头访问根目录，所以为了便于系统启动时从已知的、固定的位置访问它们，将这两个特殊的结构分配到0号和1号两个特殊的扇区中。</p></blockquote><ol><li>为目录和位图的数据块分配空间，同时更新对应的文件头内容</li></ol><blockquote><p>文件头内容包含：</p><ul><li><code>numBytes</code>文件大小</li><li><code>numSectors</code>分配给文件的块数</li><li><code>dataSector[]</code>文件每个数据块对应的扇区号</li></ul><p>位图文件大小为1024/8=128B，目录文件大小为目录项大小*10=20*10=200B</p><blockquote><p>目录项内容包含：</p><ul><li><code>inUser</code>该目录项是否已分配</li><li><code>sector</code>文件头所在的扇区号</li><li><code>name</code>文件名</li></ul></blockquote></blockquote><ol><li>将目录和位图的文件头内容写回到磁盘（0号和1号扇区）中</li><li>打开目录和位图文件</li><li>将位图的数据内容写回磁盘中，因为刚刚的初始化分配了空闲块，位图发生了变化，而目录仍然为空</li><li>文件系统创建完毕</li></ol><h2 id="理解文件系统管理涉及的数据结构组织与使用"><a href="#理解文件系统管理涉及的数据结构组织与使用" class="headerlink" title="理解文件系统管理涉及的数据结构组织与使用"></a>理解文件系统管理涉及的数据结构组织与使用</h2><p>利用命令<code>hexdump –C DISK</code>查看硬盘格式化后硬盘的布局，分析如下：</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316181837619.png" alt></p><ul><li><p>0x0~0x3：起始的4个字节为磁盘标识，设置为<code>magicNum=0x456789ab</code></p></li><li><p>0x4~0x83：0号扇区，共128个字节，存放位图的文件头，细分如下：</p><ul><li><p>0x4~0x7：4个字节，位图所占的字节数。值为<code>0x80</code>，表示位图大小为128字节</p></li><li><p>0x8~0xB：4个字节，系统为位图数据所分配的扇区数。值为<code>0x1</code>，表示位图数据只需1个扇区</p></li><li><p>0xC~0XF：位图数据块所在的扇区号。值为<code>0x2</code>，表示系统将位图数据保存在2号扇区中</p></li><li><p>0x10~0x83：空，因为位图数据只占1个扇区。</p><blockquote><p>每个扇区号占4个字节，所以0xC~0x83最多能存放30个扇区号，所以一个文件大小最大为<code>30*128=3840B</code></p></blockquote></li></ul></li><li><p>0x84~0x103：1号扇区，共128个字节，存放目录的文件头，细分如下：</p><ul><li>0x84~0x87：4个字节，目录所占的字节数。值为<code>0xc8</code>，表示目录大小为200字节</li><li>0x88~0x8B：4个字节，系统为目录数据所分配的扇区数。值为<code>0x2</code>，表示目录数据需要2个扇区</li><li>0x8C~0x8F：系统为目录数据分配的第一个扇区号，值为<code>0x3</code></li><li>0x90~0x93：系统为目录数据分配的第二个扇区号，值为<code>0x4</code></li><li>0x94~0x103：空</li></ul></li><li><p>0x104~0x183：2号扇区，共128个字节，存放位图的数据部分，值为<code>0x1f</code>，表示扇区0,1,2,3,4已被分配</p></li><li><p>0x184~0x203：3号扇区 + 0x204~0x283：4号扇区 </p><p>这两个扇区存放目录表，目前为空，值为<code>0x0</code></p></li></ul><h2 id="理解创建一个文件后相关的结构在硬盘上的存储布局"><a href="#理解创建一个文件后相关的结构在硬盘上的存储布局" class="headerlink" title="理解创建一个文件后相关的结构在硬盘上的存储布局"></a>理解创建一个文件后相关的结构在硬盘上的存储布局</h2><p>利用命令<code>nachos –cp ./test/small samll</code>复制small文件硬盘DISK中</p><p>利用命令<code>hexdump –C DISK</code>查看新建一个文件后的硬盘布局，分析如下：</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316190040837.png" alt></p><ul><li><p>0x0~0x3：磁盘标识符，不变</p></li><li><p>0x4~0x83：0号扇区，存放位图文件头，内容不变</p></li><li><p>0x84~0x103：1号扇区，存放目录文件头，内容不变</p></li><li><p>0x104~0x183：2号扇区，存放位图数据部分，由<code>0x1f</code>变为<code>0x7f</code>，说明5号和6号扇区也被分配使用，即分配给small文件头和文件内容</p></li><li><p>0x184~0x203：3号扇区，存放目录表，发生改变。因为新建了文件small，所以需要在一个空闲的目录项中添加small对应的信息：</p><ul><li>0x184~0x187：4个字节，<code>inUse</code>该目录项是否已被使用（虽然为bool类型，但为了对齐，分配4个字节）。值为<code>0x1</code>，说明该目录项正被一个文件使用</li><li>0x188~0x18B：4个字节，<code>sector</code>该目录项所记录的文件的文件头所在的扇区号。值为<code>0x5</code>，说明small文件的文件头在5号扇区，若要考察small的详细信息，则要到5号扇区访问其文件头</li><li><p>0x18C~0x195：10个字节，<code>name</code>文件名（文件名占用9个字节，最后一个字节是字符串结束符<code>\0</code>）。这里的文件名经过转码为<code>small</code></p></li><li><p>0x196~0x203：其余目录项为空</p></li></ul></li><li><p>0x204~0x283：4号扇区，存放目录表，依旧为空</p></li><li><p>0x284~0x303：5号扇区，存放small的文件头</p><ul><li>0x284~0x287：4个字节，文件所占的字节数。值为`0xc54，表示small文件大小为84字节</li><li>0x288~0x28B：4个字节，系统为文件数据所分配的扇区数。值为<code>0x1</code>，表示small数据需要1个扇区</li><li>0x28C~0x28F：系统为文件数据分配的扇区号。值为<code>0x6</code>，表示系统将small数据保存在6号扇区中</li><li>0x290~0x303：为空</li></ul></li><li><p>0x304~0x383：6号扇区，存放small的文件数据</p></li></ul><h2 id="分析文件系统的管理策略"><a href="#分析文件系统的管理策略" class="headerlink" title="分析文件系统的管理策略"></a>分析文件系统的管理策略</h2><p>复制文件medium, big到DISK中</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316192831856.png" alt></p><p>然后删除small文件</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316192918500.png" alt></p><p>利用<code>hexdump –C DISK</code>查看文件的布局</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316193020855.png" alt></p><ul><li>0x104~0x183：2号扇区，存放位图数据部分。值为<code>0x3f9f</code>，二进制为<code>11111110011111</code>，表示5号和6号扇区空闲，即为small文件的文件头和数据部分占用的扇区</li><li>0x184~0x203：3号扇区，存放目录表。0x184字节处变为<code>0x0</code>，表示为small分配的目录项的<code>inUse</code>位变为0，即为small文件分配的目录项空闲。而该目录项的其他内容不变</li><li>0x284~0x303：5号扇区，存放small的文件头，不变</li><li>0x304~0x383：6号扇区，存放small的文件数据，不变</li></ul><p>分析删除small文件的过程：该文件的目录表中的文件头所在扇区号和文件名、文件头信息、文件数据均未被清除；只是在位图中将该文件的扇区置为空闲，在目录表中将该文件的目录项置为空闲</p><p>因此，要恢复一个被删除的文件，只要该文件的相关信息未被覆盖，就可以根据文件名在目录表中找到该文件对应的目录项，将<code>inUse</code>恢复为1，并在位图中恢复文件头占用的扇区号，再根据文件头的信息恢复文件数据占用的扇区号。</p><p>这种删除文件的策略为恢复文件带来了极大的便利。</p>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>OperatingSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算作业#2</title>
    <link href="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<h1 id="列举威胁作用者有哪些，并简要说明"><a href="#列举威胁作用者有哪些，并简要说明" class="headerlink" title="列举威胁作用者有哪些，并简要说明"></a>列举威胁作用者有哪些，并简要说明</h1><h2 id="匿名攻击者"><a href="#匿名攻击者" class="headerlink" title="匿名攻击者"></a>匿名攻击者</h2><p><strong>是云中没有权限的、不被信任的云服务用户。</strong>它通常是一个<strong>外部</strong>软件程序，通过公网发动网络攻击。匿名攻击者往往诉诸绕过用户账号或窃取用户证书的手段，同时使用能确保匿名性或需要大量资源才能被检举的方法。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316154044175.png" alt="anonymous attacker"></p><h2 id="恶意服务作用者"><a href="#恶意服务作用者" class="headerlink" title="恶意服务作用者"></a>恶意服务作用者</h2><p><strong>截取网络通信，试图恶意地使用或篡改数据。</strong>它通常是带有被损害的或恶意逻辑的服务代理，或是伪装成服务代理的程序，或是能够远程截取并破坏消息内容的外部程序。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316154320361.png" alt="malicious service agent"></p><h2 id="授信的攻击者"><a href="#授信的攻击者" class="headerlink" title="授信的攻击者"></a>授信的攻击者</h2><p><strong>是经过授权的云服务用户，具有合法的证书。</strong>他们会滥用合法的证书或挪用敏感和保密的信息，在云的信任边界内部发动攻击，将云提供者以及与他们共享IT资源的云租户作为攻击目标。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316154954084.png" alt="trusted attacker"></p><h2 id="恶意的内部人员"><a href="#恶意的内部人员" class="headerlink" title="恶意的内部人员"></a>恶意的内部人员</h2><p><strong>是试图滥用对云资源范围的访问特权的人。</strong>他们通常是现任或前任雇员，或是能够访问云提供者资源范围的第三方。这种类型的威胁作用者会带来极大的破坏的可能性，因为恶意的内部人员可能拥有访问云用户IT资源的管理特权。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316155223495.png" alt="malicious insider"></p><h1 id="列举云安全威胁有哪些，并简要说明"><a href="#列举云安全威胁有哪些，并简要说明" class="headerlink" title="列举云安全威胁有哪些，并简要说明"></a>列举云安全威胁有哪些，并简要说明</h1><h2 id="流量监听"><a href="#流量监听" class="headerlink" title="流量监听"></a>流量监听</h2><p>数据在传输到云中或在云内部传输时<strong>被恶意服务作用者被动地截获</strong>，用于非法的信息收集之目的。这种攻击直接破坏了数据的保密性，可能也破坏了云用户和云提供者之间关系的保密性。由于其被动性，这种攻击更容易长时间进行而不被发现。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316155745470.png" alt="traffic eavesdropping"></p><h2 id="恶意媒介"><a href="#恶意媒介" class="headerlink" title="恶意媒介"></a>恶意媒介</h2><p><strong>消息被恶意服务作用者截获并且被篡改。</strong>这种攻击可能会破坏消息的保密性和完整性，还有可能在把消息转发到目的地之前插入有害数据。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316160005721.png" alt="malicious intermediary"></p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p><strong>使IT资源过载至无法正确运行</strong>。可以由以下方式发起：</p><ul><li>发送伪造的消息或重复的通信请求使云服务上的负载不正常地增加</li><li>网络流量过载，降低响应性，性能下降</li><li>发出多个云服务请求，每个请求都设计成消耗过量的内存和处理资源</li></ul><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316160613891.png" alt="DoS"></p><p>常见的DoS攻击：</p><ul><li>TCP SYN泛洪</li><li>ping泛洪</li><li>UDP泛洪</li><li>缓冲区溢出</li><li>ICMP路由重定向炸弹</li><li>分片炸弹</li></ul><h2 id="授权不足"><a href="#授权不足" class="headerlink" title="授权不足"></a>授权不足</h2><p><strong>错误地授予了攻击者访问权限或是授权太宽泛</strong>，导致攻击者能够访问到本应受保护的IT资源。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161032041.png" alt="lack of authorization"></p><p>这种攻击的一种变种称为<strong>弱认证</strong>，如果使用弱密码或共享账户来保护IT资源就可能导致这种攻击。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161133033.png" alt="weak authentication"></p><h2 id="虚拟化攻击"><a href="#虚拟化攻击" class="headerlink" title="虚拟化攻击"></a>虚拟化攻击</h2><p>虚拟化方法使IT资源共享底层硬件但逻辑上互相独立。云提供者给予云用户对虚拟化的IT资源的管理权限，带来的风险就是<strong>云用户会滥用这种访问权限来攻击底层物理IT资源</strong>。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161535380.png" alt="virtualization attack"></p><h2 id="信任边界重叠"><a href="#信任边界重叠" class="headerlink" title="信任边界重叠"></a>信任边界重叠</h2><p>当云中的物理IT资源由多个云服务用户共享时，他们的信任边界是重叠的。<strong>恶意的云服务用户可以损害其他共享同样信任边界的云服务用户或IT资源</strong>。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161827159.png" alt="trust boundary overlapping"></p>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>CloudComputing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算作业#1</title>
    <link href="/2022/03/09/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2022/03/09/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<h1 id="云使能技术包括哪些技术组件？用一句话简要说明其关键特征"><a href="#云使能技术包括哪些技术组件？用一句话简要说明其关键特征" class="headerlink" title="云使能技术包括哪些技术组件？用一句话简要说明其关键特征"></a>云使能技术包括哪些技术组件？用一句话简要说明其关键特征</h1><ul><li><p>宽带网络和Internet架构</p><p>云用户和云提供者通常利用Internet进行通信，Internet以无中心的供给和管理模型为基础，不受任何集中式实体的控制</p></li><li><p>数据中心技术</p><p>数据中心用于集中放置IT资源，有利于能源共享、提高共享IT资源使用率以及提高IT人员的效率</p></li><li><p>虚拟化技术</p><p>将物理IT资源转换为虚拟IT资源，提供了硬件无关性、服务器整合、资源复制、对资源池更强的支持和灵活的可扩展性</p></li><li><p>Web技术</p><p>Web技术经常被用于云服务的实现，并在前端用于远程管理云IT资源</p></li><li><p>多租户技术</p><p>一个物理或虚拟服务器运行着一个应用程序，该应用程序允许被多个不同用户共享，每个用户都感觉只有自己在使用该应用程序</p></li><li><p>服务技术</p><p>服务技术是云计算的基石，它形成了“作为服务”的云交付模型的基础</p></li><li><p>数据存储技术</p><p>选择分布式存储方式，采用多个副本存储同一数据或多份备份，在服务上采取并行的方法为用户提供所需服务，高传输率也是其一大特色</p></li><li><p>大规模数据管理技术</p><p>对海量数据进行处理、利用的前提是具备高效的管理大量数据的能力</p></li><li><p>编程模型</p><p>使用户能够简便、轻松地获取云环境下的编程服务</p></li></ul><h1 id="列举至少3种虚拟化软件，并用一句话概括其特点"><a href="#列举至少3种虚拟化软件，并用一句话概括其特点" class="headerlink" title="列举至少3种虚拟化软件，并用一句话概括其特点"></a>列举至少3种虚拟化软件，并用一句话概括其特点</h1><ul><li><p>VMware ESXi</p><p>侧重于服务器虚拟化，技术较成熟，功能也多，支持虚机系统多</p></li><li><p>Xenserver</p><p>重点在于桌面虚拟化，性价比高，网络性能好，适用于快速与大规模部署，支持系统也相对较多</p></li><li><p>Hype-V </p><p>微软开发，起步相对较晚，对于MS的系统较为支持</p></li><li><p>Oracle VM VirtualBox </p><p>开源，支持的系统种类繁多</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>CloudComputing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Consistency论文阅读</title>
    <link href="/2022/01/23/Consistency%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/01/23/Consistency%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://idl.cs.washington.edu/files/2018-Consistency-InfoVis.pdf">原文地址</a></p></blockquote><h1 id="保持多个视图一致：可视化创作中的约束、验证和异常"><a href="#保持多个视图一致：可视化创作中的约束、验证和异常" class="headerlink" title="保持多个视图一致：可视化创作中的约束、验证和异常"></a>保持多个视图一致：可视化创作中的约束、验证和异常</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>可视化通常以多个出现，或者以单个显示（例如，小型的多个可视化，仪表盘)，或者跨越时间或空间显示（例如，幻灯片，一组仪表板）。然而，现有的可视化设计指南通常关注单个而不是多个视图。仅仅遵循这些指导方针可能会导致有效但不一致的视图（例如，相同的字段在不同的图表中有不同的轴域)，使得解释缓慢且容易出错。此外，很少有人知道如何将一致性与其他设计相平衡，这使得在可视化创作软件中加入一致性机制是很困难的。我们将呈现一份绿野仙踪式的研究，在这项研究中，我们观察了Tableau用户如何在一个从探索到展示的可视化设计场景中实现和牺牲一致性。我们（从之前的工作中）扩展了一组编码特定约束用来定义跨视图的一致性。在我们的研究中将这些约束作为检查单来使用，我们观察到了参与者自发保持一致编码的案例和忽略一致性的警告性案例。参与者们对于警告，做出的回应要么是修改视图以保持一致性，要么是说明他们为什么认为一致性应该被覆盖。我们将参与者的行为和响应分类为约束验证和异常，描述一致性的相对重要性和在各种情况下对其他设计的考虑（例如，数据基数，可用的编码资源，图表布局)。我们讨论将自动一致性检查作为约束满足问题，并提供向用户传达不一致信息的设计意义。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>可视化通常以多个的形式创建和呈现。在分析中，用户用不同的变量或编码组合进行实验来寻找使人感兴趣的模型。对于相同的数量字段，在一个视图中用x刻度编码，在另一个视图中可能用一种颜色编码。或者说，一个字段在两个视图中会被不同地筛选，导致不同的x轴域([min;max])。当单独的可视化结合在一起后在指示板或幻灯片演示时，作者可能会忽略相同变量在视图间被不同地编码和不同变量在视图间看起来完全相同之间的不一致性，导致了观众地困惑或误解。</p><p><img src="/2022/01/23/Consistency%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_2.png" alt="Fig. 2"></p><p>可视化系统通常让用户手动选择编码细节以一致地显示数据。然而，对于多视图设计者来说，用户可以依赖的大多数现有的可视化设计标准是不能提供有效信息的。相反，聚焦于单独可视化的标准，比如最大化单张图表中中数据与墨水的比例[28]或给定名词或定量数据字段使用最有效的视觉编码[16]。因此，用户经常<br>不得不设计自己的手动策略来实现编码一致性。例如，一张图显示马力，一张图显示平均马力，作者需要手动调整刻度域以使均值更具有可比性(图2)。这里，决定是否和如何要实现编码一致性需要仔细考虑，因为使刻度具有可比性意味着不仅能充分利用现有空间来描述数据。在理想情况下，可视化工具可以帮助用户<br>确定并决定何时以及如何保持一致性和与其他设计达成平衡。然而，关于作者在创建多个视图时希望在什么时候和达成什么类型的编码一致性目前所知甚少。</p><p>在这项工作中，我们首次密切关注可视化作者在设计多个视图时如何理解并实现视图之间的一致性。我们将展示一项绿野仙踪式受启发的研究的结果，其中，一个“精灵”模拟为一名自动设计助手来评估作者设计过程中作品在不同阶段的一致性。为了使这项研究设计成为可能，我们通过扩展2D多元可视化中不同编码通道的一致性约束集[19]，促进了之前关于可视化的一致性准则[9,19,30]的工作。<br>我们通过观察作者如何感知可视化间各种形式一致性的重要性提供了对于一致性约束的初步验证。我们的工作首次对作者在某些情况下容忍不一致性的逻辑依据进行了详细的描述。最终，我们将描述在可视化创作工具中集成一致性支持的设计意义，该可视化创作工具则是我们研究的产物。</p>]]></content>
    
    
    <categories>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Visualization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEEDB论文阅读</title>
    <link href="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.vldb.org/pvldb/vol8/p2182-vartak.pdf">原文地址</a></p></blockquote><h1 id="SEEDB-高效的数据驱动可视化推荐以支持可视化分析"><a href="#SEEDB-高效的数据驱动可视化推荐以支持可视化分析" class="headerlink" title="SEEDB: 高效的数据驱动可视化推荐以支持可视化分析"></a>SEEDB: 高效的数据驱动可视化推荐以支持可视化分析</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数据分析师通常将建立可视化作为分析工作流中的第一步。但是，当处理高维数据集时，可视化显示相关或期望的数据趋势是很耗时费力的。我们提出了SEEDB，这是一个便于快速可视化分析的可视化推荐引擎：给定要研究的数据子集，SEEDB会智能地探索出可视化空间，评估期望的可视化趋势，并且推荐那些他认为最“有用”或者最“有趣”的方案。推荐有趣可视化的两个主要障碍是(a)规模：在交互时间尺度内评估大量的候选可视化方案并作出响应；(b)实用：确定用于评估可视化有趣程度的合理度量标准。对于前者，SEEDB引入了剪枝优化来快速识别高实用性的可视化，并且通过分享最优方案来最大限度地共享可视化计算。对于后者，第一步我们采用了一个基于偏差的度量标准来实现可视化，同时表明了如何将其推广到其他影响实用性的因素。我们实现了SEEDB，将它作为可以运行在任何数据库管理系统上的中间件。我们的实验表明，我们的架构能够以高准确率识别有趣的可视化。我们的优化使相关行列存储速度提高了多个数量级，并在交互时间尺度内提供了推荐方案。最终，我们通过一项用户研究论证了基于偏差的实用性度量的有效性，以及支持可视化分析的推荐的意义。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>数据可视化通常是数据分析的第一步。给出一个新的数据集或者是关于现有数据集的一个新问题时，数据分析师需要建立各种各样的可视化感受数据，来发现异常和离群值，并且找出值得进一步研究的模式。然而，当处理高维数据集时，识别显示出有趣变化和数据趋势的可视化并非易事：数据分析师必须手动指定大量的可视化，探究不同属性之间的关系（及其组合），并且检查不同的数据子集，最终才能实现有趣的或有洞察力的可视化。这种手动指定和检查每个可视化的需要妨碍了快速分析和探索。</p><p>在本篇文章中，我们解决了自动识别和推荐可视化的问题。可视化推荐的核心挑战之一是，一个可视化的有趣与否取决于很多因素。在本篇文章中，我们采用了一个简单的标准去评价可视化的有趣程度：如果一个可视化与某些参考（例如另一个数据集、历史数据或是剩余数据）有很大偏差，那么它极有可能是有趣的。虽然它简单，但我们在用户研究中（<a href="#6">第6节</a>）发现，偏差通常可以引导用户走向他们认为有趣的可视化。当然，其他因素也会使一个可视化变得有趣，比如美学，所呈现的数据特定属性（我们的交互工具允许分析师选择感兴趣的属性)，或者数据中的其他类型的趋势(例如在某些情况下缺乏偏差可能是有趣的)。因此，尽管我们的焦点在于大偏差的可视化，但我们开发了一个名为SEEDB的系统，并且它的技术支持很大程度上与有趣程度的特定定义是无关的。在<a href="#7">第7节</a>中，我们将描述如何扩展该系统以支持一个通用的实用性度量标准。</p><p>给定一个特定的趣味性标准（称为效用指标），基于这个指标推荐可视化有以下几个问题：第一，即使对于具有少量属性的中等数据集，需要考虑的可视化的数量也常常是数百或数千；对于一些数据集，单是生成它们的可视化就需要很多分钟（正如我们将在本文中看到的）。第二，评估这些可视化的效用需要对相同的底层数据进行重复计算，浪费时间和计算资源。第三，推荐需要以交互速度给出，需要以略低精度返回可视化结果的近似方法。在我们的系统SEEDB中解决这些挑战和权衡是本文的主要重点。</p><p>我们从一个解释性的示例开始，该示例解释了SEEDB用例，并激发了我们使用基于偏差的效用度量的想法。</p><p><em>例1.1 假设一名记者正在为一篇关于千禧一代的新闻文章进行研究。此前的分析显示，千禧一代比前几代人的结婚年龄更大，这引发了人们对这种变化会对更广泛的社会产生何种影响的疑问。</em></p><p><em>因此，记者正在研究婚姻状况如何影响社会经济指标，如教育和收入等。她利用美国人口普查数据[28]对美国未婚成年人和已婚成年人进行了分析。</em></p><p><em>正如许多分析工作流程中常见的那样，记者首先使用她最喜欢的可视化软件来绘制数据中的各种指标。例如，她可以构建一个图表，将平均收入作为婚姻状况的函数显示出来，将婚姻状况可视化为受教育程度的函数，绘制出与种族和性别的关系，将每周工作时间可视化，等等。根据创建的可视化的类型，可能的可视化的数量会随着数据集中指示器的数量呈指数增长。因此，创建和检查所有可能的可视化很快变得难以处理。</em></p><p><em><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_1.png" alt="Figure 1: Motivating Example"></em></p><p><em>我们已经发现，在许多分析中，显示目标数据（未婚成年人）趋势与参考数据（已婚成年人）趋势的可视化方法可能会引起分析人员的兴趣。例如，从我们的用户研究（<a href="#6">第6节</a>）中，我们知道对于这个特定的任务，分析人员会在图中找到可视化这很有趣，因为它描述的数据属性对于未婚成年人与已婚成年人是不同的。具体来说，图表显示，虽然未婚成年女性和未婚成年男性的资本收益大致相等，但已婚成年女性的资本收益仅为已婚成年男性的一半（图1c）。同一用户研究还显示，图1b是一个分析人员不感兴趣的可视化图。请注意，这张图表显示未婚和已婚成年人的年龄趋势没有不同（图1d）。</em></p><p>上面的例子表明，描述参考偏差的可视化可能会引起分析人员的兴趣；我们在本文中的目标是构建一个系统，该系统使用偏差作为一种手段，从大量潜在的可视化中识别最有趣的可视化。据我们所知，没有一个现有的系统会使用来自参考的变化来推荐可视化。正如前面所提到的，除了基于偏差的度量之外，当然还有许多其他维度可以影响可视化的感知效用，其中一些我们将在<a href="#7">第7节</a>中讨论，并将对这些度量的详细研究留给未来的工作。</p><p>我们对SEEDB的实现整合了端到端数据查询和可视化环境，允许分析师手动生成他们自己的可视化（如Tableau或Spotfire），或者根据需要获得数据驱动的建议，可以使用手动界面进一步细化。我们选择在SEEDB中同时支持自动化和手动交互，因为我们相信混合活动接口[12]对于保持分析人员处于决策圈中并允许他们驱动分析过程是必不可少的。</p><p>在将SEEDB开发为可以在任何数据库系统上运行的中间件层时，我们开发并验证了两种正交技术的使用，以使基于偏差的可视化推荐问题变得易于处理:</p><ul><li>共享计算。我们开发了一套多查询优化技术，以便在候选可视化中共享计算，从而减少了最多40倍的时间。</li><li>剪枝计算。我们开发了剪枝技术，以避免在明显低效用的可视化上浪费计算，并采用了传统基于置信区间的top-k排序[11]和多臂老虎机[38]的技术，进一步减少了5倍的时间。</li></ul><p>最后，我们开发了一个通用的基于阶段的执行框架，该框架允许我们同时利用这两种技术的优点，将执行时间减少了100倍以上，并使许多推荐实时可行。综上所述，本文的贡献有:</p><ul><li>我们构建了一个系统，该系统将参考偏差作为为分析任务找到最有趣的可视化结果的标准（<a href="#2">第2节</a>）</li><li>我们将SEEDB设计为一个中间件层，它可以在任何符合sql的DBMS上运行（<a href="#3">第3节</a>）</li><li>我们将描述SEEDB的执行引擎（<a href="#4">第4节</a>），它使用共享技术在可视化中共享计算（章节4.1）和剪枝技术，以避免低效用的可视化计算（章节4.2）</li><li>我们评估了SEEDB的性能并证明了SEEDB可以在交互的时间尺度上以高精度识别高实用性的可视化（<a href="#5">第5节</a>）</li><li>我们展示了一个受控用户研究的结果，该研究验证了我们基于偏差的效用度量，并根据手工图表构建工具评估了SEEDB，表明SEEDB可以加速有趣的可视化标识（<a href="#6">第6节</a>）</li></ul><p>我们注意到，这项工作建立在我们的短期愿景论文[24]和演示论文[36]中所描述的SEEDB的高层思想之上。</p><h2 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="2 问题描述"></a><span id="2">2 问题描述</span></h2><p>在OLAP的标准中，以及在可视化分析工具如Tableau和Polaris[1,35]中，我们关注雪花模式数据库$D$。在可视化中，我们将想要进行group-by的属性表示为维度属性$A$，将想要进行聚类的属性表示为度量属性$M$。进一步地，我们用$F$表示度量属性上的潜在聚合函数集(如COUNT, SUM, AVG)。出于可视化的目的，假设我们可以依据任何维度属性$A$对$D$进行分组，并且可以聚合任何度量属性$M$。这就产生了一个两列的表格，可以通过标准的可视化机制（如条形图或趋势线）轻松地进行可视化。(最近的研究表明，柱状图是使用可视化分析工具[22]创建的绝大多数可视化效果。)我们的技术还应用于一般的Polaris表代数[35]，在这里，我们可以一次跨多个属性进行聚合，并group-by多个属性，可能会产生两个以上的列。为了便于阐述，我们在本文中将重点介绍两列结果可视化，可以使用条形图或趋势线方便地进行可视化。</p><p>除了数据库$D$之外，我们假设分析人员表示希望研究由查询$Q$指定的数据子集。SEEDB的目标是推荐具有高效用的$Q$的可视化(我们使用偏差来测量，正如本节中所解释的那样)。我们支持的在$D$上提出的查询Q包含了选择事实表的水平部分和一个或多个维度表的常规查询。从概念上说，我们可以将此视为一个简单的选择查询，连接雪花模式中涉及的所有表的结果。即便如此，我们还可以支持投影和连接，它们的作用是在可视化中分别删除某些列或表。因此，我们在雪花模式上支持一般类型的选择-项目-连接(SPJ)查询。出于本讨论的目的，我们将重点关注连接雪花模式中所有表的结果的简单选择查询。我们注意到这类查询可以满足大多数可视化任务。例如在我们的示例中，$Q$可以从人口普查表中选择记录的任何子集。我们将$Q$的结果表示为$D_Q$。</p><p>每个SEEDB可视化都可以转换为对底层数据进行group-by查询的聚合。我们将一个可视化$V_i$视为一个函数，由一个三元组$(a,m,f)$表示，其中$m\in M, a\in A, f\in F$。我们称它为聚合视图，或者简称为视图。聚合视图对$a$执行group-by，并应用聚合函数$f$来度量属性$m$​。举个例子，$V_i(D)$表示将$D$中的数据按$a$分组，再用$f$对$m$值进行聚合的结果；$V_i(D_Q)$表示应用于$D_Q$中数据的类似的可视化。</p><p>SEEDB通过偏差确定可视化的效用；显示出查询数据集(即$D_Q$)与参考数据集(称为$D_R$)中不同趋势的可视化被认为具有很高的实用性。参考数据集$D_R$可以定义为整个基础数据集$(D)$、$D_Q$的补集$(D-D_Q)$或任意查询$Q’$ 选择的数据$(D_{Q’})$。分析师可以选择指定$D_R$；如果分析师没有指定，我们使用$D_R=D$作为默认值。给定一个视图$V_i$，基于偏差的效用计算结果为应用$V_i$于查询数据$D_Q$和应用$V_i$于参考数据$D_R$的结果偏差。应用$V_i$于查询数据的视图可以表示为下面的查询$Q_T$。我们称之为目标视图。</p><script type="math/tex; mode=display">Q_T=SELECT \ a,f(m)\ FROM\ D_Q \ GROUP\ BY \ a</script><p>类似地，应用$V_i$于参考数据的视图可以表示为$Q_R$。我们称之为参考视图。</p><script type="math/tex; mode=display">Q_R=SELECT\ a,f(m)\ FROM\ D_R\ GROUP\ BY\ a</script><p>对应于每个视图的（两个）SQL查询称为视图查询。上面的视图查询的结果是包含两列的汇总，即$a$和$f(m)$。为了确保所有聚合汇总具有相同的规模，我们将每个汇总归一化为概率分布（即$f(m)$值和为1）。在我们的例子中，平均资本收益与性别的可视化（图1），$V_i(D_Q)$（未婚成年人，数据见表1c）目标视图的概率分布表示为$P[V_i(D_Q)]:(F:0.52,M:0.48)$，而$V_i(D_R)$（已婚成年人，表1c）参考视图的概率分布表示为$P[V_i(D_R)]:(F:0.31,M:0.69)$。相比之下，平均年龄与性别的可视化分布（数据见表1d）为目标视图$(F:0.5,M:0.5)$，参考视图$(F:0.51,M:0.49)$。定性地说，我们看到前者的分布有很大的偏差，而后者几乎没有任何偏差。</p><p>给定聚合视图$V_i$以及目标视图的概率分布$(P[V_i(D_Q)])$和参考视图的概率分布$(P[Vi(DR)])$，我们将$V_i$的效用定义为这两个概率分布之间的距离。两个分布之间的距离越远，可视化就越可能有趣，因此效用也就越高。形式化讲，如果$S$是距离函数，</p><script type="math/tex; mode=display">U(V_i)=S(P[V_i(D_Q)],P[V_i(D_R)])</script><p>计算概率分布之间的距离已经在文献中得到了很好的研究，并且SEEDB支持各种距离函数去计算效用，包括Earth Mover’s Distance, Euclidean Distance, Kullback-Leibler Divergence (K-L divergence), and Jenson-Shannon Distance. SEEDB使用Earth Mover ‘s Distance作为默认的距离函数，我们发现使用其他距离函数可以得到类似的结果[37]。</p><p>我们可以将SEEDB问题正式表述如下：</p><p><em>问题2.1    给定数据库$D$上一个用户指定的查询$Q$，一个参考数据集$D_R$，一个效用函数$U$，和一个正数$k$，需要找到$k$个分类的视图$V\equiv (a,m,f)$，它是所有视图中$U(V)$最大的，同时最小化总计算时间。</em></p><p>在<a href="#7">第7节</a>中，我们将描述如何将我们的度量标准一般化以捕获除偏差之外的与可视化有趣程度有关的因素。</p><h2 id="3-SEEDB前端及架构"><a href="#3-SEEDB前端及架构" class="headerlink" title="3 SEEDB前端及架构"></a><span id="3">3 SEEDB前端及架构</span></h2><p>我们现在描述SEEDB的前端用户体验，然后更详细地描述体系结构和执行引擎。</p><p><strong>前端体验。</strong>SEEDB的可视化推荐功能被打包成端到端的可视化分析环境，带有基本的可视化功能，比如由Tableau提供的功能。SEEDB前端允许分析人员手动生成可视化，或者根据需要获得数据驱动的建议，这些建议可以使用手动界面进一步细化。我们将前端设计成一个混合式驱动界面，以保持人在决策圈内，并允许用户控制分析。图2显示了SEEDB的web前端所包含的四个部分：(A)用于连接数据库的数据集选择器和用于规定查询的查询创建器；(B)用于手动指定可视化的可视化生成器；(C)可视化显示面板；(D)显示推荐的可视化效果的推荐插件。由SEEDB提供的推荐会变化，以响应数据库发出的查询(A)中的变化。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_2.png" alt="Figure 2: SEEDB Frontend"></p><p><strong>架构概述。</strong>SEEDB作为一个中间件层被实现，它可以运行在任何符合sql标准的数据库系统之上。图3描述了系统的总体架构。SEEDB客户端是一个基于web的前端，它捕获用户的输入并渲染呈现由SEEDB服务器产生的可视化结果。SEEDB服务器由两个主要组件组成：视图生成器负责解析输入查询、查询系统元数据和生成必须被评估的可视化查询列表；执行引擎的目标是使用我们在底层DBMS上的优化来评估查询集合。所选中的聚合视图（例如，那些有很大偏差的视图）被发送到SEEDB客户端，并作为可视化建议显示给用户，然后用户可以与这些可视化进行交互。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_3.png" alt="Figure 3: SEEDB Architecture"></p><p><strong>基础执行引擎</strong>。为了激发对优化的需求，我们首先描述执行引擎在没有优化的情况下是如何工作的。为了确定$k$个最佳聚合视图，SEEDB需要做以下工作：对于每个聚合视图，它生成一个对应于目标视图和引用视图的SQL查询，并向底层DBMS发出这两个查询。它对每个聚合视图重复这个过程。当接收到结果时，它计算目标和参考视图分布之间的距离，并识别具有最高效用的$k$可视化结果。这个基础实现有许多低效之处。在一张具有$a$个维度属性、$m$个度量属性和$f$个聚合函数的表上，$2\times f\times a\times m$个查询需要被执行。正如我们在第五节中说明的，对于大的数据集，这需要耗费$&gt;100s$的时间。这种延迟对于交互使用是不可接受的。</p><p><strong>优化执行引擎。</strong>为了减少评估聚合视图集的延迟，SEEDB引擎应用了两种优化：共享，聚合视图查询被组合在一起，以尽可能地共享计算；以及剪枝，在不扫描整个数据集的情况下，将与低效用可视化相对应的聚合视图查询删除。这些优化在很大程度上是相互正交的。为了从这两种优化中获益，我们开发了一个分阶段执行框架。每个阶段对数据集的一个子集进行操作。阶段$n$的第$i$个对数据集的$n$个大小相等的分区中的第$i$个进行操作。例如，假设我们有$100,000$条记录和$10$个阶段，那么阶段$i=4th$就会处理记录$30,001$~$40,000$。执行引擎从在考虑范围内的整个聚合视图集开始。在阶段$i$期间，SEEDB使用数据集的第$i$个部分更新仍在考虑中的视图的部分结果。执行引擎应用基于共享的优化来最小化数据集的第$i$个部分上的扫描代价。在阶段$i$的末尾，执行引擎使用基于剪枝的优化来确定要丢弃哪些聚合视图。从部分1到$i$的每个聚合视图的结果都被用来估计每个视图的质量，而那些效用较低的视图则被丢弃。然后在第$i+1$轮处理保留的聚合视图，并继续这个过程。通过这种方式，在这些阶段中考虑的视图集减小，在第$1$阶段开始时所有的聚合视图，在第$n$阶段结束时只剩下$k$个视图。</p><h2 id="4-SEEDB执行引擎"><a href="#4-SEEDB执行引擎" class="headerlink" title="4 SEEDB执行引擎"></a><span id="4">4 SEEDB执行引擎</span></h2><p>在本节中，我们将描述用于有效生成可视化推荐的共享和修剪优化。我们的扩展技术报告[37]描述了额外的离线预计算和剪枝技术。</p><h3 id="4-1-基于共享的优化"><a href="#4-1-基于共享的优化" class="headerlink" title="4.1 基于共享的优化"></a>4.1 基于共享的优化</h3><p>在执行引擎的基本实现中，每个可视化被转换为在DBMS上独立执行的两个视图查询。然而，对于特定的用户输入，由SEEDB评估的查询非常相似：它们扫描相同的底层数据，不同的只是用于分组和聚合的属性。这为智能地合并和批处理查询提供了机会，从而减少了向数据库发出查询的数量，进而减少了底层数据的扫描次数。我们设置中的共享计算是一般多查询优化问题[33]的一个特例；我们将在<a href="#8">第8节</a>更详细地讨论这种关系。具体来说，我们应用了以下优化：</p><p><strong>合并多个聚合</strong>：具有相同group-by属性的聚合视图查询可以被重写为具有多个聚合的单个查询。因此，对于视图$(a_1,m_1,f_1),(a_1,m_2,f_2)…(a_1,m_k,f_k)$，每个都需要执行两次查询，我们可以将这些视图合并为一个视图$(a,\{m_1,m_2…m_k\},\{f_1,f_2…f_k\})$来代替，总共只需要两次查询。我们发现，合并行和列存储中的聚合对延迟的影响很小，甚至没有影响。</p><p><strong>合并多个group-by</strong>：在应用了我们的多个聚合优化之后，SEEDB剩下了许多具有多个聚合的查询，但只有单属性分组。这些查询可以进一步组合，以利用多属性分组的优势。但是，与合并多个聚合不同，添加分组属性会显著增加必须维护的组的数量，并且(可能)导致大量组的整体性能下降。</p><p>我们声明（并在<a href="#5">第5节</a>中验证），只要保持分组的内存利用率在一个阈值以下，分组就可以提高性能。而内存利用率又与查询中出现的不同组的数量成比例。如果一组属性$a_1…a_m$被用于分组，那么不同组的数量上界由$\prod_{i=1}^m|a_i|$决定。给定一个内存预算$S$，现在的挑战是确定最优的属性分组，使每个组都尊重内存预算。</p><p><em>问题4.1（最优分组）    给定内存预算$S$和一组维度属性$A={a_1…a_n}$，将维度属性A分组为$A_1,…,A_l$(其中$A_i\subseteq A,\bigcup A_i=A$ )，使得查询$Q$根据任意$A_i$对表进行分组，$Q$的内存利用率都不超过$S$。</em></p><p>注意到上述问题与NP-Hard装箱问题[18]同构，如果我们让每个维度属性$a_i$对应于装箱问题中带有重量$\log|a_i|$的一个物品，并且将箱子的大小设置为$\log S$，然后将这些物品装入箱子中，这与寻找组$A_1,…,A_l$是相同的，这样任何组的估计内存利用率都低于$S$。我们使用标准的首次适应算法[14]来寻找维度属性的最优分组。</p><p><strong>合并目标视图和引用视图查询</strong>：因为目标视图和引用视图仅在执行查询的数据子集上不同，所以SEEDB将这两个视图查询重写为一个。例如，假设目标视图为$Q1$，参考视图为$Q2$，它们可以被合并为一个视图$Q3$。</p><script type="math/tex; mode=display">\begin{aligned}Q1&=SELECT \ a,f(m) \ FROM\ D\ WHERE\ x<10\ GROUP\ BY\ a\\Q2&=SELECT \ a,f(m) \ FROM\ D\ GROUP\ BY\ a\\Q3&=SELECT \ a,f(m),CASE\ IF\ x<10\ THEN\ 1\ ELSE\ 0\ END\\&as\ g1,1\ as\ g2\ FROM\ D\ GROUP\ BY\ a,g1,g2\end{aligned}</script><p><strong>并行查询执行</strong>：SEEDB并行执行多个视图查询，因为这些查询通常可以共享缓冲池页面，从而减少磁盘访问时间。然而，精确的并行查询数目需要考虑缓冲池争用、锁定和缓存线争用等因素进行调优。</p><h3 id="4-2-基于剪枝的优化"><a href="#4-2-基于剪枝的优化" class="headerlink" title="4.2 基于剪枝的优化"></a>4.2 基于剪枝的优化</h3><p>实际上，大多数可视化都是低效用的，这意味着计算它们会浪费计算资源。因此，如前所述，在每个阶段的末尾，执行引擎使用剪枝优化来确定要丢弃哪些聚合视图。具体来说，基于到目前为止处理的数据，每个视图的部分结果被用于估计效用，而低效用的视图被删除。SEEDB执行引擎支持两种剪枝方案：第一种使用置信区间技术来绑定视图的效用；第二种使用多臂老虎机分配策略来找到顶级效用视图。</p><p><strong>基于置信区间的剪枝。</strong>我们的第一个剪枝方案使用最坏情况统计置信区间来约束视图效用。这种技术（称为CI）类似于在其他背景中开发的基于top-k的剪枝算法[13,27]。我们的方案如下：在每个阶段，我们对每个聚合视图$V_i$保留一个平均效用的估计值，并在该均值附近设置一个置信区间。在一个阶段结束时，我们使用以下规则来剪枝低效用视图：<em>如果视图$V_i$的效用上界低于$k$个或更多视图的效用下界，则$V_i$被丢弃。</em>举例来说，假设一个数据集有4个视图$V_1…V_4$，我们想要找出排行前二的视图。进一步假设在阶段$i$结束时，$V_1$-$V_4$具有如图4所示的置信区间。到此为止，视图$V_1$和$V_2$的效用估计最高，可能在前二视图中。视图$V_3$目前不在前二中，但它的置信区间与前二重叠，这使得$V_3$有可能取代$V_1$或$V_2$。另一方面，$V_4$的置信区间完全低于$V_1$和$V_2$的置信区间。因为我们很大程度上可以断言$V_4$的效用在它的置信区间内，也就是说，$V_4$的效用很有可能比$V_1$和$V_2$的效用都低，它也不会出现在前二视图中。我们的修剪方案的伪代码可以在我们的技术报告[37]中找到。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_4.png" alt="Figure 4: Confidence Interval based Pruning"></p><p>我们使用从Hoeffding-Serfling不等式[34]得到的最坏情况下的置信区间。这个不等式声明了假设给定$[0,1]$上均值为$\mu$的$N$个值$y_1,…,y_N$，而且有$m$个不需要替代的值$Y_1,…,Y_m$，然后我们可以计算这$m$个值的当前均值附近的运行置信区间，使得$N$的实际均值总是以$1-\delta$的概率在这个置信区间内：</p><p><em>定理4.1    $\forall \delta&gt;0$，对于$1\le m\le N-1$，定义</em></p><script type="math/tex; mode=display">\varepsilon_m=\sqrt{\frac{(1-\frac{m-1}{N})(2\log\log(m)+\log(\pi^2/3\delta))}{2m}}\\then: Pr[\exists m,1\le m\le N: |\frac{\sum_{i=1}^mY_i}{m}-\mu|>\varepsilon_m]\le \delta</script><p>在我们的设置中，每个$Y_i$对应的是根据迄今为止看到的记录计算出的效用估计值。</p><p><strong>基于多臂老虎机的剪枝。</strong>我们的第二个剪枝方案采用了一个多臂老虎机策略[38]。在MAB中，一种在线算法通过一系列的试验从一组可选臂中重复地进行选择来最大化回报。我们注意到，这是老虎机策略第一次被应用于识别有趣的可视化效果的问题。</p><p>最近研究的MAB变体集中于寻找具有最高平均奖励的臂[5,4]。这种变化与SEEDB处理的问题相同：我们的目标是找到可视化（臂）和最高的效用（奖励）。具体来说，我们采用[5]的连续接受和拒绝算法来寻找具有最高平均奖励的臂。在每个阶段结束时，仍在考虑中的视图按其效用平均值排序。然后我们计算出效用平均值之间的两个差异：$\Delta_1$是最高均值和第$k+1$高均值的差值，$\Delta_n$是最低均值和第$k$高均值的差。如果$\Delta_1$比$\Delta_n$大，那么均值最高的视图被”接受”为top-k的一部分（它不再参与剪枝计算）。另一方面，如果$\Delta_n$更大，那么在运行过程中均值最低的视图将从视图集合中被丢弃。伪代码可以在技术报告[37]中找到。[5]证明了在一定的奖励分配假设下，上述技术识别出了高概率的top-k臂。</p><p><strong>一致的距离函数。</strong>注意到上面描述的两个修剪方案在其他设置中都有前提条件，这些条件不会直接转移到我们的设置中。比如，MAB设置假设每个试验的样本来自一个固定的底层分布，而实际上我们的试验对应于$m$个分布（组）中的随机值，它们聚合在一起形成给定视图的效用估计。在我们的评估中，我们发现尽管有这个限制，修剪方案在实践中工作得相当好。</p><p>然而，我们可以得到一个较弱的前提：我们可以证明，当我们采样越来越多时，估计的效用$\hat{U}$可以任意接近于所有聚合视图的$U$。本质上，这意味着使用足够大样本的修剪算法（如CI和MAB）将以高概率删除低效用视图。我们可以这样形式化地表示这个性质。</p><p><em>性质4.1（一致性）    使目标和参考可视化都有$m$个组。$\hat{U}$表示基于$m$组均匀随机样本所估计的效用值$U$。那么随着样本个数趋于$\infty$，$\hat{U}$以$1-\delta$的概率趋于$U$，$\delta$越小越好。</em></p><p>我们称具有这个性质的距离函数为一致距离函数。一致的距离函数允许剪枝方案随着时间的推移收集越来越好的效用值估计（只要样本足够大）。在扩展的技术报告[37]中，我们用Hoeffding不等式证明了这个性质对于欧几里德距离是成立的。我们在5.4节和[37]的结果以经验为主地表明，基于CI和MAB的修剪方案适合各种指标，包括基于EMD的偏差、基于欧氏距离的偏差，以及根据目标分布和参考分布中各自组之间的差异对可视化进行排序的MAX_DIFF指标。</p><h2 id="5-性能评估"><a href="#5-性能评估" class="headerlink" title="5 性能评估"></a><span id="5">5 性能评估</span></h2><p>在接下来的两个部分中，我们将从返回可视化时的性能和用户研究两方面对SEEDB进行评估。在这两部分中，我们报告了在表1中列出的各种真实和合成数据集上的SEEDB结果。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Table_1.png" alt="Table 1: Datasets used for testing"></p><p>在本节中，我们将重点放在性能研究上，我们的目标是评估我们的共享和剪枝优化如何改善延迟，以及我们的剪枝优化如何影响准确性。在每个实验中，我们主要的评估指标是延迟，也就是说，SEEDB返回top-k可视化需要多长时间。对于涉及我们的剪枝策略的实验，我们通过两个额外的度量来衡量结果的质量，即准确性和效用距离（在第5.4节中进一步讨论）。因为我们期望数据布局会影响我们的优化效果，所以我们在面向行数据库（记作ROW）和面向列数据库（记作COL）上评估了我们的技术。</p><p>下面的实验使用EMD距离作为我们计算偏差的距离函数。所有的实验都是在一台8 GB RAM、16核Intel Xeon E5530处理器的机器上运行的。除非另有说明，否则我们报告三次运行的平均测量结果。我们首先总结了实验结果，然后深入研究各个优化的性能结果。</p><h3 id="5-1-结果总结"><a href="#5-1-结果总结" class="headerlink" title="5.1 结果总结"></a>5.1 结果总结</h3><p>图5.a和5.b通过表1中四个真实数据集(BANK、DIAB、AIR和AIR10)显示了SEEDB的表现概况。对于每个数据集，我们将显示在ROW和COL通过基本的SEEDB框架(NO OPT)存储并应用共享优化(SHARING)与剪枝优化(COMB)后的延迟。我们还展示了使用COMB (COMB_EARLY)产生早期结果的延迟，在这里，我们会在确定了top-k的可视化后返回近似结果。图5中的结果使用了置信区间(CI)修剪方案，k=10。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_5.png" alt="Figure 5: Performance gains from all optimizations"></p><ul><li><p>【&gt;100X的总体提速】 我们的共享和修剪优化的结合提供了50X的提速(COMB)</p><p>- 300X用于于ROW (COMB EARLY)(图5a)和10X (COMB)</p><p>- 30X用于COL(COMB EARLY)(图5b)。这将小型数据集(如DIAB)的延迟从12秒缩短到200ms，大型数据集(如AIR10)的延迟从2小时缩短到数十秒。</p></li><li><p>【6-40X的共享提速】 共享优化(章节4.1)单独产生用于ROW的高达40X的性能增益和用于COL的6X提速</p></li><li><p>【5X的不损失精度的剪枝提速】 修剪优化(章节4.2)提供高达5X的额外增益。特别是，早期的结果返回能够实现对大型数据集的实时响应，例如，对于AIR, COMB_EARLY策略能使在处理完整数据集需要数十秒时，SEEDB在不到4s的时间内返回结果。我们还发现，修剪对结果的质量没有负面影响：我们的剪枝策略的效用距离(稍后定义)接近于0。</p></li><li><p>【乘数增益】 用于ROW存储的共享优化带来的40X增益与剪枝优化带来的5X增益相结合可以产生超过200X的总体增益(图5a)。</p></li><li><p>【在更大的数据集上的增益提高】AIR10 (300X)的总体增益要比BANK (10X)大得多。我们发现我们的共享优化最适合于像BANK和DIAB这样的小数据集，而COMB和COMB_EARLY对于像AIR和AIR10这样的大数据集是必不可少的。</p></li></ul><h2 id="6-用户研究"><a href="#6-用户研究" class="headerlink" title="6 用户研究"></a><span id="6">6 用户研究</span></h2><h2 id="7-效用指标-讨论"><a href="#7-效用指标-讨论" class="headerlink" title="7 效用指标: 讨论"></a><span id="7">7 </span>效用指标: 讨论</h2><h2 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a><span id="8">8 相关工作</span></h2><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9 结论"></a>9 结论</h2><h2 id="10-参考文献"><a href="#10-参考文献" class="headerlink" title="10 参考文献"></a>10 参考文献</h2>]]></content>
    
    
    <categories>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Visualization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU机器学习试题回忆</title>
    <link href="/2022/01/15/MLmemory/"/>
    <url>/2022/01/15/MLmemory/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1 线性回归和正则化 (15’)</p></blockquote><p>求线性回归的Hessian矩阵</p><p>证明对于线性回归，使用牛顿法，迭代⼀次即得最优解$\theta^*=(X^TX)^{-1}X^T\vec{y}$</p><p>证明对于正则化的线性回归，使用牛顿法，迭代⼀次即得最优解$\theta^*=(X^TX+\lambda L)^{-1}X^T\vec{y}$</p><blockquote><p>2 朴素贝叶斯的计算 (20’)</p></blockquote><p>计算所有$p(Y),p(x_i|Y)$</p><p>结果为$arg \max_y P(y)\prod P(x_i|y)$</p><blockquote><p>3 Soft-Margin SVM的变体 (30’)</p></blockquote><p>证明约束条件$\xi_i \ge 0$不用显式给出</p><p>写出原问题的KKT条件</p><p>写出原问题的对偶问题</p><blockquote><p>4 EM的变体 将原始M-step改用梯度上升法 (20’)</p></blockquote><p>证明收敛性</p><p>证明正确性即两式求导结果相等</p><blockquote><p>5 论述 (15’)</p></blockquote><p>K-means步骤</p><p>PCA步骤</p><p>Bias, Variance, Complexity关系</p>]]></content>
    
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>MachineLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU计算机图形学复习笔记</title>
    <link href="/2022/01/15/CGreview/"/>
    <url>/2022/01/15/CGreview/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="计算机图形学的主要研究内容是什么？"><a href="#计算机图形学的主要研究内容是什么？" class="headerlink" title="计算机图形学的主要研究内容是什么？"></a>计算机图形学的主要研究内容是什么？</h2><p>计算机中图形的表示方法，以及利用计算机进行图形的计算、处理和显示的相关原理与算法</p><h2 id="列举三个以上图形学的应用领域"><a href="#列举三个以上图形学的应用领域" class="headerlink" title="列举三个以上图形学的应用领域"></a>列举三个以上图形学的应用领域</h2><p>计算机辅助设计与制造（CAD/CAM）</p><p>可视化</p><p>真实感图形实时绘制与自然景物仿真</p><p>计算机动画</p><p>用户接口</p><p>计算机艺术</p><h2 id="一个图形系统通常由哪些图形设备组成？"><a href="#一个图形系统通常由哪些图形设备组成？" class="headerlink" title="一个图形系统通常由哪些图形设备组成？"></a>一个图形系统通常由哪些图形设备组成？</h2><p>图形处理器、图形输入设备和输出设备</p><h2 id="图形和图像的区别是什么？"><a href="#图形和图像的区别是什么？" class="headerlink" title="图形和图像的区别是什么？"></a>图形和图像的区别是什么？</h2><p>图像：计算机内以位图形式存在的灰度信息</p><p>图形：含有几何属性，由场景的几何模型和景物的物理属性共同组成的</p><h2 id="CRT显示器的原理是什么？"><a href="#CRT显示器的原理是什么？" class="headerlink" title="CRT显示器的原理是什么？"></a>CRT显示器的原理是什么？</h2><p>高速的电子束由电子枪发出，经过聚焦系统、加速系统和磁偏转系统就会到达荧光屏的特定位置</p><h2 id="LCD有哪些技术指标？"><a href="#LCD有哪些技术指标？" class="headerlink" title="LCD有哪些技术指标？"></a>LCD有哪些技术指标？</h2><p>可视角度 CR10、CR5</p><p>点距</p><p>分辨率</p><h2 id="有哪些常用的图形输入设备？"><a href="#有哪些常用的图形输入设备？" class="headerlink" title="有哪些常用的图形输入设备？"></a>有哪些常用的图形输入设备？</h2><p>键盘、鼠标</p><p>跟踪球、空间球、数据手套、光笔、触摸屏</p><h2 id="图形学之父"><a href="#图形学之父" class="headerlink" title="图形学之父"></a>图形学之父</h2><p>Ivan E. Sutherland</p><h2 id="ACM-Siggraph最高奖以谁的名字命名"><a href="#ACM-Siggraph最高奖以谁的名字命名" class="headerlink" title="ACM Siggraph最高奖以谁的名字命名"></a>ACM Siggraph最高奖以谁的名字命名</h2><p>Steven A. Coons</p><h1 id="第二章-光栅图形学"><a href="#第二章-光栅图形学" class="headerlink" title="第二章 光栅图形学"></a>第二章 光栅图形学</h1><h2 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h2><h3 id="数值微分法（DDA）"><a href="#数值微分法（DDA）" class="headerlink" title="数值微分法（DDA）"></a>数值微分法（DDA）</h3><p>增量思想：对于直线y=kx+b，x每递增1，y则递增k</p><p>在该算法中，y和k都要用浮点数表示，且每一步都需要对y四舍五入取整，不适合硬件实现</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDALine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br>     <span class="hljs-keyword">float</span> dx, dy, y, k;<br>    dx = x1-x0;<br>    dy = y1-y0;<br>    k = dy/dx;<br>    y = y0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=x0; x&lt;=x1; x++)&#123;<br>        drawpixel(x, <span class="hljs-keyword">int</span>(y+<span class="hljs-number">0.5</span>));<br>        y += k;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h3><p>采用了直线的一般形式：F(x,y)=Ax+By+C=0，其中A=-dy，B=dx</p><p>画直线段过程中当前像素点为(x0,y0)，下一个像素点有两种选择P1(x0+1,y0), P2(x0+1,y0+1)，设M(x0+1,y0+0.5)是P1P2中点，Q为理想直线与x=x0+1的交点，当M在Q下方时F(M)<0，下一个像素点为P2，当M在Q上方时F(M)>0，下一个像素点为P1</0，下一个像素点为P2，当M在Q上方时F(M)></p><p>采用增量计算，令d=F(M)=a+0.5b，取正右方P1后判断下一个像素时d1=d+a，取右上方P2后判断下一个像素时d2=d+a+b</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MidpointLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, d1, d2, d, x, y;<br>    a = y0-y1;<br>    b = x1-x0;<br>    d = <span class="hljs-number">2</span>*a+b;<br>    d1 = <span class="hljs-number">2</span>*a;<br>    d2 = <span class="hljs-number">2</span>*(a+b);<br>    x = x0, y = y0;<br>    <span class="hljs-keyword">while</span>(x&lt;x1)&#123;<br>        <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">0</span>)&#123;<br>            x++;<br>            y++;<br>            d += d2;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            x++;<br>            d += d1;<br>        &#125;<br>        drawpixel(x, y);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h3><p>过各行各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序计算直线与各垂直网格线的交点，根据误差项的符号确定该列像素中与此交点最近的像素</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IntegerBresenhamLine</span><span class="hljs-params">(x0, y0, x1, y1)</span></span>&#123;<br>    x = x0;<br>    y = y0;<br>    dx = x1-x0;<br>    dy = y1-y0;<br>    e = -dx;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=dx; i++)&#123;<br>        drawpixel(x, y);<br>        x++;<br>        e += <span class="hljs-number">2</span>*dy;<br>        <span class="hljs-keyword">if</span>(e&gt;=<span class="hljs-number">0</span>)&#123;<br>            y++;<br>            e -= <span class="hljs-number">2</span>*dx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="多边形的扫描转换"><a href="#多边形的扫描转换" class="headerlink" title="多边形的扫描转换"></a>多边形的扫描转换</h2><blockquote><p>多边形有两种重要的表示方法：顶点表示和点阵表示</p><p>多边形的顶点表示转换为点阵表示，这种转换称为多边形的扫描转换</p></blockquote><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，以完成填充工作</p><p>对于一条扫描线，多边形的扫描步骤为：</p><ol><li>求交。计算扫描线与多边形各边的交点</li><li>排序。把所有交点按照x值递增顺序排序</li><li>配对。将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间</li><li>填色。把相交区间内的像素置成多边形的颜色，把相交区间外的像素置成背景色</li></ol><p>涉及的数据结构：</p><ul><li><p>活性边表AET：为提高效率，在处理一条扫描线时仅对与它相交的多边形的边进行求交运算，与当前扫描线相交的边称为活性边，把活性边按与扫描线交点x坐标递增的顺序存放在一个链表中，该链表为AET</p><p>结点内容：</p><ol><li><p>当前扫描线与边的交点坐标x值</p></li><li><p>从当前扫描线到下一条扫描线间x的增量$\Delta x$</p></li><li><p>该边所交的最高扫描线号$y_{max}$</p></li></ol></li><li><p>新边表NET：为方便AET的建立与更新，为每一条扫描线建立一个NET，存放在该扫描线第一次出现的边</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scanLinePolyFill</span><span class="hljs-params">(polygon)</span></span>&#123;<br>    <span class="hljs-comment">//初始化新边表NET</span><br>    <span class="hljs-keyword">for</span>(各条扫描线i)&#123;<br>        初始化NET[i]头指针;<br>        把ymin=i的边放入NET[i]中;<br>    &#125;<br>    <span class="hljs-comment">//扫描准备</span><br>    初始化AET为空;<br>    y=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始扫描</span><br>    <span class="hljs-keyword">for</span>(各条扫描线i)&#123;<br>        <span class="hljs-comment">//加入边</span><br>        将NET[i]中的边插入排序到AET中;<br>        若要自交,则对AET冒泡排序;<br>        <span class="hljs-comment">//区间填色</span><br>        遍历AET，配对交点区间，对区间上的点改写像素值;<br>        <span class="hljs-comment">//删除边 </span><br>        删除ymax=i的边;<br>        <span class="hljs-comment">//更新AET</span><br>        将AET中结点的x值递增dx;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="边界标志算法"><a href="#边界标志算法" class="headerlink" title="边界标志算法"></a>边界标志算法</h3><p>帧缓冲器对多边形进行直线扫描转换时在边界像素打上标志，再采用和扫描线算法类似的方法将位于多边形的各个区间填色。适合硬件实现</p><h2 id="多边形的区域填充"><a href="#多边形的区域填充" class="headerlink" title="多边形的区域填充"></a>多边形的区域填充</h2><blockquote><p>这里的区域是指已经表示成点阵形式的填充图形，它是像素的集合</p><p>区域可采用内点表示和边界表示</p><p>区域可分为四连通区域和八连通区域（容易穿出脆弱边界）</p></blockquote><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>假设在多边形内有一个像素已知，由此出发利用连通性找到区域内的所有像素</p><h3 id="扫描线算法-1"><a href="#扫描线算法-1" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>给定种子点时，首先填充种子点所在扫描线上位于给定区域的一个区间，然后确定与这一区间相连通的上下两条扫描线上位于给定区域内的区间，并依次保存下来，反复这个过程直到填充结束</p><p>区域填充的扫描线算法步骤：</p><ol><li>初始化。堆栈置空，将种子点(x,y)入栈</li><li>出栈。若栈空则结束；否则取栈顶元素(x,y)，以y作为当前扫描线</li><li>填充并确定种子点所在区段。从种子点(x,y)出发，沿当前扫描线向左、右两个方向填充，直到边界。分别标记区段的左右端点坐标为xl和xr</li><li>确定新的种子点。在区间[xl,xr]中检查与当前扫描线y上下相邻的两条扫描线上的像素。若存在非边界、未填充的像素，则把每一区间的最右像素作为种子点压入堆栈，返回第2步</li></ol><h2 id="直线段裁剪"><a href="#直线段裁剪" class="headerlink" title="直线段裁剪"></a>直线段裁剪</h2><h3 id="Cohen-Sutherland法"><a href="#Cohen-Sutherland法" class="headerlink" title="Cohen-Sutherland法"></a>Cohen-Sutherland法</h3><p>对线段端点进行编码<code>code1</code> <code>code2</code>，判断直线段与窗口的关系，分为三种情况：</p><ol><li><p>全在窗口内，显示该线段；<code>code1 | code2 == 0</code></p></li><li><p>完全不在窗口内，丢弃该线段；<code>code1 &amp; code2 != 0</code></p></li><li><p>线段与窗口有交，求出该交点，把线段一分为二，丢弃在窗口外的一段，对另一端重复上述处理</p></li></ol><h3 id="中点分割法"><a href="#中点分割法" class="headerlink" title="中点分割法"></a>中点分割法</h3><p>首先对线段端点进行编码，并把线段与窗口的关系分为三种情况：</p><ol><li>全在窗口内，显示该线段</li><li>完全不在窗口内，丢弃该线段</li><li>线段与窗口有交，用<strong>中点分割</strong>的方法求出线段与窗口的交点</li></ol><p>改进之处：不用解方程组求交，而是采用二分法求交</p><p>改进理由：主要计算过程只用到加法和除2运算，适合硬件实现和并行计算</p><h3 id="梁友栋-Barskey裁剪算法"><a href="#梁友栋-Barskey裁剪算法" class="headerlink" title="梁友栋-Barskey裁剪算法"></a>梁友栋-Barskey裁剪算法</h3><p>参数化裁剪条件：</p><script type="math/tex; mode=display">\begin{cases}XL \le x_1+u\Delta x\le XR\\YB \le y_1+u\Delta y\le YT\end{cases}</script><p>可以表示为统一形式：$up_k\le q_k$</p><ul><li><p>$p_k=0$，直线段平行于裁剪边界之一</p><ul><li>$q_k&lt;0$，则线段完全在边界外，舍弃该线段</li><li>$q_k\ge0$，则该线段平行于裁剪边界并且在窗口内</li></ul></li><li><p>$p_k&lt;0$，线段从裁剪边界所在直线的外部指向内部</p><p>计算线段与边界k的延长线的交点u值$r_k=q_k/p_k$，$u_1=max\{0,r_k\}$</p></li><li><p>$p_k&gt;0$，线段从裁剪边界所在直线的内部指向外部</p><p>计算线段与边界k的延长线的交点u值$r_k=q_k/p_k$，$u_2=min\{1,r_k\}$</p></li></ul><p>如果$u_1&gt;u_2$则线段完全落在裁剪窗口之外被舍弃；否则裁剪线段由参数$u_1,u_2$计算出来，它们定义了在裁剪矩形内的线段部分</p><p>它比前两种方法快，因为线段与窗口边界的交点仅需计算一次，且更新参数$u1,u2$仅需要一次除法</p><h2 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h2><h3 id="Sutherland-Hodgman算法"><a href="#Sutherland-Hodgman算法" class="headerlink" title="Sutherland-Hodgman算法"></a>Sutherland-Hodgman算法</h3><p>一次用窗口的一条边裁剪多边形，得到一个顶点序列，作为下一条裁剪边处理过程的输入</p><p>每条线段端点S,P与裁剪线的位置关系有如下4种，红色标注点为输出的点：</p><p><img src="/2022/01/15/CGreview/image-1.png" alt></p><p>算法优点：裁剪窗口可以是任意凸多边形</p><p>算法不足：只能裁剪凸多边形；裁剪窗口不能是凹多边形</p><p>算法改进：可以将凹多边形分割成多个凸多边形再去运行该算法</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><h3 id="字库的分类"><a href="#字库的分类" class="headerlink" title="字库的分类"></a>字库的分类</h3><p>点阵型：存储空间大、易于显示</p><p>矢量型：存储空间小、美观、变换方便</p><h3 id="字符裁剪"><a href="#字符裁剪" class="headerlink" title="字符裁剪"></a>字符裁剪</h3><p>串精度</p><p>字符精度</p><p>笔画或像素精度</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>走样aliasing：用离散量表示连续量引起的失真现象</p><p>反走样antialiasing：用于减少或消除这种效果的技术</p><h3 id="提高分辨率"><a href="#提高分辨率" class="headerlink" title="提高分辨率"></a>提高分辨率</h3><p>把显示器分辨率提高一倍，直线经过两倍像素，锯齿增加一倍，但同时每个阶梯也减少了一倍，显示的直线段看起来平直光滑。方法简单，但不经济，只能减轻而不能消除锯齿问题</p><h3 id="非加权区域采样"><a href="#非加权区域采样" class="headerlink" title="非加权区域采样"></a>非加权区域采样</h3><p>假定每个像素是具有一定面积的小区域，直线段是具有一定宽度的狭长矩形，当直线段与像素有交时，求出两者相交区域的面积，然后根据相交区域面积的大小确定该像素的亮度值</p><p>两个缺点：</p><ul><li>像素的亮度与相交区域的面积成正比，而与相交区域落在像素内的位置无关，这仍然会导致锯齿效应</li><li>直线条上沿理想直线方向的相邻两个像素有时会有较大的灰度差</li></ul><h3 id="加权区域采样"><a href="#加权区域采样" class="headerlink" title="加权区域采样"></a>加权区域采样</h3><p>使相交区域对像素亮度的贡献依赖于该区域与像素中心的距离</p><h2 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h2><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><p>先把屏幕置成背景色，再把物体各个面按离视点的远近进行排序，结果存放在深度优先级表中，按照由远到近的顺序绘制各个面</p><p>优点：原理简单</p><p>缺点：只能处理互不相交的面，而且深度优先级表中面的顺序可能出错，深度排序计算量大</p><h3 id="Z-Buffer算法"><a href="#Z-Buffer算法" class="headerlink" title="Z-Buffer算法"></a>Z-Buffer算法</h3><p>设置帧缓存存放每个像素的颜色值，深度缓存来存放每个像素的深度值。把显示对象的每个面上每一点的属性值填入帧缓冲区相应单元前，要把这点的z坐标值与Z缓冲器中相应单元的值进行比较，只有前者大于后者时才改变帧缓冲区该单元的值，同时Z缓冲器相应单元的值更新</p><p>优点：比总体排序灵活简单，有利于硬件实现</p><p>缺点：占用空间大，没有利用图形的相关性与连续性</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>    帧缓存全置为背景色;<br>    深度缓存全置为最小Z值;<br>    <span class="hljs-keyword">for</span>(每一个多边形)&#123;<br>        扫描转换该多边形;<br>        <span class="hljs-keyword">for</span>(该多边形覆盖的每个像素(x,y))&#123;<br>            计算该多边形在该像素的深度值Z(x,y);<br>            <span class="hljs-keyword">if</span>(Z(x,y)大于Z缓存在(x,y)的值)&#123;<br>                把Z(x,y)存入Z缓存中(x,y)处;<br>                把多边形在(x,y)处的颜色值存入帧缓存的(x,y)处;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="改进的Z-Buffer算法"><a href="#改进的Z-Buffer算法" class="headerlink" title="改进的Z-Buffer算法"></a>改进的Z-Buffer算法</h3><p>用一个深度缓存变量zb代替缓存数组。对屏幕上的每个像素，对于每个多边形，若该像素在该多边形内，则计算该多边形在该像素的深度值，找出对应最大深度值的多边形，更新像素属性值</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>    帧缓存全置为背景色;<br>    <span class="hljs-keyword">for</span>(屏幕上的每一个像素(x,y))&#123;<br>        深度缓存变量zb置最小值MinValue;<br>        <span class="hljs-keyword">for</span>(每个多边形P)&#123;<br>            <span class="hljs-keyword">if</span>(像素(x,y)在该多边形P_k内)&#123;<br>                计算该多边形在该像素的深度值depth;<br>                <span class="hljs-keyword">if</span>(depth&gt;zb)&#123;<br>                    zb=depth;<br>                    index=k;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(zb!=MinValue)<br>            计算多边形P_index在像素(x,y)的光照颜色并显示;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第6行的包含性检测可采用射线法或弧长法</p><h3 id="扫描线Z-Buffer算法"><a href="#扫描线Z-Buffer算法" class="headerlink" title="扫描线Z-Buffer算法"></a>扫描线Z-Buffer算法</h3><p>在处理当前扫描线时，开一个一维数组作为当前扫描线的Z-Buffer。首先找出与当前扫描线相关的多边形，以及每个多边形中相关的边对；然后计算边对之间区间上各像素的深度，与Z-Buffer中的值相比较，找出各像素处对应的可见平面，计算颜色，写帧缓存。对深度计算采用增量算法。</p><p>优点：将整个绘图窗口内的消隐问题分解到扫描线上解决，使所需的Z缓冲器大大减小；计算深度时利用了面的连贯性，只用了一个加法</p><p>缺点：被多个多边形覆盖的像素还要进行多次计算，计算量仍然很大</p><p>数据结构：</p><ul><li>多边形Y表：保存所有多边形的序号和其顶点最大y坐标，根据多边形顶点最小y坐标插入到Y表相应位置</li><li>活化多边形表APT：保存与当前扫描线相交的多边形</li><li>边表ET：每个APT中的多边形都有一个边表，存放每条边端点中较大的y值，增量$\Delta x$，y值较小一端的x坐标和z坐标</li><li>活化边对表AET：存放当前多边形中与当前扫描线相交的各边对的信息</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>    建立多边形Y表;<br>    初始化活化多边形表APT，活化边对表AET为空;<br>    <span class="hljs-keyword">for</span>(每条扫描线i)&#123;<br>        帧缓存CB置为背景色;<br>        深度缓存ZB置为负无穷;<br>        将对应扫描线i的Y表中的多边形加入APT中;<br>        生成新加入多边形的边表ET;<br>        对APT中每一个多边形，若其边表ET中对应扫描线i增加了新边，则将新边配对，加入AET中;<br>        对AET中每一个边对:<br>            对xl&lt;j&lt;xr的每一个像素，按增量公式z=z+dz_a计算各点深度depth;<br>            若depth&gt;ZB(j)则令ZB(j)=depth，并计算颜色值写帧缓存;<br>        删除APT中多边形顶点最大y坐标为i的多边形，并删除相应的边;<br>        对AET中每一个边对:<br>            删除y_lmax或y_rmax等于i的边，若一边对中只删除了一边则对该多边形的边重新配对;<br>            用增量公式计算新的x_l,x_r,z_l=z_l+dx_l*dz_a+dz_b;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h3><p>把当前扫描线各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间，只要在区间任一点处找出在该处z值最大的一个面，这个区间上的每一个像素就用这个面的颜色来表示</p><p>优点：在一条扫描线上每个区间只计算一次深度值，并且不需要Z缓冲器</p><h3 id="区域子分割算法（Warnack算法）"><a href="#区域子分割算法（Warnack算法）" class="headerlink" title="区域子分割算法（Warnack算法）"></a>区域子分割算法（Warnack算法）</h3><p>把物体投影到全屏幕窗口上，然后递归分割窗口，直到窗口内目标足够简单，可以显示为止</p><p>如果窗口内没有物体，则按背景色显示；如果窗口内只有一个面，则把该面显示出来；如果窗口内含有两个以上的面，则把窗口等分成4个子窗口，对每个小窗口作上述同样的处理</p><p>窗口与多边形的覆盖关系有4种：内含，相交，包围，分离</p><h3 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h3><p>考查由视点出发穿过观察屏幕的一个像素而射入场景的一条射线，则可确定出场景中与该射线相交的物体。在计算出光线与物体表面的交点后，离像素最近的交点所在面片的颜色为该像素的颜色；如果没有交点，说明没有多边形的投影覆盖此像素，用背景色显示。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(屏幕上的每一像素)&#123;<br>    形成通过该屏幕像素的射线;<br>    <span class="hljs-keyword">for</span>(场景中的每一物体)<br>        将该射线于物体求交;<br>    <span class="hljs-keyword">if</span>(存在交点)<br>        以最近的交点所属的颜色显示像素;<br>    <span class="hljs-keyword">else</span><br>        以背景色显示像素;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-几何造型技术"><a href="#第三章-几何造型技术" class="headerlink" title="第三章 几何造型技术"></a>第三章 几何造型技术</h1><h2 id="曲线的基本概念"><a href="#曲线的基本概念" class="headerlink" title="曲线的基本概念"></a>曲线的基本概念</h2><p>位置矢量</p><p>切矢量</p><p>法矢量</p><p>曲率：弯曲程度，曲线的单位切矢对弧长的转动率</p><p>挠率：扭曲程度，副法线方向对于弧长的转动率</p><h2 id="三次Hermite曲线"><a href="#三次Hermite曲线" class="headerlink" title="三次Hermite曲线"></a>三次Hermite曲线</h2><p>三次曲线的代数形式：$P(t)=a_3t^3+a_2t^2+a_1t+a_0, t\in[0,1]$</p><p>三次曲线的几何形式：用端点位矢$P_0,P_1$，切矢$P’_0,P’_1$表示</p><p>代入<strong>推导(……)</strong>，几何系数是$P_0,P_1,P’_0,P’_1$，调和函数是$F_0, F_1, G_0, G_1$</p><script type="math/tex; mode=display">P(t)=F_0P_0+F_1P_1+G_0P'_0+G_1P'_1, t\in[0,1]</script><p>矩阵化表达</p><script type="math/tex; mode=display">P(t)=\left( \begin{matrix}P_0 & P_1 & P'_0 & P'_1\end{matrix}\right)\left( \begin{matrix}F_0 \\ F_1 \\ G_0 \\ G_1\end{matrix}\right)=\left( \begin{matrix}P_0 & P_1 & P'_0 & P'_1\end{matrix}\right)\left( \begin{matrix}2 & -3 & 0 & 1\\-2 & 3 & 0 & 0\\1 & -2 & 1 & 0\\1 & -1 & 0 & 0\\\end{matrix}\right)\left( \begin{matrix}t^3 \\ t^2 \\ t \\ 1\end{matrix}\right)\\</script><h2 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h2><script type="math/tex; mode=display">P(t)=\sum_{i=0}^nP_iC_n^it^i(1-t)^{n-i},t\in[0,1]</script><p>性质：</p><ul><li><p>端点性质</p><ul><li><p>起点终点与对应的特征多边形的起点终点重合</p></li><li><p>端点切向量$P’(t)=n\sum_{i=1}^{n-1}P_i[B_{i-1,n-1}(t)-B_{i,n-1}(t)]$</p><p>起点终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致</p></li></ul></li><li><p>对称性：曲线的起点终点处几何性质一样</p></li><li><p>凸包性：曲线落在$P_i$构成的凸包之中</p></li><li><p>几何不变性：曲线的位置和形状不依赖坐标系的选择</p></li><li><p>变差缩减性：平面内任意直线与$P(t)$的交点个数不多于该直线与其特征多边形的交点个数，反映了bezier曲线比特征多边形的折线更光顺</p></li><li><p>仿射不变性：在仿射变换下，$P(t)$的形式不变</p></li></ul><p>de Casteljau算法：</p><script type="math/tex; mode=display">P_i^k=\begin{cases}P_i,&k=0\\(1-t)P_i^{k-1}+tP_{i+1}^{k-1},&k=1,2,...,n,i=0,1,...,n-k\end{cases}</script><p>升阶：保持Bezier曲线的形状与定向不变，增加定义它的控制顶点数</p><script type="math/tex; mode=display">P_i^*=\frac{i}{n+1}P_{i-1}+(1-\frac{i}{n+1})P_i\\i=0,1,...,n+1</script><p>不足：</p><ul><li>Bezier曲线不能做局部修改</li><li>Bezier曲线的拼接比较复杂</li></ul><blockquote><p>例题1：计算以(30,0) (60,10) (80,30) (90,60) (90,90)为控制顶点的四次Bezier 曲线在$t=\frac{1}{2}$处的值，并画出de Casteljau三角形。</p><p><img src="/2022/01/15/CGreview/image-20211230111522197.png" alt></p><p>例题2：给定型值点(0,0) (0,100) (100,0) (100,100)，如对应的参数为$0,\frac{1}{3},\frac{2}{3},1$，反求插值这四个型值点的三次Bezier曲线的控制点。</p><p><img src="/2022/01/15/CGreview/image-20211230112257196.png" alt></p></blockquote><h2 id="B样条"><a href="#B样条" class="headerlink" title="B样条"></a>B样条</h2><p>k阶（k-1次）B样条曲线的定义为：</p><script type="math/tex; mode=display">P(t)=\sum_{i=0}^n P_iN_{i,k}(t) \\t\in[t_{k-1},t_{n+1}]</script><p>de Boor算法：</p><p>给定控制顶点$P_i(i=0,1,…,n)$和节点矢量$T=[t_0,t_1,…,t_{n+k}]$，定义k阶（k-1次）B样条曲线</p><script type="math/tex; mode=display">t\in[t_j,t_{j+1}](k-1\le j\le n)\\P_i^r(t)=\begin{cases}P_i,&r=0;\\&i=j-k+1,j-k+2,...,j\\\frac{t-t_i}{t_{i+k-r}-t_i}P_i^{r-1}(t)+\frac{t_{i+k-r}-t}{t_{i+k-r}-t_i}P_{i-1}^{r-1}(t),&r=1,2,..,k-1;\\&i=j-k+r+1,j-k+r+2,...,j\end{cases}\\P(t)=P_j^{k-1}(t)</script><p>三次B样条的Bezier表示：</p><p>在区间$[t_j,t_{j+1}]$上的B样条曲线，如表示成三次Bezier曲线，则控制顶点为：</p><script type="math/tex; mode=display">P_{j-1}^{[2]}(t_j),P_{j-1}^{[1]}(t_j),P_{j-1}^{[1]}(t_{j+1}),P_{j}^{[2]}(t_{j+1})</script><script type="math/tex; mode=display">P(t)=\sum_{i=j-3}^j P_iN_{i,4}(t)\\=P_{j-1}^{[2]}(t_j)B_{0,3}(\frac{t-t_j}{\Delta t_j})+P_{j-1}^{[1]}(t_j)B_{1,3}(\frac{t-t_j}{\Delta t_j})+P_{j-1}^{[1]}(t_{j+1})B_{2,3}(\frac{t-t_j}{\Delta t_j})+P_{j}^{[2]}(t_{j+1})B_{3,3}(\frac{t-t_j}{\Delta t_j})</script><h2 id="三角网格"><a href="#三角网格" class="headerlink" title="三角网格"></a>三角网格</h2><h3 id="半边表示"><a href="#半边表示" class="headerlink" title="半边表示"></a>半边表示</h3><p>把一条无向的边拆分成两条有向的半边，半边的方向在模型中总是沿着逆时针方向</p><p>每条半边需要存储的信息：</p><ul><li>该半边的源顶点<code>origin(e)</code></li><li>该半边在同一三角形中的下一半边<code>next(e)</code></li><li>与该半边同属一条边的对边<code>opposite(e)</code></li><li>该半边所属的面<code>IncFace(e)</code></li></ul><h3 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h3><p>三种基本化简操作：顶点删除、边压缩、面片收缩</p><h3 id="网格细分"><a href="#网格细分" class="headerlink" title="网格细分"></a>网格细分</h3><p>Loop细分方法：第一步增加顶点，第二步调整顶点位置使网格更加平滑</p><h1 id="第四章-真实感图形学"><a href="#第四章-真实感图形学" class="headerlink" title="第四章 真实感图形学"></a>第四章 真实感图形学</h1><h2 id="颜色的特性"><a href="#颜色的特性" class="headerlink" title="颜色的特性"></a>颜色的特性</h2><p>心理学和视觉的角度：色调(hue)、饱和度(saturation)、亮度(lightness)</p><p>光学物理学的角度：主波长、纯度、明度</p><h2 id="三色学说"><a href="#三色学说" class="headerlink" title="三色学说"></a>三色学说</h2><p>是真实感图形学的生理视觉基础，是颜色视觉中最基础、最根本的理论</p><h2 id="CIE色度图"><a href="#CIE色度图" class="headerlink" title="CIE色度图"></a>CIE色度图</h2><p>马蹄形区域</p><h2 id="常见的颜色模型"><a href="#常见的颜色模型" class="headerlink" title="常见的颜色模型"></a>常见的颜色模型</h2><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>用于彩色光栅图形显示设备，采用红、绿、蓝为原色，面向硬件</p><p>三维直角坐标系，单位立方体来表示，原点为黑色，从黑色中加入某种颜色</p><h3 id="CMY"><a href="#CMY" class="headerlink" title="CMY"></a>CMY</h3><p>用于印刷行业，采用青(Cyan)、品红(Magenta)、黄(Yellow)为原色，面向硬件</p><p>减性原色系统，单位立方体，原点为白色，在白色中减去某种颜色</p><h3 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h3><p>面向用户，对应于画家的配色方法，圆锥形</p><h2 id="写出Phong模型公式，并指出其中各个参数的含义"><a href="#写出Phong模型公式，并指出其中各个参数的含义" class="headerlink" title="写出Phong模型公式，并指出其中各个参数的含义"></a>写出Phong模型公式，并指出其中各个参数的含义</h2><p>环境光ambient + 漫反射光diffuse + 镜面反射光specular</p><p><img src="/2022/01/15/CGreview/image-2.png" alt></p><script type="math/tex; mode=display">I=I_aK_a+I_pK_d(L\cdot N)+I_pK_s(R\cdot V)^n\\R=2N(L\cdot N)-L</script><p>$I_a$——环境光强度</p><p>$K_a$——物体对环境光的反射系数</p><p>$I_p$——入射光强度</p><p>$K_d$——物体的漫反射系数</p><p>$L$——光源方向单位向量</p><p>$N$——物体法向量</p><p>$K_s$——物体的镜面反射系数</p><p>$R$——反射方向单位向量</p><p>$V$——视线方向单位向量</p><p>$n$——镜面反射指数</p><h2 id="Gouraud明暗处理"><a href="#Gouraud明暗处理" class="headerlink" title="Gouraud明暗处理"></a>Gouraud明暗处理</h2><ol><li>计算多边形顶点的平均法向 相邻多边形的平均法向</li><li>用Phong光照明模型计算顶点的平均光强</li><li>插值计算离散边上的各点光强</li><li>插值计算多边形内域中各点的光强</li></ol><p>优点：能有效地显示漫反射效果，计算量小</p><p>缺点：镜面发射效果不理想，相邻多边形边界处的马赫带效应不能完全消除</p><h2 id="Phong明暗处理"><a href="#Phong明暗处理" class="headerlink" title="Phong明暗处理"></a>Phong明暗处理</h2><ol><li>计算多边形顶点的平均法向</li><li>插值计算离散边上的各点法向</li><li>插值计算多边形内域中各点的法向</li><li>用Phong光照明模型计算各点的光强</li></ol><p>优点：可以产生正确的高光区域</p><p>缺点：计算量大</p><h2 id="针对多面体模型，直接用Phong模型绘制会有什么问题？"><a href="#针对多面体模型，直接用Phong模型绘制会有什么问题？" class="headerlink" title="针对多面体模型，直接用Phong模型绘制会有什么问题？"></a>针对多面体模型，直接用Phong模型绘制会有什么问题？</h2><p>由于光源和视点都被假定为无穷远，且每一个多边形由于法向一致，所以多边形内部像素的颜色都是相同的，因此在不同法向的多边形邻接处不仅有光强突变还会产生马赫带效应</p><h2 id="两种增量式光照明模型的基本思想及算法区别"><a href="#两种增量式光照明模型的基本思想及算法区别" class="headerlink" title="两种增量式光照明模型的基本思想及算法区别"></a>两种增量式光照明模型的基本思想及算法区别</h2><p>在每一个多边形的顶点处计算合适的光照明强度或其他参数，然后在各个多边形内部进行均匀插值，最后得到多边形的光滑颜色分布</p><p>Gouraud明暗处理采用光强插值，Phong明暗处理采用法向插值</p><h2 id="局部光照明模型"><a href="#局部光照明模型" class="headerlink" title="局部光照明模型"></a>局部光照明模型</h2><script type="math/tex; mode=display">I_r=I_aK_a+I_i(N\cdot L)d\omega (K_dR_d+K_sR_s)</script><p>与简单光照模型比较的优点：</p><ol><li>是基于入射光能量导出的光辐射模型，更具有理论基础</li><li>可以反映表面的粗糙度对反射光强的影响</li><li>可以根据材料的物理性质决定颜色</li><li>可以改进简单光照模型的失真现象</li><li>可以模拟金属的光泽</li></ol><h2 id="整体光照明模型—光线跟踪算法"><a href="#整体光照明模型—光线跟踪算法" class="headerlink" title="整体光照明模型—光线跟踪算法"></a>整体光照明模型—光线跟踪算法</h2><p>终止条件：</p><ul><li>该光线未碰到任何物体</li><li>该光线碰到了背景</li><li>光线在经过多次反射和折射后衰减，光线对于视点的光强贡献很小</li><li>光线反射或折射次数大于给定值</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">RayTracing(start, direction, weight, color)&#123;<br>    <span class="hljs-comment">//光线起点start 光线方向direction 光线衰减权值weight 返回光线方向上的颜色值color</span><br>    <span class="hljs-keyword">if</span>(weight &lt; MinWeight)<br>        color = black;<br>    <span class="hljs-keyword">else</span>&#123;<br>        计算光线与所有物体的交点中离start最近的点;<br>        <span class="hljs-keyword">if</span>(没有交点)<br>            color = black;<br>        <span class="hljs-keyword">else</span>&#123;<br>            I_local = 在交点处用局部光照模型计算出的光强;<br>            计算反射方向R = <span class="hljs-number">2</span>N(L*N)-L;<br>            RayTracing(最近的交点, R, weight*w_r, I_r);<br>            计算折射方向T;<br>            RayTracing(最近的交点, T, weight*<span class="hljs-keyword">w_t</span>, I_t);<br>            color = I_local + K_sI_r + K_tI_t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>加速方法：自适应深度控制；包围盒及层次结构；三维DDA算法；空间八叉树剖分技术</p><h2 id="包围盒"><a href="#包围盒" class="headerlink" title="包围盒"></a>包围盒</h2><p>基本思想：用体积稍大且特性简单的集合体来近似代替复杂的几何对象</p><h3 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h3><p>包含该对象，且边平行于坐标轴的最小六面体。六个标量即可表示$(x_{min},y_{min},z_{min})(x_{max},y_{max},z_{max})$。</p><p>不随物体旋转，紧密性差。</p><h3 id="OBB"><a href="#OBB" class="headerlink" title="OBB"></a>OBB</h3><p>包围盒无需和坐标轴垂直，根据物体表面的顶点，通过PCA获得特征向量，即OBB的主轴。具有方向性，可以旋转。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="二维图形的几何变换"><a href="#二维图形的几何变换" class="headerlink" title="二维图形的几何变换"></a>二维图形的几何变换</h2><p>平移变换</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & t_x\\0 & 1 & t_y\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\1\end{matrix}\right]</script><p>旋转变换（逆时针）</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & -\sin\theta & 0\\\sin\theta & \cos\theta & 0\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\1\end{matrix}\right]</script><p>关于$(x_f,y_f)$点的旋转变换：需要先将该点移到坐标原点处，然后再进行旋转变换，最后将该点移回原来的位置</p><script type="math/tex; mode=display">T(x_f,y_f)\cdot R(\theta)\cdot T(-x_f,-y_f)=\left[ \begin{matrix}1 & 0 & x_f\\0 & 1 & y_f\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}\cos\theta & -\sin\theta & 0\\\sin\theta & \cos\theta & 0\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}1 & 0 & -x_f\\0 & 1 & -y_f\\0 & 0 & 1\\\end{matrix}\right]</script><h2 id="三维图形的几何变换"><a href="#三维图形的几何变换" class="headerlink" title="三维图形的几何变换"></a>三维图形的几何变换</h2><p>绕x轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & 0 & 0\\0 & \cos\theta & -\sin\theta & 0\\0 & \sin\theta & \cos\theta & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕y轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & 0 & \sin\theta & 0\\0 & 1 & 0 & 0\\-\sin\theta & 0 & \cos\theta & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕z轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & -\sin\theta & 0 & 0\\\sin\theta & \cos\theta & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕任意轴AB旋转</p><ul><li>将A点移到坐标原点</li><li>使AB分别绕x轴、y轴旋转与z轴重合</li><li>将AB绕z轴旋转$\theta$角</li><li>作上述变换的逆操作，使AB回到原来位置</li></ul><h2 id="矩形求交"><a href="#矩形求交" class="headerlink" title="矩形求交"></a>矩形求交</h2><p>给定两个矩形A和B，矩形A的左上角坐标为$(x_{a1},y_{a1})$，右下角坐标为$(x_{a2},y_{b2})$；矩形B的左上角坐标为$(x_{b1},y_{b1})$，右下角坐标为$(x_{b2},y_{b2})$。</p><p>假设两矩形相交区域为矩形C，左上角坐标为$(x_{c1},y_{c1})$，右下角坐标为$(x_{c2},y_{c2})$</p><p><img src="/2022/01/15/CGreview/71080-20200727202832495-1783624488.png" alt></p><p>分析相交情况可知</p><script type="math/tex; mode=display">x_{c1}=max(x_{a1},x_{b1})\\y_{c1}=min(y_{a1},y_{b1})\\x_{c2}=min(x_{a2},y_{b2})\\y_{c2}=max(y_{a2},y_{b2})</script><p>若要相交则$\begin{cases}x_{c1}<x_{c2}\\y_{c1}>y_{c2}\end{cases}$，即</x_{c2}\\y_{c1}></p><script type="math/tex; mode=display">\begin{cases}max(x_{a1},x_{b1})<min(x_{a2},x_{b2})\\min(y_{a1},y_{b1})>max(y_{a2},y_{b2})\\\end{cases}</script><h2 id="线面求交"><a href="#线面求交" class="headerlink" title="线面求交"></a>线面求交</h2><p>圆柱面</p><script type="math/tex; mode=display">x^2+y^2=r^2</script><p>线的参数方程$x=x(t),y=y(t),z=z(t)$</p><p>代入解方程t</p><h2 id="判断点在多边形内部"><a href="#判断点在多边形内部" class="headerlink" title="判断点在多边形内部"></a>判断点在多边形内部</h2><p>根据向量叉乘，按照逆时针（顺时针）取向量进行叉乘，所得值同号，则说明点在多边形内部。</p><p>即判断方式为：取向量AB和AP、BC和BP、CD和CP、DE和DP、EA和EP进行叉乘，判断所得值是否同号。</p><p><img src="/2022/01/15/CGreview/image-3.png" alt></p><h2 id="三角形相关"><a href="#三角形相关" class="headerlink" title="三角形相关"></a>三角形相关</h2><p>已知三角形三顶点A$(x_1,y_1)$，B$(x_2,y_2)$，C$(x_3,y_3)$</p><p>$\vec{AB}=(x_2-x_1,y_2-y_1,z_2-z_1)$，$\vec{AC}=(x_3-x_1,y_3-y_1,z_3-z_1)$</p><h3 id="单位法向量"><a href="#单位法向量" class="headerlink" title="单位法向量"></a>单位法向量</h3><p>$\frac{\vec{AB}\times\vec{AC}}{|{\vec{AB}\times\vec{AC}}|}$</p><h3 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h3><p>$\frac{1}{2}|\vec{AB}||\vec{AC}|\sin\theta=\frac{1}{2}|\vec{AB}\times\vec{AC}|$</p><h3 id="两个三角形是否相交"><a href="#两个三角形是否相交" class="headerlink" title="两个三角形是否相交"></a>两个三角形是否相交</h3><p>设两个三角形$T_1,T_2$，所在平面分别为$\pi_1,\pi_2$</p><ul><li><p>计算$T_1$每个顶点到$\pi_2$的距离，若同号则$T_1$在$\pi_2$一边，两三角形不相交</p></li><li><p>计算$T_2$每个顶点到$\pi_1$的距离，若同号则$T_2$在$\pi_1$一边，两三角形不相交</p></li><li><p>否则可能相交，计算$T_1$和$\pi_2$的交线$l_1$，$T_2$和$\pi_1$的交线$l_2$</p><p>若$l_1$和$l_2$有重叠，则两三角形相交；否则不相交</p></li></ul><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><h3 id="世界坐标到观察坐标"><a href="#世界坐标到观察坐标" class="headerlink" title="世界坐标到观察坐标"></a>世界坐标到观察坐标</h3><ul><li><p>原点平移矩阵</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & 0 & -x_0\\0 & 1 & 0 & -y_0\\0 & 0 & 1 & -z_0\\0 & 0 & 0 & 1\\\end{matrix} \right]</script></li><li><p>旋转矩阵（单位矢量法）</p><ul><li>取观察坐标系的z轴方向为观察平面的法向，单位化得$n=(n_x,n_y,n_z)$</li><li>取观察坐标系的x轴方向为观察方向，单位化得$u=(u_x,u_y,u_z)$</li><li>取观察坐标系的y轴方向的单位矢量，或直接计算得$v=n\times u=(v_x,v_y,v_z)$</li></ul><script type="math/tex; mode=display">\left[ \begin{matrix}u_x & v_x & n_x & 0\\u_y & v_y & n_y & 0\\u_z & v_z & n_z & 0\\0 & 0 & 0 & 1\\\end{matrix} \right]</script></li></ul><h3 id="一点透视"><a href="#一点透视" class="headerlink" title="一点透视"></a>一点透视</h3><p>假定视点位置为 (0,-2,0)，沿y轴正方向投影，投影面与y轴垂直并经过点 (0,1,0)</p><p>  (a) 请写出点 (2, 2, 2) 经过透视投影后的坐标。</p><p>  (b) 请写出投影矩阵。</p><p>投影后坐标为：（3/2, 1, 3/2）</p><p>投影矩阵如下： </p><p><img src="/2022/01/15/CGreview/image-20220331185506074.png" alt></p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p>Bresenham与中点画线法相比的改进</p><p>灭点个数</p><p>曲线参数方程</p><p>Phong明暗处理中代价最高的步骤</p><p>颜色代码000000为什么颜色</p><h2 id="简答计算题"><a href="#简答计算题" class="headerlink" title="简答计算题"></a>简答计算题</h2><p>多边形的扫描填充伪代码</p><p>简述面消隐的各种算法</p><p>Phong光照模型公式及示意图，反射方向R的推导</p><p>对称变换矩阵</p><p>空间中一正方形和一多边形求交</p><p>给定控制点求Bezier曲线方程，转换为B-Spline的新控制点，转换为Hermite曲线的端点和切矢</p><p>给定视点、投影面，在世界坐标与观察坐标下的投影矩阵</p>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>ComputerGraphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU操作系统复习笔记</title>
    <link href="/2022/01/15/OSreview/"/>
    <url>/2022/01/15/OSreview/</url>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="操作系统-operating-system"><a href="#操作系统-operating-system" class="headerlink" title="操作系统 operating system"></a>操作系统 operating system</h3><p>操作系统是为应用程序提供运行环境的资源管理软件</p><h3 id="虚拟机-virtual-machine"><a href="#虚拟机-virtual-machine" class="headerlink" title="虚拟机 virtual machine"></a>虚拟机 virtual machine</h3><p>通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p><h3 id="运行时系统-runtime-system"><a href="#运行时系统-runtime-system" class="headerlink" title="运行时系统 runtime system"></a>运行时系统 runtime system</h3><p>编译程序除了把用户程序中的语句翻译成机器代码外，还要为用户程序的运行提供管理工作，这部分代码就是运行时系统</p><h3 id="装入程序-loader"><a href="#装入程序-loader" class="headerlink" title="装入程序 loader"></a>装入程序 loader</h3><p>将装入模块装入内存的程序，实现虚拟地址到内存地址的映射，分为绝对装入、静态重定位、动态重定位</p><h3 id="运行栈-execution-stack"><a href="#运行栈-execution-stack" class="headerlink" title="运行栈 execution stack"></a>运行栈 execution stack</h3><p>存放有关正在运行的子程序消息的栈，存放子程序的返回地址、传递给子程序的参数、局部运行环境</p><h3 id="系统调用-system-call"><a href="#系统调用-system-call" class="headerlink" title="系统调用 system call"></a>系统调用 system call</h3><p>操作系统提供给用户程序的一组接口，用于获取内核提供的服务</p><h3 id="应用程序接口-API"><a href="#应用程序接口-API" class="headerlink" title="应用程序接口 API"></a>应用程序接口 API</h3><p>由操作系统或高级语言提供，为应用程序提供跨平台的I/O服务</p><h3 id="特权指令-privileged-instruction"><a href="#特权指令-privileged-instruction" class="headerlink" title="特权指令 privileged instruction"></a>特权指令 privileged instruction</h3><p>能对系统中关键资源进行操作的指令，为保证计算机系统的安全可靠特权指令只能在核心态下使用</p><h3 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程 thread"></a>线程 thread</h3><p>程序在虚拟CPU上的执行过程，是操作系统能够进行调度的最小单位。</p><h3 id="线程控制块-TCB"><a href="#线程控制块-TCB" class="headerlink" title="线程控制块 TCB"></a>线程控制块 TCB</h3><p>操作系统描述和管理线程的数据结构</p><h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程 process"></a>进程 process</h3><p>一组线程及其所依赖的虚拟运行环境，是操作系统进行资源分配的最小单位。</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>操作系统描述和管理进程的数据结构。主要内容有线程TCB、资源描述、虚实资源映射关系、进程的档案</p><h3 id="多线程进程"><a href="#多线程进程" class="headerlink" title="多线程进程"></a>多线程进程</h3><p>进程中可以包含多个线程，所有线程共享进程的虚拟运行环境，进程内线程之间并发执行，每个线程有自己的线程控制块、运行栈</p><h3 id="僵尸进程-zombie-process"><a href="#僵尸进程-zombie-process" class="headerlink" title="僵尸进程 zombie process"></a>僵尸进程 zombie process</h3><p>子进程已经结束，但父进程并不执行wait()为子进程释放资源</p><h3 id="孤儿进程-orphan-process"><a href="#孤儿进程-orphan-process" class="headerlink" title="孤儿进程 orphan process"></a>孤儿进程 orphan process</h3><p>父进程已经退出，剩下的子进程被init进程收留</p><h3 id="进程上下文-process-context"><a href="#进程上下文-process-context" class="headerlink" title="进程上下文 process context"></a>进程上下文 process context</h3><p>进程执行活动全过程的静态描述，包括用户进程传递给内核的参数、CPU的所有寄存器中的值、进程的状态以及堆栈内容</p><h3 id="CPU调度器-scheduler"><a href="#CPU调度器-scheduler" class="headerlink" title="CPU调度器 scheduler"></a>CPU调度器 scheduler</h3><p>按调度算法选择一个就绪线程并将CPU分配给它运行，是操作系统中关键的程序模块</p><h3 id="抢占式调度-preemptive-scheduling"><a href="#抢占式调度-preemptive-scheduling" class="headerlink" title="抢占式调度 preemptive scheduling"></a>抢占式调度 preemptive scheduling</h3><p>进程还没有执行完成就被剥夺CPU，切换执行其他的进程</p><h3 id="对换技术-swapping"><a href="#对换技术-swapping" class="headerlink" title="对换技术 swapping"></a>对换技术 swapping</h3><p>内存空间紧张时，将内存中某些进程暂时调出到外存，腾出足够的内存空间后把具备运行条件的进程调入内存</p><h3 id="多道程序设计-multiprogramming"><a href="#多道程序设计-multiprogramming" class="headerlink" title="多道程序设计 multiprogramming"></a>多道程序设计 multiprogramming</h3><p>允许多个程序同时装入计算机内存中，在管理程序控制下宏观上并行、微观上串行</p><h3 id="请求调页-demand-paging"><a href="#请求调页-demand-paging" class="headerlink" title="请求调页 demand paging"></a>请求调页 demand paging</h3><p>执行一个进程前仅将PCB装入内存，程序和数据并没有实际装入内存；程序执行过程中，如果访问到的页还没有装入内存就通过缺页异常处理将其装入内存</p><h3 id="局部模式-locality-model"><a href="#局部模式-locality-model" class="headerlink" title="局部模式 locality model"></a>局部模式 locality model</h3><p>进程执行过程中，其访问的内存空间从一个局部迁移到另一个局部，这种运行方式被称为局部模式</p><h3 id="颠簸-thrashing"><a href="#颠簸-thrashing" class="headerlink" title="颠簸 thrashing"></a>颠簸 thrashing</h3><p>在页面置换过程中频繁的页面调度导致CPU利用率极低的现象</p><h3 id="工作集-working-model"><a href="#工作集-working-model" class="headerlink" title="工作集 working model"></a>工作集 working model</h3><p>进程在某个时刻t之前$\Delta$次访问中所访问页的集合</p><h3 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区 critical section"></a>临界区 critical section</h3><p>进程中访问临界资源的代码段，临界区不能并发执行</p><h3 id="字符设备-character-device"><a href="#字符设备-character-device" class="headerlink" title="字符设备 character device"></a>字符设备 character device</h3><p>指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等，数据没有地址</p><h3 id="块设备-block-device"><a href="#块设备-block-device" class="headerlink" title="块设备 block device"></a>块设备 block device</h3><p>将信息存储在固定大小的块中，每个块都有自己的地址，I/O传输过程中以块为单位</p><h3 id="物理格式化-physical-formatting"><a href="#物理格式化-physical-formatting" class="headerlink" title="物理格式化 physical formatting"></a>物理格式化 physical formatting</h3><p>将磁盘划分出一系列同心圆磁道，各个磁道划分为扇区</p><h3 id="逻辑格式化-logical-formatting"><a href="#逻辑格式化-logical-formatting" class="headerlink" title="逻辑格式化 logical formatting"></a>逻辑格式化 logical formatting</h3><p>在磁盘上建立一个空文件系统，使操作系统对其进行后续文件读写的过程</p><h3 id="磁盘冗余阵列-RAID"><a href="#磁盘冗余阵列-RAID" class="headerlink" title="磁盘冗余阵列 RAID"></a>磁盘冗余阵列 RAID</h3><p>通过在多个磁盘上存储相同的数据改善性能、增加可靠性的技术</p><h3 id="设备驱动程序-device-driver"><a href="#设备驱动程序-device-driver" class="headerlink" title="设备驱动程序 device driver"></a>设备驱动程序 device driver</h3><p>直接控制设备的程序</p><h3 id="设备依赖的-device-dependent"><a href="#设备依赖的-device-dependent" class="headerlink" title="设备依赖的 device-dependent"></a>设备依赖的 device-dependent</h3><p>指程序只能在特定的设备环境下运行，也称设备相关的</p><h3 id="中断服务例程-ISR"><a href="#中断服务例程-ISR" class="headerlink" title="中断服务例程 ISR"></a>中断服务例程 ISR</h3><p>驱动程序的一部分，处理中断信号，检查自己负责的设备是否发出中断以处理中断事件</p><h3 id="假脱机-SPOOLing"><a href="#假脱机-SPOOLing" class="headerlink" title="假脱机 SPOOLing"></a>假脱机 SPOOLing</h3><p>外围设备同时联机操作，是低速I/O设备与主机交换的一种技术。利用程序模拟脱机输入输出技术中外围控制机的功能，提高了输入输出速度、将独占设备改造为共享设备、实现了虚拟设备的功能</p><h3 id="守护进程-daemon"><a href="#守护进程-daemon" class="headerlink" title="守护进程 daemon"></a>守护进程 daemon</h3><p>开机时启动，后台运行，无交互，直至关机</p><h3 id="文件-file"><a href="#文件-file" class="headerlink" title="文件 file"></a>文件 file</h3><p>由操作系统管理的、存储在外存上的、数据的逻辑单元，位程序提供了按名存取的外存使用模式</p><h3 id="索引节点-i-node"><a href="#索引节点-i-node" class="headerlink" title="索引节点 i-node"></a>索引节点 i-node</h3><p>存放文件属性和文件的位置，每个文件有唯一的索引节点号。整个系统有一个索引节点表，存放全部文件属性和位置</p><h3 id="文件分配表-FAT"><a href="#文件分配表-FAT" class="headerlink" title="文件分配表 FAT"></a>文件分配表 FAT</h3><p>用于文件的链接分配，每个磁盘有一张文件分配表FAT，行号对应块号，每个FAT表项中存放对应磁盘块的下一块链接指针</p><h3 id="文件共享-file-sharing"><a href="#文件共享-file-sharing" class="headerlink" title="文件共享 file sharing"></a>文件共享 file sharing</h3><p>在不同的目录下访问同一个文件；不同的进程访问同一个文件</p><h3 id="保护域-protection-domain"><a href="#保护域-protection-domain" class="headerlink" title="保护域 protection domain"></a>保护域 protection domain</h3><p>对一组对象访问权限的集合{(对象，操作), …}，表示一种身份</p><h3 id="访问矩阵-Access-Matrix"><a href="#访问矩阵-Access-Matrix" class="headerlink" title="访问矩阵 Access Matrix"></a>访问矩阵 Access Matrix</h3><p>定义了系统中所有的保护域</p><h3 id="访问控制表-ACL"><a href="#访问控制表-ACL" class="headerlink" title="访问控制表 ACL"></a>访问控制表 ACL</h3><p>从文件的角度描述用户的权限，访问矩阵按列压缩</p><h3 id="用户权限表-Capability-List"><a href="#用户权限表-Capability-List" class="headerlink" title="用户权限表 Capability List"></a>用户权限表 Capability List</h3><p>从用户的角度描述对文件的操作，访问矩阵按行压缩</p><h3 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 VFS"></a>虚拟文件系统 VFS</h3><p>是物理文件系统与服务之间的一个接口层，为各类文件系统提供了一个统一的操作界面和应用编程接口</p><h3 id="同步-synchronization"><a href="#同步-synchronization" class="headerlink" title="同步 synchronization"></a>同步 synchronization</h3><p>并发环境下，保持操作之间偏序关系的行为</p><h3 id="互斥-mutual-exclusion"><a href="#互斥-mutual-exclusion" class="headerlink" title="互斥 mutual exclusion"></a>互斥 mutual exclusion</h3><p>某一资源同时只允许一个访问者对其进行访问</p><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量 semaphore"></a>信号量 semaphore</h3><p>同步工具，通过PV原子操作控制多线程对共享资源的访问</p><h3 id="管程-monitor"><a href="#管程-monitor" class="headerlink" title="管程 monitor"></a>管程 monitor</h3><p>由高级语言提供的同步方法，将共享变量及对其的所有操作封装在一个对象中，通过每次只允许一个进程在管程内部执行实现进程的互斥，通过设置条件变量及等待、唤醒操作实现进程的同步</p><h3 id="竞争条件-race-condition"><a href="#竞争条件-race-condition" class="headerlink" title="竞争条件 race condition"></a>竞争条件 race condition</h3><p>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题</p><h3 id="安全状态-safe-state"><a href="#安全状态-safe-state" class="headerlink" title="安全状态 safe state"></a>安全状态 safe state</h3><p>系统能按安全序列P1, P2, …, Pn的顺序为每个进程分配其所需的全部资源，使每个进程都能顺利完成，则称系统处于安全状态</p><h2 id="简答论述"><a href="#简答论述" class="headerlink" title="简答论述"></a>简答论述</h2><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><ul><li><p>简单结构</p><ul><li>无核：操作系统内核和应用程序的权限没有区分</li><li>单核：全部内核代码运行在同一个地址空间中，权限相同</li></ul></li><li><p>分层</p><p>系统分成若干层，每层建立在底层基础上，只能高层程序调用低层的程序</p></li><li><p>微内核</p><p>讲内核功能尽量从内核空间移到用户空间，内核尽量小</p><p>更容易扩充、移植，更可靠，更安全；内核与核外程序之间的通信降低性能</p></li><li><p>模块化</p><p>使用面向对象的技术，模块之间通过接口通信</p></li></ul><h3 id="内核、应用程序与用户的关系"><a href="#内核、应用程序与用户的关系" class="headerlink" title="内核、应用程序与用户的关系"></a>内核、应用程序与用户的关系</h3><p>内核为应用程序运行提供管理和服务</p><p>内核和用户无直接关系，用户感觉不到内核的存在</p><p>用户直接/间接执行应用程序</p><h3 id="系统调用的工作机制及其参数传递方法"><a href="#系统调用的工作机制及其参数传递方法" class="headerlink" title="系统调用的工作机制及其参数传递方法"></a>系统调用的工作机制及其参数传递方法</h3><p>工作机制</p><ul><li>正在运行的进程先传递系统调用参数，然后由陷入（trap）指令负责将用户态转化为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核服务程序，最后返回用户态。</li></ul><p>参数传递方法</p><ul><li>通过寄存器传递参数</li><li>若参数数量比寄存器多，参数通常存在内存的块和表中，并将块的地址通过寄存器来传递</li><li>参数通过程序压入堆栈中，通过操作系统弹出</li></ul><h3 id="逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）"><a href="#逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）" class="headerlink" title="逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）"></a>逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）</h3><ul><li><p>编译时（绝对装入）：编译时就知道程序将在内存中的驻留位置，则可以生成绝对代码</p><p>执行速度快</p><p>只适用于单道程序的运行环境</p></li><li><p>加载时（静态重定位）：装入时对地址进行重定位，地址变换在装入时一次性完成</p><p>适用于多道程序的运行环境</p><p>作业装入时需要分配所有要求的内存空间，一旦进入内存不能移动和申请空间</p></li><li><p>执行时（动态重定位）：程序要执行时才进行地址转换</p><p>可以把程序放在不连续的存储区中；程序运行前只装入部分代码即可运行；便于程序段的共享</p><p>需要硬件支持：基地址寄存器、限长寄存器、MMU</p></li></ul><h3 id="进程转换图"><a href="#进程转换图" class="headerlink" title="进程转换图"></a>进程转换图</h3><p><img src="/2022/01/15/OSreview/image-20220331184413295.png" alt="进程转换图"></p><h3 id="进程与线程的区别和联系"><a href="#进程与线程的区别和联系" class="headerlink" title="进程与线程的区别和联系"></a>进程与线程的区别和联系</h3><p>一个线程只能属于一个进程，而一个线程可以有多个线程且至少有一个线程</p><p>线程是操作系统最小的调度单位，进程是操作系统最小的资源分配单位</p><p>同一进程的所有线程共享该进程的所有资源</p><p>同一进程的多个线程共享代码段、数据段、堆，但每个线程拥有自己的栈段</p><p>同一进程的线程可以并发执行，进一步提高资源利用率和系统吞吐量</p><p>对于系统创建/撤销/切换的开销，进程大于线程</p><h3 id="用户级线程和内核级线程及关系"><a href="#用户级线程和内核级线程及关系" class="headerlink" title="用户级线程和内核级线程及关系"></a>用户级线程和内核级线程及关系</h3><p>用户级线程：线程的管理由用户程序（线程库）控制。非抢占式，线程切换速度快，对于操作系统内核透明，若一个线程阻塞则导致整个进程阻塞 ，不适用于多CPU</p><p>内核级线程：线程的管理（创建、撤销、调度）需要由内核控制。可以抢占，切换代价高，若一个线程阻塞则不会影响进程中其他线程的运行，适用于多CPU</p><p>多对一：程序创建的所有线程为用户级线程</p><p>一对一：程序创建的所有线程为内核级线程</p><p>多对多：多个内核级线程共同分担多个用户级线程的任务</p><h3 id="一个进程中能否既有内核级线程又有用户级线程"><a href="#一个进程中能否既有内核级线程又有用户级线程" class="headerlink" title="一个进程中能否既有内核级线程又有用户级线程"></a>一个进程中能否既有内核级线程又有用户级线程</h3><p>当采用多对多方式时，一个进程中既有内核级线程又有用户级线程。每个进程有自己的内核线程池，运行时库分派并标记可运行的用户级线程为准备好执行的线程，操作系统选择用户线程并将它映射到线程池中的可用内核线程，多个用户级线程可以分配给相同的内核级线程</p><p>Java线程属于内核级线程</p><h3 id="何时执行调度器"><a href="#何时执行调度器" class="headerlink" title="何时执行调度器"></a>何时执行调度器</h3><p>非抢占式调度</p><ul><li><p>当前线程执行结束</p></li><li><p>当前线程主动放弃CPU</p></li><li><p>当前线程阻塞</p></li></ul><p>抢占式调度</p><ul><li><p>就绪队列中出现高优先级的线程</p></li><li><p>时间片结束</p></li></ul><h3 id="操作系统需要考虑的调度及目标、方法"><a href="#操作系统需要考虑的调度及目标、方法" class="headerlink" title="操作系统需要考虑的调度及目标、方法"></a>操作系统需要考虑的调度及目标、方法</h3><ul><li><p>作业调度：将外存中的作业调入内存，为其创建进程、分配资源</p><p>先来先服务FCFS 短作业优先SJF 最高响应比优先HRN 优先级 轮转法 多级反馈队列</p></li><li><p>内存调度：为提高内存利用率和系统吞吐量，将内存中的进程暂时挂起，选择部分程序或数据留在内存，这种技术称为交换</p></li><li><p>进程调度：从就绪队列中选择进程获得CPU</p><p>先进先出FIFO 时间片轮转RR 优先级 多级反馈队列</p></li><li><p>磁盘调度：当多个进程要求访问磁盘时，使平均访问时间最小</p><p>先来先服务FCFS 最短寻道时间优先SSTF 电梯调度SCAN LOOK C-SCAN C-LOOK</p></li></ul><blockquote><p>// ？？？不懂算不算调度</p><ul><li><p>空闲分区的分配：将磁盘中一组连续的块分配给文件存储</p><p>首次适应 最佳适应 最坏适应</p></li><li><p>请求分页存储管理中的页面置换：内存空间不足时，需要从内存中调出一页</p><p>最佳置换OPT 先进先出FIFO 最近最久未使用LRU 时钟置换CLOCK</p></li></ul></blockquote><p>调度算法的目标</p><ul><li>CPU利用率 高</li><li>吞吐量 高：单位时间内完成进程的个数</li><li>等待时间 短：线程在就绪队列中的时间</li><li>响应时间 短：从用户提交请求到系统做出反馈的时间</li><li>周转时间 短：进程等待时间+运行时间</li></ul><h3 id="进程调度中多级反馈队列调度算法的基本思想"><a href="#进程调度中多级反馈队列调度算法的基本思想" class="headerlink" title="进程调度中多级反馈队列调度算法的基本思想"></a>进程调度中多级反馈队列调度算法的基本思想</h3><p>将进程按类型分成不同的队列，每个队列采用适合自身的调度算法，从最高优先级队列开始调度，若该队列中的作业未完成则将其降级到更低优先级队列，若较低优先级队列中作业等待时间过长则将其升级到更高优先级队列，能够较好实现公平性与资源利用率之间的平衡。</p><h3 id="进程通信IPC的两种模式"><a href="#进程通信IPC的两种模式" class="headerlink" title="进程通信IPC的两种模式"></a>进程通信IPC的两种模式</h3><p>共享内存：多个进程都可以访问各自的虚拟内存区域，进程虚拟地址映射到相同的物理地址；共享数据过程的同步由应用程序负责</p><p>消息传输：以Message为单位，通过send()和receive()两个原语操作进行数据交换</p><ul><li>直接通信：要求对方在线，每个进程都有消息队列</li><li>间接通信：对方可以不同时在线，通信前建立邮箱</li></ul><h3 id="图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件"><a href="#图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件" class="headerlink" title="图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件"></a>图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件</h3><p>不同作业指向相同的页框号</p><p><img src="/2022/01/15/OSreview/image-20220331184445967.png" alt="页式存储管理系统对页面的共享"></p><p>由于页不是代码的逻辑单元，所以需要将逻辑单元对齐页边界</p><h3 id="CPU和操作系统在分页中各自承担了哪些工作"><a href="#CPU和操作系统在分页中各自承担了哪些工作" class="headerlink" title="CPU和操作系统在分页中各自承担了哪些工作"></a>CPU和操作系统在分页中各自承担了哪些工作</h3><p>CPU生成逻辑地址，分为页表和页偏移量两个部分；当一个进程可分配到CPU时，CPU调度程序可以根据页表副本来定义硬件页表</p><p>操作系统为每个进程维护一个页表的副本用于将逻辑地址转变成物理地址；管理物理内存，维护物理内存的分配信息保存在帧表中；</p><h3 id="图文并茂的描述虚拟地址到物理地址的映射过程"><a href="#图文并茂的描述虚拟地址到物理地址的映射过程" class="headerlink" title="图文并茂的描述虚拟地址到物理地址的映射过程"></a>图文并茂的描述虚拟地址到物理地址的映射过程</h3><p><strong>基本分页式</strong></p><p><img src="/2022/01/15/OSreview/image-基本分页式.png" alt></p><p><strong>带快表的分页式</strong></p><p><img src="/2022/01/15/OSreview/image-带快表的分页式.png" alt></p><p>① 根据逻辑地址计算页号、页内偏移量</p><p>② 比较页号和页表长度，检查页号合法性</p><p>③ 查快表，若命中则获得页面存放的内存块号，转⑤；若未命中，转④</p><p>④ 查页表，根据页表始址找到页号对应页表项，获得页面存放的内存块号，并将该页表项复制到快表中</p><p>⑤ 根据内存块号和页内偏移量得到物理地址</p><p><strong>基本分段式</strong></p><p><img src="/2022/01/15/OSreview/image-基本分段式.png" alt></p><p><strong>段页式</strong></p><p><img src="/2022/01/15/OSreview/image-段页式.png" alt></p><h3 id="请求调页系统中页表项包含的数据项和作用"><a href="#请求调页系统中页表项包含的数据项和作用" class="headerlink" title="请求调页系统中页表项包含的数据项和作用"></a>请求调页系统中页表项包含的数据项和作用</h3><ul><li>页号（隐式）：给页顺序编号</li><li>内存块号：指出该页在内存中的位置</li><li>状态位：该页是否已经调入内存</li><li>访问字段：记录本页在一段时间内的访问次数或最近一次访问时间，用作置换算法的参考项</li><li>修改位：该页在调入内存后是否被修改过</li><li>外存地址：该页在外存中的位置</li></ul><h3 id="请求调页和纯分页的比较"><a href="#请求调页和纯分页的比较" class="headerlink" title="请求调页和纯分页的比较"></a>请求调页和纯分页的比较</h3><ul><li>ISA架构的改变：页故障异常、页表中增加存在位和脏位等设计</li><li>操作系统的改变：页故障异常处理程序（页置换）</li><li>硬盘的改变：对换区</li></ul><h3 id="采用工作集模型预防系统抖动的思想与过程"><a href="#采用工作集模型预防系统抖动的思想与过程" class="headerlink" title="采用工作集模型预防系统抖动的思想与过程"></a>采用工作集模型预防系统抖动的思想与过程</h3><p>根据局部性原理，进程会在某段时间间隔内相对稳定地访问某些页面。所以引入工作集的概念，指在某段时间间隔内进程实际访问的页面的集合</p><p>操作系统跟踪每个进程的工作集，并为进程分配大于其工作集大小的物理块</p><h3 id="颠簸产生的原因及解决方案"><a href="#颠簸产生的原因及解决方案" class="headerlink" title="颠簸产生的原因及解决方案"></a>颠簸产生的原因及解决方案</h3><p>进程频繁访问的页面数多于可用的物理块数</p><p>应用工作集策略为进程分配足够多的物理块；修改页面置换算法；降低多道程序的数量；增加物理内存容量</p><h3 id="I-O控制方式及特点"><a href="#I-O控制方式及特点" class="headerlink" title="I/O控制方式及特点"></a>I/O控制方式及特点</h3><p>程序直接控制：程序直接对设备轮询</p><p>中断驱动：当设备准备完成时发生中断</p><p>DMA：在I/O设备与内存之间开辟直接数据通路</p><p>通道控制：引入专门的I/O处理机进行管理</p><h3 id="输入输出过程举例"><a href="#输入输出过程举例" class="headerlink" title="输入输出过程举例"></a>输入输出过程举例</h3><ul><li><p>线程T调用驱动程序Q的启动部分的代码，启动设备</p></li><li><p>当前线程T等待设备完成操作；设备开始工作，线程T阻塞，CPU转去执行其他任务</p></li><li><p>设备完成工作，发出中断信号，激活中断处理程序，调用驱动程序Q的中断服务例程处理中断，线程T就绪</p></li><li><p>线程T被调度，继续执行</p></li></ul><h3 id="驱动程序、设备、中断服务程序、I-O子系统关系"><a href="#驱动程序、设备、中断服务程序、I-O子系统关系" class="headerlink" title="驱动程序、设备、中断服务程序、I/O子系统关系"></a>驱动程序、设备、中断服务程序、I/O子系统关系</h3><ul><li><p>驱动程序与内核I/O子系统</p><p>内核I/O子系统调用驱动程序，启动设备</p><p>驱动程序可以调用内核，如阻塞、唤醒线程</p></li><li><p>驱动程序与中断处理程序</p><p>中断处理程序调用驱动程序，执行设备中断服务例程</p></li><li><p>驱动程序与设备</p><p>驱动程序向设备发送命令，检测设备状态，通过中断机制响应设备事件</p></li></ul><h3 id="缓冲区的作用"><a href="#缓冲区的作用" class="headerlink" title="缓冲区的作用"></a>缓冲区的作用</h3><p>在内存中预留指定大小的存储空间用来临时存储I/O数据，可以缓和通信双方数据处理速度、单元的差异性，减少实际物理读写次数，提升并发性</p><p>缓冲区一直被重用，可以减少动态分配和回收内存的次数</p><h3 id="缓冲机制的三种用途并举例"><a href="#缓冲机制的三种用途并举例" class="headerlink" title="缓冲机制的三种用途并举例"></a>缓冲机制的三种用途并举例</h3><ul><li><p>处理数据流的生产者与消费者之间的速度差异</p><p>从调制解调器接收文件要保存到硬盘上。由于调制解调器大约比硬盘慢数千倍，所以在内存中创建缓冲区累计从调制解调器接收到的字节，当整个缓冲区填满后，通过一次操作将缓冲区内容写入磁盘中</p></li><li><p>协调传输数据大小不一致的设备</p><p>计算机网络中，缓冲用来处理消息的分段与重组。在发送端，一个到消息分成若干小包；在接收端，将包放在重组缓冲区内，最终生成完成的消息</p></li><li><p>支持应用程序I/O的复制语义</p><p>当某应用程序需要将缓冲区内的数据写入到磁盘上时，操作系统将应用程序缓冲区复制到内核缓冲区中，让磁盘写操作在内核缓冲区中执行，这样后来应用程序缓冲区的改变就没有影响</p></li></ul><h3 id="使用cache的意义"><a href="#使用cache的意义" class="headerlink" title="使用cache的意义"></a>使用cache的意义</h3><p>解决数据读写速度不匹配的问题</p><h3 id="高速缓存与缓冲区的区别"><a href="#高速缓存与缓冲区的区别" class="headerlink" title="高速缓存与缓冲区的区别"></a>高速缓存与缓冲区的区别</h3><p>作用上：高速缓存为了提高效率；缓冲区用于通信双方数据的交换</p><p>内容上：高速缓存中的内容是另一个存储器内容的备份；缓冲区中的数据是唯一的</p><h3 id="异步I-O-阻塞I-O-非阻塞I-O的区别，并举例"><a href="#异步I-O-阻塞I-O-非阻塞I-O的区别，并举例" class="headerlink" title="异步I/O 阻塞I/O 非阻塞I/O的区别，并举例"></a>异步I/O 阻塞I/O 非阻塞I/O的区别，并举例</h3><p>阻塞I/O：请求I/O系统调用后一直等待直到获得结果，进程变为就绪态 socket中的listen(), send(), recv()等</p><p>非阻塞式I/O：请求I/O系统调用后立即返回 socket中的select()</p><p>异步I/O：请求I/O系统调用后立即返回，I/O操作完成后向进程发出信号执行回调函数 aio_read()</p><h3 id="访存操作可能会导致I-O的进行，某进程读写文件时可能并没有I-O设备执行，为什么"><a href="#访存操作可能会导致I-O的进行，某进程读写文件时可能并没有I-O设备执行，为什么" class="headerlink" title="访存操作可能会导致I/O的进行，某进程读写文件时可能并没有I/O设备执行，为什么"></a>访存操作可能会导致I/O的进行，某进程读写文件时可能并没有I/O设备执行，为什么</h3><p>使用了假脱机技术。操作系统对于用户的读写文件请求，并没有真正把I/O设备分配给该用户进程，而是在磁盘缓冲区中为进程分配了空闲盘块和建立了一张I/O请求表，实现了虚拟设备的功能</p><h3 id="批处理、脱机、假脱机为了解决什么问题"><a href="#批处理、脱机、假脱机为了解决什么问题" class="headerlink" title="批处理、脱机、假脱机为了解决什么问题"></a>批处理、脱机、假脱机为了解决什么问题</h3><p>批处理阶段引入脱机技术（在外围控制机的控制下I/O设备的输入输出先被送到更快速的磁带上）缓解了CPU与慢速I/O设备的速度矛盾</p><p>假脱机技术用软件的方式模拟脱机技术（磁盘上开辟的输入输出井模拟磁带，输入输出进程模拟外围控制机）提高了I/O速度，把一台物理设备虚拟成逻辑上的多台设备，将独占设备改造为共享设备</p><h3 id="磁盘分配的三种方式和各自优缺点"><a href="#磁盘分配的三种方式和各自优缺点" class="headerlink" title="磁盘分配的三种方式和各自优缺点"></a>磁盘分配的三种方式和各自优缺点</h3><ul><li><p>连续分配</p><p>每个文件在磁盘上占有连续的块</p><p>优点：支持随机访问、顺序存取速度快</p><p>缺点：不方便文件扩展、会产生外碎片</p></li><li><p>链接分配</p><p>每个文件对应一个磁盘块链表，每个磁盘块有指向下一个磁盘块的指针</p><p>优点：方便文件扩展、无碎片</p><p>缺点：不支持随机访问、磁盘块指针占用空间、存取速度慢、可靠性差</p></li><li><p>索引分配</p><p>每个文件建立一张索引表，放在索引块中</p><p>优点：支持随机访问、方便文件扩展、无碎片</p><p>缺点：索引表占用空间</p></li></ul><h3 id="三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置"><a href="#三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置" class="headerlink" title="三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置"></a>三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置</h3><p>连续分配：FCB记录了文件起始块号和长度，文件物理位置=起始块号+逻辑块号</p><p>链接分配：FCB记录了文件起始块号和结束块号，从起始块开始访问，每个磁盘块都有指向下一个磁盘块的指针，直到访问到结束块</p><p>索引分配：FCB记录了索引块所在的物理块号，访问该物理块读取索引表，得到各个逻辑块对应的物理块号</p><h3 id="FAT工作原理-链接分配中引入FAT的优点"><a href="#FAT工作原理-链接分配中引入FAT的优点" class="headerlink" title="FAT工作原理 链接分配中引入FAT的优点"></a>FAT工作原理 链接分配中引入FAT的优点</h3><p>每个磁盘建立一张文件分配表FAT，行号对应块号；每个FAT表项中存放对应磁盘块的下一块链接指针</p><p>支持随机访问</p><h3 id="空闲存储空间管理"><a href="#空闲存储空间管理" class="headerlink" title="空闲存储空间管理"></a>空闲存储空间管理</h3><ul><li><p>连续空闲空间管理</p><p>空闲区列表，每一项记录空闲区起始块号和空闲块数量</p></li><li><p>空闲块链</p><p>空闲块组成链表，指针放在空闲块中</p></li><li><p>成组空闲块链</p><p>每组100个空闲块，第一组索引在内存中，下一组索引在每组最后一块</p></li><li><p>位图</p><p>连续存储空间，每位对应一个盘块，存放在内存中</p></li></ul><h3 id="文件系统如何依据用户给出的文件名找到该文件对应的FCB"><a href="#文件系统如何依据用户给出的文件名找到该文件对应的FCB" class="headerlink" title="文件系统如何依据用户给出的文件名找到该文件对应的FCB"></a>文件系统如何依据用户给出的文件名找到该文件对应的FCB</h3><p>顺序检索目录表，找到文件名对应的目录项，该目录项就是FCB</p><h3 id="文件共享的途径"><a href="#文件共享的途径" class="headerlink" title="文件共享的途径"></a>文件共享的途径</h3><p>硬连接（基于索引节点）方式中，不同文件的目录项指向同一个索引节点，索引节点中设置一个引用计数变量</p><p>软连接（基于符号链接）方式中，由系统生成一个LINK类型文件，包含被共享文件的路径名</p><h3 id="如何实现多种文件系统的共存"><a href="#如何实现多种文件系统的共存" class="headerlink" title="如何实现多种文件系统的共存"></a>如何实现多种文件系统的共存</h3><p>文件系统的挂载，挂载表记录系统已安装文件系统的类型和指向文件系统的指针，挂载位置为目录节点或独立盘符</p><p>虚拟文件系统VFS，抽象出各种文件系统共有的部分，为各种文件系统提供一个统一的操作界面和应用编程接口</p><h3 id="操作系统中打开文件的工作过程"><a href="#操作系统中打开文件的工作过程" class="headerlink" title="操作系统中打开文件的工作过程"></a>操作系统中打开文件的工作过程</h3><p>使用open系统调用，提供文件存放路径、文件名、操作类型，操作系统在系统文件打开表中查找</p><ul><li><p>该文件已经打开</p><p>检查操作类型是否合法</p><p>在进程文件打开表中为文件分配一个表项，将该表项的指针指向系统文件打开表中该文件对应的一项</p><p>在PCB中为文件分配一个文件描述符fd作为进程文件打开表项的指针，文件打开完成</p></li><li><p>该文件没有打开</p><p>根据文件存放路径查找相应的目录文件是否在内存中，若不在则装入内存</p><p>从目录中找到文件名对应的目录项，检查操作类型是否合法，得到该文件的FCB在磁盘中的位置</p><p>将该FCB装入内存中的Active Inode中</p><p>在系统文件打开表中为文件分配一个表项，将该表项的指针指向Active Inode中对应的FCB</p><p>在进程文件打开表中为文件分配一个表项，将该表项的指针指向系统文件打开表中该文件对应的一项</p><p>在PCB中为文件分配一个文件描述符fd作为进程文件打开表项的指针，文件打开完成</p></li></ul><h3 id="临界区及其使用准则"><a href="#临界区及其使用准则" class="headerlink" title="临界区及其使用准则"></a>临界区及其使用准则</h3><p>进程在并发执行中可以共享系统中的资源，但对临界资源的访问必须互斥进行，一个进程中访问临界资源的代码段为临界区。</p><p>临界区的使用准则</p><ul><li>空闲让进：无进程处于临界区时，若有进程要求进入临界区应允许进入</li><li>忙则等待：有进程处于临界区时，其他试图进入该临界区的进程必须等待</li><li>有限等待：有进程等待进入临界区时，它的等待时间应该是有限的</li><li>让权等待：等待进入临界区的进程应释放CPU</li></ul><h3 id="同步与互斥的异同"><a href="#同步与互斥的异同" class="headerlink" title="同步与互斥的异同"></a>同步与互斥的异同</h3><p>相同点</p><ul><li>都是并发环境下操作之间的时序关系</li><li>不满足条件时线程等待</li><li>运行过程中动态判定</li></ul><p>不同点</p><ul><li>同步在时序上是固定的偏序关系</li><li>互斥在时序上只要不同时执行即可</li></ul><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li>互斥：资源一次只能由一个进程使用</li><li>非抢占：资源只能在进程完成任务后自动释放</li><li>占有并等待：一个进程必须至少占用一个资源，并等待另一资源，且该资源被其他进程占有</li><li>循环等待：有一组等待进程{P0, P1, …, Pn}，P0等待的资源被P1占有，P1等待的资源被P2占有，……，Pn等待的资源被P0占有</li></ul><h3 id="CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁"><a href="#CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁" class="headerlink" title="CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁"></a>CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁</h3><p>CPU属于可剥夺性资源。只有不可剥夺资源才会因为竞争资源而产生死锁。</p><h3 id="死锁预防思路"><a href="#死锁预防思路" class="headerlink" title="死锁预防思路"></a>死锁预防思路</h3><ul><li><p>破坏互斥条件</p><p>一般不能破坏</p><p>假脱机技术可以将独占设备在逻辑上改造成共享设备</p></li><li><p>破坏占有并等待条件</p><p>一次性申请需要的所有资源；申请新资源前释放已占有资源</p><p>产生饥饿的概率增加</p></li><li><p>破坏非抢占条件</p><p>若进程请求资源不成功则回收其占有的所有资源</p><p>一般适用于易保存和恢复的资源</p></li><li><p>破坏循环等待条件</p><p>将所有资源排序编号，进程只能按序号递增的顺序申请资源</p></li></ul><h3 id="简述银行家算法避免死锁的过程"><a href="#简述银行家算法避免死锁的过程" class="headerlink" title="简述银行家算法避免死锁的过程"></a>简述银行家算法避免死锁的过程</h3><p>变量定义</p><ul><li>Allocation矩阵：当前已分配给各进程的各类资源数目</li><li>Max矩阵：各进程总共需要的各类资源数目</li><li>Need矩阵：各进程还需要的各类资源数目</li><li>Available向量：当前可供分配的各类资源数目</li><li>Work向量：用于安全检测算法中记录可供分配的各类资源数目</li><li>Finish数组：用于安全检测算法中记录是否能满足该进程所有资源请求</li></ul><p>算法过程</p><p>​    进程Pi提出申请资源的请求Request</p><ul><li><p>检查Request&lt;=Need[i]</p></li><li><p>检查Request&lt;=Available</p></li><li><p>Allocation[i]=Allocation[i]+Request</p><p>Need[i]=Need[i]-Request</p><p>Available=Available-Request</p></li><li><p>执行安全性算法</p><ul><li><p>Work=Available Finish[:]=false</p></li><li><p>查找i，使Work&gt;=Need[i]且Finish[i]=false</p><ul><li><p>若找到，则Work=Work+Allocation[i] Finish[i]=true，继续查找</p></li><li><p>若找不到，检查是否Finish数组全为true</p><p>是则安全，否则不安全</p></li></ul></li><li><p>若产生的资源分配状态安全，则满足Request请求；否则不满足，恢复到原来资源分配状态</p></li></ul></li></ul><h3 id="死锁避免、死锁预防并比较区别"><a href="#死锁避免、死锁预防并比较区别" class="headerlink" title="死锁避免、死锁预防并比较区别"></a>死锁避免、死锁预防并比较区别</h3><p>死锁预防：通过破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。是在进程申请资源的层面上进行的，系统预先确定资源分配策略，系统按照策略进行分配。</p><p>死锁避免：当进程提出资源申请时系统测试资源分配，仅当能确保系统安全的时候才把资源分配给进程，这样使得系统能一直处于安全状态。是在操作系统分配资源的层面上进行的。</p><h3 id="死锁检测和恢复的思路"><a href="#死锁检测和恢复的思路" class="headerlink" title="死锁检测和恢复的思路"></a>死锁检测和恢复的思路</h3><p>检测：资源分配图化简后形成环路；死锁检测算法</p><p>恢复：资源剥夺法；撤销进程法；进程回退法</p><h3 id="阻塞、饥饿、死锁的区别"><a href="#阻塞、饥饿、死锁的区别" class="headerlink" title="阻塞、饥饿、死锁的区别"></a>阻塞、饥饿、死锁的区别</h3><p>阻塞：一个正在执行的进程由于I/O请求等事件暂时无法继续执行，将其暂停执行</p><p>饥饿：一个进程因调度算法不合理而长时间等待；发生饥饿的进程既可能是阻塞态（长期得不到需要的I/O设备）也可能是就绪态（长期得不到CPU）；等待会被释放但不会分配给自己的资源</p><p>死锁：多个进程因竞争资源而相互等待；发生死锁的进程一定处于阻塞态；等待永远不会被释放的资源</p><h3 id="简述保护的概念"><a href="#简述保护的概念" class="headerlink" title="简述保护的概念"></a>简述保护的概念</h3><ul><li><p>硬件层面</p><p>操作系统分为内核态和用户态，将可能引起损害的机器指令作为特权指令，且只能在内核态下执行特权指令</p><p>操作系统使用定时器防止用户程序陷入死循环</p></li><li><p>文件管理</p><p>文件保护指避免文件拥有者或其它用户因错误操作使文件受到破坏，有三种方式：口令保护、密码保护、访问控制（每个文件和目录增加一个访问控制列表ACL，记录每个用户名及允许的访问类型）</p></li><li><p>设备管理</p><p>设备被看作文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中的信息判断用户是否有访问权限，来实现设备保护的功能</p></li><li><p>存储管理</p><p>保护内存使各道作业互不干扰，可以设置一对上下限寄存器或基址寄存器和限长寄存器，当进行地址变换时检查是否出现越界</p></li><li><p>进程同步</p><p>为保护临界区资源同一时间只能由一个进程访问，可以采用硬件方法：关中断、TestAndSet指令、Swap指令，软件方法：Peterson算法</p></li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="m-n-k生产者-消费者问题"><a href="#m-n-k生产者-消费者问题" class="headerlink" title="m-n-k生产者-消费者问题"></a>m-n-k生产者-消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore full=<span class="hljs-number">0</span>, empty=k, mutex=<span class="hljs-number">1</span>;<br>Item buffer[k];<br><span class="hljs-keyword">int</span> in=<span class="hljs-number">0</span>, out=<span class="hljs-number">0</span>;<br><br>producer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(empty);<br>    P(mutex);<br>    buffer[in] = item;<br>    in = (in+<span class="hljs-number">1</span>)%k;<br>    V(full);<br>    V(mutex);<br>&#125;<br><br>consumer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(full);<br>    P(mutex);<br>    item = buffer[out];<br>    out = (out+<span class="hljs-number">1</span>)%k;<br>    V(empty);<br>    V(mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore rw_mutex=<span class="hljs-number">1</span>, r_mutex=<span class="hljs-number">1</span>, w=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> r_count=<span class="hljs-number">0</span>;<br><br>writer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(w);<br>    P(rw_mutex);<br>    <span class="hljs-comment">//writing...</span><br>    V(rw_mutex);<br>    V(w);<br>&#125;<br><br>reader:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(w);<br>    P(r_mutex);<br>    <span class="hljs-keyword">if</span>(r_count == <span class="hljs-number">0</span>)&#123;<br>        P(rw_mutex);<br>    &#125;<br>    r_count++;<br>    V(r_mutex);<br>    V(w);<br>    <span class="hljs-comment">//reading...</span><br>    P(r_mutex);<br>    r_count--;<br>    <span class="hljs-keyword">if</span>(r_count == <span class="hljs-number">0</span>)&#123;<br>        V(rw_mutex);<br>    &#125;<br>    V(r_mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;, mutex=<span class="hljs-number">1</span>;<br>Philosopher_i:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(mutex);<br>    P(chopstick[i]);<br>    P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    <span class="hljs-comment">//eating...</span><br>    V(mutex);<br>    V(chopstick[i]);<br>    V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    <span class="hljs-comment">//thinking...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDU</tag>
      
      <tag>OperationgSystem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
