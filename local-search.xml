<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字节青训营前端场#1 [前端与HTML]</title>
    <link href="/2022/01/16/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%89%8D%E7%AB%AF%E5%9C%BA-1/"/>
    <url>/2022/01/16/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%89%8D%E7%AB%AF%E5%9C%BA-1/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是前端？"><a href="#什么是前端？" class="headerlink" title="什么是前端？"></a>什么是前端？</h1><ul><li>解决GUI人机交互问题</li><li>跨终端<ul><li>PC/移动浏览器</li><li>客户端/小程序</li><li>VR/AR等</li></ul></li><li>Web技术栈</li></ul><h1 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h1><ul><li><p>HTML(内容)</p></li><li><p>CSS(样式)</p></li><li><p>JavaScript(行为)</p></li></ul><h1 id="前端应该关注哪些方面？"><a href="#前端应该关注哪些方面？" class="headerlink" title="前端应该关注哪些方面？"></a>前端应该关注哪些方面？</h1><ul><li><p>功能</p></li><li><p>美观</p></li><li><p>无障碍</p></li><li>安全</li><li>性能</li><li>兼容性</li></ul><h1 id="HTML是什么？"><a href="#HTML是什么？" class="headerlink" title="HTML是什么？"></a>HTML是什么？</h1><p>HyperText ：超文本（图片、标题、链接、表格）</p><p>Markup Language ：标记语言（<code>&lt;h1&gt;文章标题&lt;h1&gt;</code>）</p><h1 id="HTML语法"><a href="#HTML语法" class="headerlink" title="HTML语法"></a>HTML语法</h1><ul><li>标签和属性不区分大小写，推荐小写</li><li>空标签可以不闭合，比如<code>input</code>、<code>meta</code></li><li>属性值推荐用双引号包裹</li><li>某些属性值可以忽略，比如<code>required</code>、<code>readonly</code></li></ul><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><code>&lt;h1&gt;~&lt;h6&gt;</code></p><p><img src="/2022/01/16/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%89%8D%E7%AB%AF%E5%9C%BA-1/title.png" alt="标题"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>有序列表<code>&lt;ol&gt;&lt;li&gt;</code></p><p>无序列表<code>&lt;ul&gt;&lt;li&gt;</code></p><p>定义列表<code>&lt;dl&gt;&lt;dt&gt;&lt;dd&gt;</code></p><p><img src="/2022/01/16/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%89%8D%E7%AB%AF%E5%9C%BA-1/list.png" alt="列表"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><code>&lt;a href=&quot;http://31wu.top/&quot;&gt; 31&#39;s Blog &lt;a&gt;</code></p><h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><p><code>&lt;img src=&quot;&quot; alt=&quot;替代性文本&quot; width=&quot;&quot;/&gt;</code></p><p><code>&lt;audio src=&quot;&quot; controls&gt;&lt;/audio&gt;</code></p><p><code>&lt;video src=&quot;&quot; constrols&gt;&lt;/video&gt;</code></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><code>&lt;input placeholder=&quot;请输入&quot;&gt;</code></p><p><code>&lt;input type=&quot;range&quot;&gt;</code></p><p><code>&lt;input type=&quot;number&quot; min=&quot;1&quot; max=&quot;10&quot;&gt;</code></p><p><code>&lt;input type=&quot;date&quot; min=&quot;2001-10-10&quot;&gt;</code></p><p><code>&lt;textarea&gt;Hey&lt;/textarea&gt;</code></p><h2 id="内容划分"><a href="#内容划分" class="headerlink" title="内容划分"></a>内容划分</h2><p><img src="/2022/01/16/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5%E5%89%8D%E7%AB%AF%E5%9C%BA-1/content.png" alt="内容划分"></p><h2 id="……"><a href="#……" class="headerlink" title="……"></a>……</h2><p><a href="https://www.runoob.com/html/html-tutorial.html">HTML 教程 | 菜鸟教程 (runoob.com)</a></p><h1 id="语义化是什么？"><a href="#语义化是什么？" class="headerlink" title="语义化是什么？"></a>语义化是什么？</h1><ul><li>HTML中的元素、属性及属性值都拥有某些含义</li><li>开发者应该遵循语义来编写HTML<ul><li>有序列表用<code>ol</code>；无序列表用<code>ul</code></li><li><code>lang</code>属性表示内容所使用的语言</li></ul></li></ul><h1 id="谁在使用我们写的HTML？"><a href="#谁在使用我们写的HTML？" class="headerlink" title="谁在使用我们写的HTML？"></a>谁在使用我们写的HTML？</h1><ul><li>开发者 - 修改、维护页面</li><li>浏览器 - 展示页面</li><li>搜索引擎 - 提取关键词、排序</li><li>屏幕阅读器 - 给盲人读页面内容</li></ul><h1 id="语义化的好处"><a href="#语义化的好处" class="headerlink" title="语义化的好处"></a>语义化的好处</h1><ul><li>代码可读性</li><li>可维护性</li><li>搜索引擎优化</li><li>提升无障碍性</li></ul><h1 id="如何做到语义化？"><a href="#如何做到语义化？" class="headerlink" title="如何做到语义化？"></a>如何做到语义化？</h1><p>推荐阅读<a href="https://www.w3.org/">W3C</a>、<a href="https://developer.mozilla.org/zh-CN/">MDN</a>文档</p><ul><li><p>了解每个标签和属性的含义</p></li><li><p>思考什么标签最适合描述这个内容</p></li><li>不使用可视化工具生成代码</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字节</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU机器学习试题回忆</title>
    <link href="/2022/01/15/MLmemory/"/>
    <url>/2022/01/15/MLmemory/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1 线性回归和正则化 (15’)</p></blockquote><p>求线性回归的Hessian矩阵</p><p>证明对于线性回归，使用牛顿法，迭代⼀次即得最优解$\theta^*=(X^TX)^{-1}X^T\vec{y}$</p><p>证明对于正则化的线性回归，使用牛顿法，迭代⼀次即得最优解$\theta^*=(X^TX+\lambda L)^{-1}X^T\vec{y}$</p><blockquote><p>2 朴素贝叶斯的计算 (20’)</p></blockquote><p>计算所有$p(Y),p(x_i|Y)$</p><p>结果为$arg \max_y P(y)\prod P(x_i|y)$</p><blockquote><p>3 Soft-Margin SVM的变体 (30’)</p></blockquote><p>证明约束条件$\xi_i \ge 0$不用显式给出</p><p>写出原问题的KKT条件</p><p>写出原问题的对偶问题</p><blockquote><p>4 EM的变体 将原始M-step改用梯度上升法 (20’)</p></blockquote><p>证明收敛性</p><p>证明正确性即两式求导结果相等</p><blockquote><p>5 论述 (15’)</p></blockquote><p>K-means步骤</p><p>PCA步骤</p><p>Bias, Variance, Complexity关系</p>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU计算机图形学复习笔记</title>
    <link href="/2022/01/15/CGreview/"/>
    <url>/2022/01/15/CGreview/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="计算机图形学的主要研究内容是什么？"><a href="#计算机图形学的主要研究内容是什么？" class="headerlink" title="计算机图形学的主要研究内容是什么？"></a>计算机图形学的主要研究内容是什么？</h2><p>计算机中图形的表示方法，以及利用计算机进行图形的计算、处理和显示的相关原理与算法</p><h2 id="列举三个以上图形学的应用领域"><a href="#列举三个以上图形学的应用领域" class="headerlink" title="列举三个以上图形学的应用领域"></a>列举三个以上图形学的应用领域</h2><p>计算机辅助设计与制造（CAD/CAM）</p><p>可视化</p><p>真实感图形实时绘制与自然景物仿真</p><p>计算机动画</p><p>用户接口</p><p>计算机艺术</p><h2 id="一个图形系统通常由哪些图形设备组成？"><a href="#一个图形系统通常由哪些图形设备组成？" class="headerlink" title="一个图形系统通常由哪些图形设备组成？"></a>一个图形系统通常由哪些图形设备组成？</h2><p>图形处理器、图形输入设备和输出设备</p><h2 id="图形和图像的区别是什么？"><a href="#图形和图像的区别是什么？" class="headerlink" title="图形和图像的区别是什么？"></a>图形和图像的区别是什么？</h2><p>图像：计算机内以位图形式存在的灰度信息</p><p>图形：含有几何属性，由场景的几何模型和景物的物理属性共同组成的</p><h2 id="CRT显示器的原理是什么？"><a href="#CRT显示器的原理是什么？" class="headerlink" title="CRT显示器的原理是什么？"></a>CRT显示器的原理是什么？</h2><p>高速的电子束由电子枪发出，经过聚焦系统、加速系统和磁偏转系统就会到达荧光屏的特定位置</p><h2 id="LCD有哪些技术指标？"><a href="#LCD有哪些技术指标？" class="headerlink" title="LCD有哪些技术指标？"></a>LCD有哪些技术指标？</h2><p>可视角度 CR10、CR5</p><p>点距</p><p>分辨率</p><h2 id="有哪些常用的图形输入设备？"><a href="#有哪些常用的图形输入设备？" class="headerlink" title="有哪些常用的图形输入设备？"></a>有哪些常用的图形输入设备？</h2><p>键盘、鼠标</p><p>跟踪球、空间球、数据手套、光笔、触摸屏</p><h2 id="图形学之父"><a href="#图形学之父" class="headerlink" title="图形学之父"></a>图形学之父</h2><p>Ivan E. Sutherland</p><h2 id="ACM-Siggraph最高奖以谁的名字命名"><a href="#ACM-Siggraph最高奖以谁的名字命名" class="headerlink" title="ACM Siggraph最高奖以谁的名字命名"></a>ACM Siggraph最高奖以谁的名字命名</h2><p>Steven A. Coons</p><h1 id="第二章-光栅图形学"><a href="#第二章-光栅图形学" class="headerlink" title="第二章 光栅图形学"></a>第二章 光栅图形学</h1><h2 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h2><h3 id="数值微分法（DDA）"><a href="#数值微分法（DDA）" class="headerlink" title="数值微分法（DDA）"></a>数值微分法（DDA）</h3><p>增量思想：对于直线y=kx+b，x每递增1，y则递增k</p><p>在该算法中，y和k都要用浮点数表示，且每一步都需要对y四舍五入取整，不适合硬件实现</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDALine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br> <span class="hljs-keyword">float</span> dx, dy, y, k;<br>    dx = x1-x0;<br>    dy = y1-y0;<br>    k = dy/dx;<br>    y = y0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=x0; x&lt;=x1; x++)&#123;<br>        drawpixel(x, <span class="hljs-keyword">int</span>(y+<span class="hljs-number">0.5</span>));<br>        y += k;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h3><p>采用了直线的一般形式：F(x,y)=Ax+By+C=0，其中A=-dy，B=dx</p><p>画直线段过程中当前像素点为(x0,y0)，下一个像素点有两种选择P1(x0+1,y0), P2(x0+1,y0+1)，设M(x0+1,y0+0.5)是P1P2中点，Q为理想直线与x=x0+1的交点，当M在Q下方时F(M)<0，下一个像素点为P2，当M在Q上方时F(M)>0，下一个像素点为P1</0，下一个像素点为P2，当M在Q上方时F(M)></p><p>采用增量计算，令d=F(M)=a+0.5b，取正右方P1后判断下一个像素时d1=d+a，取右上方P2后判断下一个像素时d2=d+a+b</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MidpointLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, d1, d2, d, x, y;<br>    a = y0-y1;<br>    b = x1-x0;<br>    d = <span class="hljs-number">2</span>*a+b;<br>    d1 = <span class="hljs-number">2</span>*a;<br>    d2 = <span class="hljs-number">2</span>*(a+b);<br>    x = x0, y = y0;<br>    <span class="hljs-keyword">while</span>(x&lt;x1)&#123;<br>        <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">0</span>)&#123;<br>            x++;<br>            y++;<br>            d += d2;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            x++;<br>            d += d1;<br>        &#125;<br>        drawpixel(x, y);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h3><p>过各行各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序计算直线与各垂直网格线的交点，根据误差项的符号确定该列像素中与此交点最近的像素</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IntegerBresenhamLine</span><span class="hljs-params">(x0, y0, x1, y1)</span></span>&#123;<br>    x = x0;<br>    y = y0;<br>    dx = x1-x0;<br>    dy = y1-y0;<br>    e = -dx;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=dx; i++)&#123;<br>        drawpixel(x, y);<br>        x++;<br>        e += <span class="hljs-number">2</span>*dy;<br>        <span class="hljs-keyword">if</span>(e&gt;=<span class="hljs-number">0</span>)&#123;<br>            y++;<br>            e -= <span class="hljs-number">2</span>*dx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="多边形的扫描转换"><a href="#多边形的扫描转换" class="headerlink" title="多边形的扫描转换"></a>多边形的扫描转换</h2><blockquote><p>多边形有两种重要的表示方法：顶点表示和点阵表示</p><p>多边形的顶点表示转换为点阵表示，这种转换称为多边形的扫描转换</p></blockquote><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，以完成填充工作</p><p>对于一条扫描线，多边形的扫描步骤为：</p><ol><li>求交。计算扫描线与多边形各边的交点</li><li>排序。把所有交点按照x值递增顺序排序</li><li>配对。将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间</li><li>填色。把相交区间内的像素置成多边形的颜色，把相交区间外的像素置成背景色</li></ol><p>涉及的数据结构：</p><ul><li><p>活性边表AET：为提高效率，在处理一条扫描线时仅对与它相交的多边形的边进行求交运算，与当前扫描线相交的边称为活性边，把活性边按与扫描线交点x坐标递增的顺序存放在一个链表中，该链表为AET</p><p>结点内容：</p><ol><li><p>当前扫描线与边的交点坐标x值</p></li><li><p>从当前扫描线到下一条扫描线间x的增量$\Delta x$</p></li><li><p>该边所交的最高扫描线号$y_{max}$</p></li></ol></li><li><p>新边表NET：为方便AET的建立与更新，为每一条扫描线建立一个NET，存放在该扫描线第一次出现的边</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scanLinePolyFill</span><span class="hljs-params">(polygon)</span></span>&#123;<br>    <span class="hljs-comment">//初始化新边表NET</span><br>    <span class="hljs-keyword">for</span>(各条扫描线i)&#123;<br>        初始化NET[i]头指针;<br>        把ymin=i的边放入NET[i]中;<br>    &#125;<br>    <span class="hljs-comment">//扫描准备</span><br>    初始化AET为空;<br>    y=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始扫描</span><br>    <span class="hljs-keyword">for</span>(各条扫描线i)&#123;<br>        <span class="hljs-comment">//加入边</span><br>        将NET[i]中的边插入排序到AET中;<br>        若要自交,则对AET冒泡排序;<br>        <span class="hljs-comment">//区间填色</span><br>        遍历AET，配对交点区间，对区间上的点改写像素值;<br>        <span class="hljs-comment">//删除边 </span><br>        删除ymax=i的边;<br>        <span class="hljs-comment">//更新AET</span><br>        将AET中结点的x值递增dx;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="边界标志算法"><a href="#边界标志算法" class="headerlink" title="边界标志算法"></a>边界标志算法</h3><p>帧缓冲器对多边形进行直线扫描转换时在边界像素打上标志，再采用和扫描线算法类似的方法将位于多边形的各个区间填色。适合硬件实现</p><h2 id="多边形的区域填充"><a href="#多边形的区域填充" class="headerlink" title="多边形的区域填充"></a>多边形的区域填充</h2><blockquote><p>这里的区域是指已经表示成点阵形式的填充图形，它是像素的集合</p><p>区域可采用内点表示和边界表示</p><p>区域可分为四连通区域和八连通区域（容易穿出脆弱边界）</p></blockquote><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>假设在多边形内有一个像素已知，由此出发利用连通性找到区域内的所有像素</p><h3 id="扫描线算法-1"><a href="#扫描线算法-1" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>给定种子点时，首先填充种子点所在扫描线上位于给定区域的一个区间，然后确定与这一区间相连通的上下两条扫描线上位于给定区域内的区间，并依次保存下来，反复这个过程直到填充结束</p><p>区域填充的扫描线算法步骤：</p><ol><li>初始化。堆栈置空，将种子点(x,y)入栈</li><li>出栈。若栈空则结束；否则取栈顶元素(x,y)，以y作为当前扫描线</li><li>填充并确定种子点所在区段。从种子点(x,y)出发，沿当前扫描线向左、右两个方向填充，直到边界。分别标记区段的左右端点坐标为xl和xr</li><li>确定新的种子点。在区间[xl,xr]中检查与当前扫描线y上下相邻的两条扫描线上的像素。若存在非边界、未填充的像素，则把每一区间的最右像素作为种子点压入堆栈，返回第2步</li></ol><h2 id="直线段裁剪"><a href="#直线段裁剪" class="headerlink" title="直线段裁剪"></a>直线段裁剪</h2><h3 id="Cohen-Sutherland法"><a href="#Cohen-Sutherland法" class="headerlink" title="Cohen-Sutherland法"></a>Cohen-Sutherland法</h3><p>对线段端点进行编码<code>code1</code> <code>code2</code>，判断直线段与窗口的关系，分为三种情况：</p><ol><li><p>全在窗口内，显示该线段；<code>code1 | code2 == 0</code></p></li><li><p>完全不在窗口内，丢弃该线段；<code>code1 &amp; code2 != 0</code></p></li><li><p>线段与窗口有交，求出该交点，把线段一分为二，丢弃在窗口外的一段，对另一端重复上述处理</p></li></ol><h3 id="中点分割法"><a href="#中点分割法" class="headerlink" title="中点分割法"></a>中点分割法</h3><p>首先对线段端点进行编码，并把线段与窗口的关系分为三种情况：</p><ol><li>全在窗口内，显示该线段</li><li>完全不在窗口内，丢弃该线段</li><li>线段与窗口有交，用<strong>中点分割</strong>的方法求出线段与窗口的交点</li></ol><p>改进之处：不用解方程组求交，而是采用二分法求交</p><p>改进理由：主要计算过程只用到加法和除2运算，适合硬件实现和并行计算</p><h3 id="梁友栋-Barskey裁剪算法"><a href="#梁友栋-Barskey裁剪算法" class="headerlink" title="梁友栋-Barskey裁剪算法"></a>梁友栋-Barskey裁剪算法</h3><p>参数化裁剪条件：</p><script type="math/tex; mode=display">\begin{cases}XL \le x_1+u\Delta x\le XR\\YB \le y_1+u\Delta y\le YT\end{cases}</script><p>可以表示为统一形式：$up_k\le q_k$</p><ul><li><p>$p_k=0$，直线段平行于裁剪边界之一</p><ul><li>$q_k&lt;0$，则线段完全在边界外，舍弃该线段</li><li>$q_k\ge0$，则该线段平行于裁剪边界并且在窗口内</li></ul></li><li><p>$p_k&lt;0$，线段从裁剪边界所在直线的外部指向内部</p><p>计算线段与边界k的延长线的交点u值$r_k=q_k/p_k$，$u_1=max\{0,r_k\}$</p></li><li><p>$p_k&gt;0$，线段从裁剪边界所在直线的内部指向外部</p><p>计算线段与边界k的延长线的交点u值$r_k=q_k/p_k$，$u_2=min\{1,r_k\}$</p></li></ul><p>如果$u_1&gt;u_2$则线段完全落在裁剪窗口之外被舍弃；否则裁剪线段由参数$u_1,u_2$计算出来，它们定义了在裁剪矩形内的线段部分</p><p>它比前两种方法快，因为线段与窗口边界的交点仅需计算一次，且更新参数$u1,u2$仅需要一次除法</p><h2 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h2><h3 id="Sutherland-Hodgman算法"><a href="#Sutherland-Hodgman算法" class="headerlink" title="Sutherland-Hodgman算法"></a>Sutherland-Hodgman算法</h3><p>一次用窗口的一条边裁剪多边形，得到一个顶点序列，作为下一条裁剪边处理过程的输入</p><p>每条线段端点S,P与裁剪线的位置关系有如下4种，红色标注点为输出的点：</p><p><img src="https://img-blog.csdnimg.cn/20201226192313592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwMjI4,size_16,color_FFFFFF,t_70" alt></p><p>算法优点：裁剪窗口可以是任意凸多边形</p><p>算法不足：只能裁剪凸多边形；裁剪窗口不能是凹多边形</p><p>算法改进：可以将凹多边形分割成多个凸多边形再去运行该算法</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><h3 id="字库的分类"><a href="#字库的分类" class="headerlink" title="字库的分类"></a>字库的分类</h3><p>点阵型：存储空间大、易于显示</p><p>矢量型：存储空间小、美观、变换方便</p><h3 id="字符裁剪"><a href="#字符裁剪" class="headerlink" title="字符裁剪"></a>字符裁剪</h3><p>串精度</p><p>字符精度</p><p>笔画或像素精度</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>走样aliasing：用离散量表示连续量引起的失真现象</p><p>反走样antialiasing：用于减少或消除这种效果的技术</p><h3 id="提高分辨率"><a href="#提高分辨率" class="headerlink" title="提高分辨率"></a>提高分辨率</h3><p>把显示器分辨率提高一倍，直线经过两倍像素，锯齿增加一倍，但同时每个阶梯也减少了一倍，显示的直线段看起来平直光滑。方法简单，但不经济，只能减轻而不能消除锯齿问题</p><h3 id="非加权区域采样"><a href="#非加权区域采样" class="headerlink" title="非加权区域采样"></a>非加权区域采样</h3><p>假定每个像素是具有一定面积的小区域，直线段是具有一定宽度的狭长矩形，当直线段与像素有交时，求出两者相交区域的面积，然后根据相交区域面积的大小确定该像素的亮度值</p><p>两个缺点：</p><ul><li>像素的亮度与相交区域的面积成正比，而与相交区域落在像素内的位置无关，这仍然会导致锯齿效应</li><li>直线条上沿理想直线方向的相邻两个像素有时会有较大的灰度差</li></ul><h3 id="加权区域采样"><a href="#加权区域采样" class="headerlink" title="加权区域采样"></a>加权区域采样</h3><p>使相交区域对像素亮度的贡献依赖于该区域与像素中心的距离</p><h2 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h2><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><p>先把屏幕置成背景色，再把物体各个面按离视点的远近进行排序，结果存放在深度优先级表中，按照由远到近的顺序绘制各个面</p><p>优点：原理简单</p><p>缺点：只能处理互不相交的面，而且深度优先级表中面的顺序可能出错，深度排序计算量大</p><h3 id="Z-Buffer算法"><a href="#Z-Buffer算法" class="headerlink" title="Z-Buffer算法"></a>Z-Buffer算法</h3><p>设置帧缓存存放每个像素的颜色值，深度缓存来存放每个像素的深度值。把显示对象的每个面上每一点的属性值填入帧缓冲区相应单元前，要把这点的z坐标值与Z缓冲器中相应单元的值进行比较，只有前者大于后者时才改变帧缓冲区该单元的值，同时Z缓冲器相应单元的值更新</p><p>优点：比总体排序灵活简单，有利于硬件实现</p><p>缺点：占用空间大，没有利用图形的相关性与连续性</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>帧缓存全置为背景色;<br>    深度缓存全置为最小Z值;<br>    <span class="hljs-keyword">for</span>(每一个多边形)&#123;<br>        扫描转换该多边形;<br>        <span class="hljs-keyword">for</span>(该多边形覆盖的每个像素(x,y))&#123;<br>            计算该多边形在该像素的深度值Z(x,y);<br>            <span class="hljs-keyword">if</span>(Z(x,y)大于Z缓存在(x,y)的值)&#123;<br>            把Z(x,y)存入Z缓存中(x,y)处;<br>                把多边形在(x,y)处的颜色值存入帧缓存的(x,y)处;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="改进的Z-Buffer算法"><a href="#改进的Z-Buffer算法" class="headerlink" title="改进的Z-Buffer算法"></a>改进的Z-Buffer算法</h3><p>用一个深度缓存变量zb代替缓存数组。对屏幕上的每个像素，对于每个多边形，若该像素在该多边形内，则计算该多边形在该像素的深度值，找出对应最大深度值的多边形，更新像素属性值</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>帧缓存全置为背景色;<br>    <span class="hljs-keyword">for</span>(屏幕上的每一个像素(x,y))&#123;<br>        深度缓存变量zb置最小值MinValue;<br>        <span class="hljs-keyword">for</span>(每个多边形P)&#123;<br>            <span class="hljs-keyword">if</span>(像素(x,y)在该多边形P_k内)&#123;<br>                计算该多边形在该像素的深度值depth;<br>                <span class="hljs-keyword">if</span>(depth&gt;zb)&#123;<br>            zb=depth;<br>                    index=k;<br>            &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(zb!=MinValue)<br>            计算多边形P_index在像素(x,y)的光照颜色并显示;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第6行的包含性检测可采用射线法或弧长法</p><h3 id="扫描线Z-Buffer算法"><a href="#扫描线Z-Buffer算法" class="headerlink" title="扫描线Z-Buffer算法"></a>扫描线Z-Buffer算法</h3><p>在处理当前扫描线时，开一个一维数组作为当前扫描线的Z-Buffer。首先找出与当前扫描线相关的多边形，以及每个多边形中相关的边对；然后计算边对之间区间上各像素的深度，与Z-Buffer中的值相比较，找出各像素处对应的可见平面，计算颜色，写帧缓存。对深度计算采用增量算法。</p><p>优点：将整个绘图窗口内的消隐问题分解到扫描线上解决，使所需的Z缓冲器大大减小；计算深度时利用了面的连贯性，只用了一个加法</p><p>缺点：被多个多边形覆盖的像素还要进行多次计算，计算量仍然很大</p><p>数据结构：</p><ul><li>多边形Y表：保存所有多边形的序号和其顶点最大y坐标，根据多边形顶点最小y坐标插入到Y表相应位置</li><li>活化多边形表APT：保存与当前扫描线相交的多边形</li><li>边表ET：每个APT中的多边形都有一个边表，存放每条边端点中较大的y值，增量$\Delta x$，y值较小一端的x坐标和z坐标</li><li>活化边对表AET：存放当前多边形中与当前扫描线相交的各边对的信息</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>    建立多边形Y表;<br>    初始化活化多边形表APT，活化边对表AET为空;<br>    <span class="hljs-keyword">for</span>(每条扫描线i)&#123;<br>        帧缓存CB置为背景色;<br>        深度缓存ZB置为负无穷;<br>        将对应扫描线i的Y表中的多边形加入APT中;<br>        生成新加入多边形的边表ET;<br>        对APT中每一个多边形，若其边表ET中对应扫描线i增加了新边，则将新边配对，加入AET中;<br>        对AET中每一个边对:<br>            对xl&lt;j&lt;xr的每一个像素，按增量公式z=z+dz_a计算各点深度depth;<br>        若depth&gt;ZB(j)则令ZB(j)=depth，并计算颜色值写帧缓存;<br>        删除APT中多边形顶点最大y坐标为i的多边形，并删除相应的边;<br>        对AET中每一个边对:<br>        删除y_lmax或y_rmax等于i的边，若一边对中只删除了一边则对该多边形的边重新配对;<br>        用增量公式计算新的x_l,x_r,z_l=z_l+dx_l*dz_a+dz_b;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h3><p>把当前扫描线各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间，只要在区间任一点处找出在该处z值最大的一个面，这个区间上的每一个像素就用这个面的颜色来表示</p><p>优点：在一条扫描线上每个区间只计算一次深度值，并且不需要Z缓冲器</p><h3 id="区域子分割算法（Warnack算法）"><a href="#区域子分割算法（Warnack算法）" class="headerlink" title="区域子分割算法（Warnack算法）"></a>区域子分割算法（Warnack算法）</h3><p>把物体投影到全屏幕窗口上，然后递归分割窗口，直到窗口内目标足够简单，可以显示为止</p><p>如果窗口内没有物体，则按背景色显示；如果窗口内只有一个面，则把该面显示出来；如果窗口内含有两个以上的面，则把窗口等分成4个子窗口，对每个小窗口作上述同样的处理</p><p>窗口与多边形的覆盖关系有4种：内含，相交，包围，分离</p><h3 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h3><p>考查由视点出发穿过观察屏幕的一个像素而射入场景的一条射线，则可确定出场景中与该射线相交的物体。在计算出光线与物体表面的交点后，离像素最近的交点所在面片的颜色为该像素的颜色；如果没有交点，说明没有多边形的投影覆盖此像素，用背景色显示。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(屏幕上的每一像素)&#123;<br>    形成通过该屏幕像素的射线;<br>    <span class="hljs-keyword">for</span>(场景中的每一物体)<br>        将该射线于物体求交;<br>    <span class="hljs-keyword">if</span>(存在交点)<br>        以最近的交点所属的颜色显示像素;<br>    <span class="hljs-keyword">else</span><br>        以背景色显示像素;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-几何造型技术"><a href="#第三章-几何造型技术" class="headerlink" title="第三章 几何造型技术"></a>第三章 几何造型技术</h1><h2 id="曲线的基本概念"><a href="#曲线的基本概念" class="headerlink" title="曲线的基本概念"></a>曲线的基本概念</h2><p>位置矢量</p><p>切矢量</p><p>法矢量</p><p>曲率：弯曲程度，曲线的单位切矢对弧长的转动率</p><p>挠率：扭曲程度，副法线方向对于弧长的转动率</p><h2 id="三次Hermite曲线"><a href="#三次Hermite曲线" class="headerlink" title="三次Hermite曲线"></a>三次Hermite曲线</h2><p>三次曲线的代数形式：$P(t)=a_3t^3+a_2t^2+a_1t+a_0, t\in[0,1]$</p><p>三次曲线的几何形式：用端点位矢$P_0,P_1$，切矢$P’_0,P’_1$表示</p><p>代入<strong>推导(……)</strong>，几何系数是$P_0,P_1,P’_0,P’_1$，调和函数是$F_0, F_1, G_0, G_1$</p><script type="math/tex; mode=display">P(t)=F_0P_0+F_1P_1+G_0P'_0+G_1P'_1, t\in[0,1]</script><p>矩阵化表达</p><script type="math/tex; mode=display">P(t)=\left( \begin{matrix}P_0 & P_1 & P'_0 & P'_1\end{matrix}\right)\left( \begin{matrix}F_0 \\ F_1 \\ G_0 \\ G_1\end{matrix}\right)=\left( \begin{matrix}P_0 & P_1 & P'_0 & P'_1\end{matrix}\right)\left( \begin{matrix}2 & -3 & 0 & 1\\-2 & 3 & 0 & 0\\1 & -2 & 1 & 0\\1 & -1 & 0 & 0\\\end{matrix}\right)\left( \begin{matrix}t^3 \\ t^2 \\ t \\ 1\end{matrix}\right)\\</script><h2 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h2><script type="math/tex; mode=display">P(t)=\sum_{i=0}^nP_iC_n^it^i(1-t)^{n-i},t\in[0,1]</script><p>性质：</p><ul><li><p>端点性质</p><ul><li><p>起点终点与对应的特征多边形的起点终点重合</p></li><li><p>端点切向量$P’(t)=n\sum_{i=1}^{n-1}P_i[B_{i-1,n-1}(t)-B_{i,n-1}(t)]$</p><p>起点终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致</p></li></ul></li><li><p>对称性：曲线的起点终点处几何性质一样</p></li><li><p>凸包性：曲线落在$P_i$构成的凸包之中</p></li><li><p>几何不变性：曲线的位置和形状不依赖坐标系的选择</p></li><li><p>变差缩减性：平面内任意直线与$P(t)$的交点个数不多于该直线与其特征多边形的交点个数，反映了bezier曲线比特征多边形的折线更光顺</p></li><li><p>仿射不变性：在仿射变换下，$P(t)$的形式不变</p></li></ul><p>de Casteljau算法：</p><script type="math/tex; mode=display">P_i^k=\begin{cases}P_i,&k=0\\(1-t)P_i^{k-1}+tP_{i+1}^{k-1},&k=1,2,...,n,i=0,1,...,n-k\end{cases}</script><p>升阶：保持Bezier曲线的形状与定向不变，增加定义它的控制顶点数</p><script type="math/tex; mode=display">P_i^*=\frac{i}{n+1}P_{i-1}+(1-\frac{i}{n+1})P_i\\i=0,1,...,n+1</script><p>不足：</p><ul><li>Bezier曲线不能做局部修改</li><li>Bezier曲线的拼接比较复杂</li></ul><h2 id="B样条"><a href="#B样条" class="headerlink" title="B样条"></a>B样条</h2><p>k阶（k-1次）B样条曲线的定义为：</p><script type="math/tex; mode=display">P(t)=\sum_{i=0}^n P_iN_{i,k}(t) \\t\in[t_{k-1},t_{n+1}]</script><p>de Boor算法：</p><p>给定控制顶点$P_i(i=0,1,…,n)$和节点矢量$T=[t_0,t_1,…,t_{n+k}]$，定义k阶（k-1次）B样条曲线</p><script type="math/tex; mode=display">t\in[t_j,t_{j+1}](k-1\le j\le n)\\P_i^r(t)=\begin{cases}P_i,&r=0;\\&i=j-k+1,j-k+2,...,j\\\frac{t-t_i}{t_{i+k-r}-t_i}P_i^{r-1}(t)+\frac{t_{i+k-r}-t}{t_{i+k-r}-t_i}P_{i-1}^{r-1}(t),&r=1,2,..,k-1;\\&i=j-k+r+1,j-k+r+2,...,j\end{cases}\\P(t)=P_j^{k-1}(t)</script><p>三次B样条的Bezier表示：</p><p>在区间$[t_j,t_{j+1}]$上的B样条曲线，如表示成三次Bezier曲线，则控制顶点为：</p><script type="math/tex; mode=display">P_{j-1}^{[2]}(t_j),P_{j-1}^{[1]}(t_j),P_{j-1}^{[1]}(t_{j+1}),P_{j}^{[2]}(t_{j+1})</script><script type="math/tex; mode=display">P(t)=\sum_{i=j-3}^j P_iN_{i,4}(t)\\=P_{j-1}^{[2]}(t_j)B_{0,3}(\frac{t-t_j}{\Delta t_j})+P_{j-1}^{[1]}(t_j)B_{1,3}(\frac{t-t_j}{\Delta t_j})+P_{j-1}^{[1]}(t_{j+1})B_{2,3}(\frac{t-t_j}{\Delta t_j})+P_{j}^{[2]}(t_{j+1})B_{3,3}(\frac{t-t_j}{\Delta t_j})</script><h2 id="三角网格"><a href="#三角网格" class="headerlink" title="三角网格"></a>三角网格</h2><h3 id="半边表示"><a href="#半边表示" class="headerlink" title="半边表示"></a>半边表示</h3><p>把一条无向的边拆分成两条有向的半边，半边的方向在模型中总是沿着逆时针方向</p><p>每条半边需要存储的信息：</p><ul><li>该半边的源顶点<code>origin(e)</code></li><li>该半边在同一三角形中的下一半边<code>next(e)</code></li><li>与该半边同属一条边的对边<code>opposite(e)</code></li><li>该半边所属的面<code>IncFace(e)</code></li></ul><h3 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h3><p>三种基本化简操作：顶点删除、边压缩、面片收缩</p><h3 id="网格细分"><a href="#网格细分" class="headerlink" title="网格细分"></a>网格细分</h3><p>Loop细分方法：第一步增加顶点，第二步调整顶点位置使网格更加平滑</p><h1 id="第四章-真实感图形学"><a href="#第四章-真实感图形学" class="headerlink" title="第四章 真实感图形学"></a>第四章 真实感图形学</h1><h2 id="颜色的特性"><a href="#颜色的特性" class="headerlink" title="颜色的特性"></a>颜色的特性</h2><p>心理学和视觉的角度：色调(hue)、饱和度(saturation)、亮度(lightness)</p><p>光学物理学的角度：主波长、纯度、明度</p><h2 id="三色学说"><a href="#三色学说" class="headerlink" title="三色学说"></a>三色学说</h2><p>是真实感图形学的生理视觉基础，是颜色视觉中最基础、最根本的理论</p><h2 id="CIE色度图"><a href="#CIE色度图" class="headerlink" title="CIE色度图"></a>CIE色度图</h2><p>马蹄形区域</p><h2 id="常见的颜色模型"><a href="#常见的颜色模型" class="headerlink" title="常见的颜色模型"></a>常见的颜色模型</h2><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>用于彩色光栅图形显示设备，采用红、绿、蓝为原色，面向硬件</p><p>三维直角坐标系，单位立方体来表示，原点为黑色，从黑色中加入某种颜色</p><h3 id="CMY"><a href="#CMY" class="headerlink" title="CMY"></a>CMY</h3><p>用于印刷行业，采用青(Cyan)、品红(Magenta)、黄(Yellow)为原色，面向硬件</p><p>减性原色系统，单位立方体，原点为白色，在白色中减去某种颜色</p><h3 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h3><p>面向用户，对应于画家的配色方法，圆锥形</p><h2 id="写出Phong模型公式，并指出其中各个参数的含义"><a href="#写出Phong模型公式，并指出其中各个参数的含义" class="headerlink" title="写出Phong模型公式，并指出其中各个参数的含义"></a>写出Phong模型公式，并指出其中各个参数的含义</h2><p>环境光ambient + 漫反射光diffuse + 镜面反射光specular</p><p><img src="https://img-blog.csdnimg.cn/20190502153628116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FqaDU2MDY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;"></p><script type="math/tex; mode=display">I=I_aK_a+I_pK_d(L\cdot N)+I_pK_s(R\cdot V)^n\\R=2N(L\cdot N)-L</script><p>$I_a$——环境光强度</p><p>$K_a$——物体对环境光的反射系数</p><p>$I_p$——入射光强度</p><p>$K_d$——物体的漫反射系数</p><p>$L$——光源方向单位向量</p><p>$N$——物体法向量</p><p>$K_s$——物体的镜面反射系数</p><p>$R$——反射方向单位向量</p><p>$V$——视线方向单位向量</p><p>$n$——镜面反射指数</p><h2 id="Gouraud明暗处理"><a href="#Gouraud明暗处理" class="headerlink" title="Gouraud明暗处理"></a>Gouraud明暗处理</h2><ol><li>计算多边形顶点的平均法向 相邻多边形的平均法向</li><li>用Phong光照明模型计算顶点的平均光强</li><li>插值计算离散边上的各点光强</li><li>插值计算多边形内域中各点的光强</li></ol><p>优点：能有效地显示漫反射效果，计算量小</p><p>缺点：镜面发射效果不理想，相邻多边形边界处的马赫带效应不能完全消除</p><h2 id="Phong明暗处理"><a href="#Phong明暗处理" class="headerlink" title="Phong明暗处理"></a>Phong明暗处理</h2><ol><li>计算多边形顶点的平均法向</li><li>插值计算离散边上的各点法向</li><li>插值计算多边形内域中各点的法向</li><li>用Phong光照明模型计算各点的光强</li></ol><p>优点：可以产生正确的高光区域</p><p>缺点：计算量大</p><h2 id="针对多面体模型，直接用Phong模型绘制会有什么问题？"><a href="#针对多面体模型，直接用Phong模型绘制会有什么问题？" class="headerlink" title="针对多面体模型，直接用Phong模型绘制会有什么问题？"></a>针对多面体模型，直接用Phong模型绘制会有什么问题？</h2><p>由于光源和视点都被假定为无穷远，且每一个多边形由于法向一致，所以多边形内部像素的颜色都是相同的，因此在不同法向的多边形邻接处不仅有光强突变还会产生马赫带效应</p><h2 id="两种增量式光照明模型的基本思想及算法区别"><a href="#两种增量式光照明模型的基本思想及算法区别" class="headerlink" title="两种增量式光照明模型的基本思想及算法区别"></a>两种增量式光照明模型的基本思想及算法区别</h2><p>在每一个多边形的顶点处计算合适的光照明强度或其他参数，然后在各个多边形内部进行均匀插值，最后得到多边形的光滑颜色分布</p><p>Gouraud明暗处理采用光强插值，Phong明暗处理采用法向插值</p><h2 id="局部光照明模型"><a href="#局部光照明模型" class="headerlink" title="局部光照明模型"></a>局部光照明模型</h2><script type="math/tex; mode=display">I_r=I_aK_a+I_i(N\cdot L)d\omega (K_dR_d+K_sR_s)</script><p>与简单光照模型比较的优点：</p><ol><li>是基于入射光能量导出的光辐射模型，更具有理论基础</li><li>可以反映表面的粗糙度对反射光强的影响</li><li>可以根据材料的物理性质决定颜色</li><li>可以改进简单光照模型的失真现象</li><li>可以模拟金属的光泽</li></ol><h2 id="整体光照明模型—光线跟踪算法"><a href="#整体光照明模型—光线跟踪算法" class="headerlink" title="整体光照明模型—光线跟踪算法"></a>整体光照明模型—光线跟踪算法</h2><p>终止条件：</p><ul><li>该光线未碰到任何物体</li><li>该光线碰到了背景</li><li>光线在经过多次反射和折射后衰减，光线对于视点的光强贡献很小</li><li>光线反射或折射次数大于给定值</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">RayTracing(start, direction, weight, color)&#123;<br><span class="hljs-comment">//光线起点start 光线方向direction 光线衰减权值weight 返回光线方向上的颜色值color</span><br>    <span class="hljs-keyword">if</span>(weight &lt; MinWeight)<br>        color = black;<br>    <span class="hljs-keyword">else</span>&#123;<br>    计算光线与所有物体的交点中离start最近的点;<br>        <span class="hljs-keyword">if</span>(没有交点)<br>            color = black;<br>        <span class="hljs-keyword">else</span>&#123;<br>            I_local = 在交点处用局部光照模型计算出的光强;<br>            计算反射方向R = <span class="hljs-number">2</span>N(L*N)-L;<br>            RayTracing(最近的交点, R, weight*w_r, I_r);<br>            计算折射方向T;<br>            RayTracing(最近的交点, T, weight*<span class="hljs-keyword">w_t</span>, I_t);<br>            color = I_local + K_sI_r + K_tI_t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>加速方法：自适应深度控制；包围盒及层次结构；三维DDA算法；空间八叉树剖分技术</p><h2 id="包围盒"><a href="#包围盒" class="headerlink" title="包围盒"></a>包围盒</h2><p>基本思想：用体积稍大且特性简单的集合体来近似代替复杂的几何对象</p><h3 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h3><p>包含该对象，且边平行于坐标轴的最小六面体。六个标量即可表示$(x_{min},y_{min},z_{min})(x_{max},y_{max},z_{max})$。</p><p>不随物体旋转，紧密性差。</p><h3 id="OBB"><a href="#OBB" class="headerlink" title="OBB"></a>OBB</h3><p>包围盒无需和坐标轴垂直，根据物体表面的顶点，通过PCA获得特征向量，即OBB的主轴。具有方向性，可以旋转。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="二维图形的几何变换"><a href="#二维图形的几何变换" class="headerlink" title="二维图形的几何变换"></a>二维图形的几何变换</h2><p>平移变换</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & t_x\\0 & 1 & t_y\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\1\end{matrix}\right]</script><p>旋转变换（逆时针）</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & -\sin\theta & 0\\\sin\theta & \cos\theta & 0\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\1\end{matrix}\right]</script><p>关于$(x_f,y_f)$点的旋转变换：需要先将该点移到坐标原点处，然后再进行旋转变换，最后将该点移回原来的位置</p><script type="math/tex; mode=display">T(x_f,y_f)\cdot R(\theta)\cdot T(-x_f,-y_f)=\left[ \begin{matrix}1 & 0 & x_f\\0 & 1 & y_f\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}\cos\theta & -\sin\theta & 0\\\sin\theta & \cos\theta & 0\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}1 & 0 & -x_f\\0 & 1 & -y_f\\0 & 0 & 1\\\end{matrix}\right]</script><h2 id="三维图形的几何变换"><a href="#三维图形的几何变换" class="headerlink" title="三维图形的几何变换"></a>三维图形的几何变换</h2><p>绕x轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & 0 & 0\\0 & \cos\theta & -\sin\theta & 0\\0 & \sin\theta & \cos\theta & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕y轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & 0 & \sin\theta & 0\\0 & 1 & 0 & 0\\-\sin\theta & 0 & \cos\theta & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕z轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & -\sin\theta & 0 & 0\\\sin\theta & \cos\theta & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕任意轴AB旋转</p><ul><li>将A点移到坐标原点</li><li>使AB分别绕x轴、y轴旋转与z轴重合</li><li>将AB绕z轴旋转$\theta$角</li><li>作上述变换的逆操作，使AB回到原来位置</li></ul><h2 id="矩形求交"><a href="#矩形求交" class="headerlink" title="矩形求交"></a>矩形求交</h2><p>给定两个矩形A和B，矩形A的左上角坐标为$(x_{a1},y_{a1})$，右下角坐标为$(x_{a2},y_{b2})$；矩形B的左上角坐标为$(x_{b1},y_{b1})$，右下角坐标为$(x_{b2},y_{b2})$。</p><p>假设两矩形相交区域为矩形C，左上角坐标为$(x_{c1},y_{c1})$，右下角坐标为$(x_{c2},y_{c2})$</p><p>分析相交情况可知</p><script type="math/tex; mode=display">x_{c1}=max(x_{a1},x_{b1})\\y_{c1}=min(y_{a1},y_{b1})\\x_{c2}=min(x_{a2},y_{b2})\\y_{c2}=max(y_{a2},y_{b2})</script><p>若要相交则$\begin{cases}x_{c1}<x_{c2}\\y_{c1}>y_{c2}\end{cases}$，即</x_{c2}\\y_{c1}></p><script type="math/tex; mode=display">\begin{cases}max(x_{a1},x_{b1})<min(x_{a2},x_{b2})\\min(y_{a1},y_{b1})>max(y_{a2},y_{b2})\\\end{cases}</script><h2 id="线面求交"><a href="#线面求交" class="headerlink" title="线面求交"></a>线面求交</h2><p>圆柱面</p><script type="math/tex; mode=display">x^2+y^2=r^2</script><p>线的参数方程$x=x(t),y=y(t),z=z(t)$</p><p>代入解方程t</p><h2 id="判断点在多边形内部"><a href="#判断点在多边形内部" class="headerlink" title="判断点在多边形内部"></a>判断点在多边形内部</h2><p>根据向量叉乘，按照逆时针（顺时针）取向量进行叉乘，所得值同号，则说明点在多边形内部。</p><p>即判断方式为：取向量AB和AP、BC和BP、CD和CP、DE和DP、EA和EP进行叉乘，判断所得值是否同号。</p><p><img src="https://img-blog.csdnimg.cn/20200113093410275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdV9mZW5nX3ppXw==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;"></p><h2 id="三角形相关"><a href="#三角形相关" class="headerlink" title="三角形相关"></a>三角形相关</h2><p>已知三角形三顶点A$(x_1,y_1)$，B$(x_2,y_2)$，C$(x_3,y_3)$</p><p>$\vec{AB}=(x_2-x_1,y_2-y_1,z_2-z_1)$，$\vec{AC}=(x_3-x_1,y_3-y_1,z_3-z_1)$</p><h3 id="单位法向量"><a href="#单位法向量" class="headerlink" title="单位法向量"></a>单位法向量</h3><p>$\frac{\vec{AB}\times\vec{AC}}{|{\vec{AB}\times\vec{AC}}|}$</p><h3 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h3><p>$\frac{1}{2}|\vec{AB}||\vec{AC}|\sin\theta=\frac{1}{2}|\vec{AB}\times\vec{AC}|$</p><h3 id="两个三角形是否相交"><a href="#两个三角形是否相交" class="headerlink" title="两个三角形是否相交"></a>两个三角形是否相交</h3><p>设两个三角形$T_1,T_2$，所在平面分别为$\pi_1,\pi_2$</p><ul><li><p>计算$T_1$每个顶点到$\pi_2$的距离，若同号则$T_1$在$\pi_2$一边，两三角形不相交</p></li><li><p>计算$T_2$每个顶点到$\pi_1$的距离，若同号则$T_2$在$\pi_1$一边，两三角形不相交</p></li><li><p>否则可能相交，计算$T_1$和$\pi_2$的交线$l_1$，$T_2$和$\pi_1$的交线$l_2$</p><p>若$l_1$和$l_2$有重叠，则两三角形相交；否则不相交</p></li></ul><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><h3 id="世界坐标到观察坐标"><a href="#世界坐标到观察坐标" class="headerlink" title="世界坐标到观察坐标"></a>世界坐标到观察坐标</h3><ul><li><p>原点平移矩阵</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & 0 & -x_0\\0 & 1 & 0 & -y_0\\0 & 0 & 1 & -z_0\\0 & 0 & 0 & 1\\\end{matrix} \right]</script></li><li><p>旋转矩阵（单位矢量法）</p><ul><li>取观察坐标系的z轴方向为观察平面的法向，单位化得$n=(n_x,n_y,n_z)$</li><li>取观察坐标系的x轴方向为观察方向，单位化得$u=(u_x,u_y,u_z)$</li><li>取观察坐标系的y轴方向的单位矢量，或直接计算得$v=n\times u=(v_x,v_y,v_z)$</li></ul><script type="math/tex; mode=display">\left[ \begin{matrix}u_x & v_x & n_x & 0\\u_y & v_y & n_y & 0\\u_z & v_z & n_z & 0\\0 & 0 & 0 & 1\\\end{matrix} \right]</script></li></ul><h3 id="一点透视"><a href="#一点透视" class="headerlink" title="一点透视"></a>一点透视</h3><p>假定视点位置为 (0,-2,0)，沿y轴正方向投影，投影面与y轴垂直并经过点 (0,1,0)</p><p>  (a) 请写出点 (2, 2, 2) 经过透视投影后的坐标。</p><p>  (b) 请写出投影矩阵。</p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p>Bresenham与中点画线法相比的改进</p><p>灭点个数</p><p>曲线参数方程</p><p>Phong明暗处理中代价最高的步骤</p><p>颜色代码000000为什么颜色</p><h2 id="简答计算题"><a href="#简答计算题" class="headerlink" title="简答计算题"></a>简答计算题</h2><p>多边形的扫描填充伪代码</p><p>简述面消隐的各种算法</p><p>Phong光照模型公式及示意图，反射方向R的推导</p><p>对称变换矩阵</p><p>空间中一正方形和一多边形求交</p><p>给定控制点求Bezier曲线方程，转换为B-Spline的新控制点，转换为Hermite曲线的端点和切矢</p><p>给定视点、投影面，在世界坐标与观察坐标下的投影矩阵</p>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU操作系统复习笔记</title>
    <link href="/2022/01/15/OSreview/"/>
    <url>/2022/01/15/OSreview/</url>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="操作系统-operating-system"><a href="#操作系统-operating-system" class="headerlink" title="操作系统 operating system"></a>操作系统 operating system</h3><p>操作系统是为应用程序提供运行环境的资源管理软件</p><h3 id="虚拟机-virtual-machine"><a href="#虚拟机-virtual-machine" class="headerlink" title="虚拟机 virtual machine"></a>虚拟机 virtual machine</h3><p>通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p><h3 id="运行时系统-runtime-system"><a href="#运行时系统-runtime-system" class="headerlink" title="运行时系统 runtime system"></a>运行时系统 runtime system</h3><p>编译程序除了把用户程序中的语句翻译成机器代码外，还要为用户程序的运行提供管理工作，这部分代码就是运行时系统</p><h3 id="装入程序-loader"><a href="#装入程序-loader" class="headerlink" title="装入程序 loader"></a>装入程序 loader</h3><p>将装入模块装入内存的程序，实现虚拟地址到内存地址的映射，分为绝对装入、静态重定位、动态重定位</p><h3 id="运行栈-execution-stack"><a href="#运行栈-execution-stack" class="headerlink" title="运行栈 execution stack"></a>运行栈 execution stack</h3><p>存放有关正在运行的子程序消息的栈，存放子程序的返回地址、传递给子程序的参数、局部运行环境</p><h3 id="系统调用-system-call"><a href="#系统调用-system-call" class="headerlink" title="系统调用 system call"></a>系统调用 system call</h3><p>操作系统提供给用户程序的一组接口，用于获取内核提供的服务</p><h3 id="应用程序接口-API"><a href="#应用程序接口-API" class="headerlink" title="应用程序接口 API"></a>应用程序接口 API</h3><p>由操作系统或高级语言提供，为应用程序提供跨平台的I/O服务</p><h3 id="特权指令-privileged-instruction"><a href="#特权指令-privileged-instruction" class="headerlink" title="特权指令 privileged instruction"></a>特权指令 privileged instruction</h3><p>能对系统中关键资源进行操作的指令，为保证计算机系统的安全可靠特权指令只能在核心态下使用</p><h3 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程 thread"></a>线程 thread</h3><p>程序在虚拟CPU上的执行过程，是操作系统能够进行调度的最小单位。</p><h3 id="线程控制块-TCB"><a href="#线程控制块-TCB" class="headerlink" title="线程控制块 TCB"></a>线程控制块 TCB</h3><p>操作系统描述和管理线程的数据结构</p><h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程 process"></a>进程 process</h3><p>一组线程及其所依赖的虚拟运行环境，是操作系统进行资源分配的最小单位。</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>操作系统描述和管理进程的数据结构。主要内容有线程TCB、资源描述、虚实资源映射关系、进程的档案</p><h3 id="多线程进程"><a href="#多线程进程" class="headerlink" title="多线程进程"></a>多线程进程</h3><p>进程中可以包含多个线程，所有线程共享进程的虚拟运行环境，进程内线程之间并发执行，每个线程有自己的线程控制块、运行栈</p><h3 id="僵尸进程-zombie-process"><a href="#僵尸进程-zombie-process" class="headerlink" title="僵尸进程 zombie process"></a>僵尸进程 zombie process</h3><p>子进程已经结束，但父进程并不执行wait()为子进程释放资源</p><h3 id="孤儿进程-orphan-process"><a href="#孤儿进程-orphan-process" class="headerlink" title="孤儿进程 orphan process"></a>孤儿进程 orphan process</h3><p>父进程已经退出，剩下的子进程被init进程收留</p><h3 id="进程上下文-process-context"><a href="#进程上下文-process-context" class="headerlink" title="进程上下文 process context"></a>进程上下文 process context</h3><p>进程执行活动全过程的静态描述，包括用户进程传递给内核的参数、CPU的所有寄存器中的值、进程的状态以及堆栈内容</p><h3 id="CPU调度器-scheduler"><a href="#CPU调度器-scheduler" class="headerlink" title="CPU调度器 scheduler"></a>CPU调度器 scheduler</h3><p>按调度算法选择一个就绪线程并将CPU分配给它运行，是操作系统中关键的程序模块</p><h3 id="抢占式调度-preemptive-scheduling"><a href="#抢占式调度-preemptive-scheduling" class="headerlink" title="抢占式调度 preemptive scheduling"></a>抢占式调度 preemptive scheduling</h3><p>进程还没有执行完成就被剥夺CPU，切换执行其他的进程</p><h3 id="对换技术-swapping"><a href="#对换技术-swapping" class="headerlink" title="对换技术 swapping"></a>对换技术 swapping</h3><p>内存空间紧张时，将内存中某些进程暂时调出到外存，腾出足够的内存空间后把具备运行条件的进程调入内存</p><h3 id="多道程序设计-multiprogramming"><a href="#多道程序设计-multiprogramming" class="headerlink" title="多道程序设计 multiprogramming"></a>多道程序设计 multiprogramming</h3><p>允许多个程序同时装入计算机内存中，在管理程序控制下宏观上并行、微观上串行</p><h3 id="请求调页-demand-paging"><a href="#请求调页-demand-paging" class="headerlink" title="请求调页 demand paging"></a>请求调页 demand paging</h3><p>执行一个进程前仅将PCB装入内存，程序和数据并没有实际装入内存；程序执行过程中，如果访问到的页还没有装入内存就通过缺页异常处理将其装入内存</p><h3 id="局部模式-locality-model"><a href="#局部模式-locality-model" class="headerlink" title="局部模式 locality model"></a>局部模式 locality model</h3><p>进程执行过程中，其访问的内存空间从一个局部迁移到另一个局部，这种运行方式被称为局部模式</p><h3 id="颠簸-thrashing"><a href="#颠簸-thrashing" class="headerlink" title="颠簸 thrashing"></a>颠簸 thrashing</h3><p>在页面置换过程中频繁的页面调度导致CPU利用率极低的现象</p><h3 id="工作集-working-model"><a href="#工作集-working-model" class="headerlink" title="工作集 working model"></a>工作集 working model</h3><p>进程在某个时刻t之前$\Delta$次访问中所访问页的集合</p><h3 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区 critical section"></a>临界区 critical section</h3><p>进程中访问临界资源的代码段，临界区不能并发执行</p><h3 id="字符设备-character-device"><a href="#字符设备-character-device" class="headerlink" title="字符设备 character device"></a>字符设备 character device</h3><p>指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等，数据没有地址</p><h3 id="块设备-block-device"><a href="#块设备-block-device" class="headerlink" title="块设备 block device"></a>块设备 block device</h3><p>将信息存储在固定大小的块中，每个块都有自己的地址，I/O传输过程中以块为单位</p><h3 id="物理格式化-physical-formatting"><a href="#物理格式化-physical-formatting" class="headerlink" title="物理格式化 physical formatting"></a>物理格式化 physical formatting</h3><p>将磁盘划分出一系列同心圆磁道，各个磁道划分为扇区</p><h3 id="逻辑格式化-logical-formatting"><a href="#逻辑格式化-logical-formatting" class="headerlink" title="逻辑格式化 logical formatting"></a>逻辑格式化 logical formatting</h3><p>在磁盘上建立一个空文件系统，使操作系统对其进行后续文件读写的过程</p><h3 id="磁盘冗余阵列-RAID"><a href="#磁盘冗余阵列-RAID" class="headerlink" title="磁盘冗余阵列 RAID"></a>磁盘冗余阵列 RAID</h3><p>通过在多个磁盘上存储相同的数据改善性能、增加可靠性的技术</p><h3 id="设备驱动程序-device-driver"><a href="#设备驱动程序-device-driver" class="headerlink" title="设备驱动程序 device driver"></a>设备驱动程序 device driver</h3><p>直接控制设备的程序</p><h3 id="设备依赖的-device-dependent"><a href="#设备依赖的-device-dependent" class="headerlink" title="设备依赖的 device-dependent"></a>设备依赖的 device-dependent</h3><p>指程序只能在特定的设备环境下运行，也称设备相关的</p><h3 id="中断服务例程-ISR"><a href="#中断服务例程-ISR" class="headerlink" title="中断服务例程 ISR"></a>中断服务例程 ISR</h3><p>驱动程序的一部分，处理中断信号，检查自己负责的设备是否发出中断以处理中断事件</p><h3 id="假脱机-SPOOLing"><a href="#假脱机-SPOOLing" class="headerlink" title="假脱机 SPOOLing"></a>假脱机 SPOOLing</h3><p>外围设备同时联机操作，是低速I/O设备与主机交换的一种技术。利用程序模拟脱机输入输出技术中外围控制机的功能，提高了输入输出速度、将独占设备改造为共享设备、实现了虚拟设备的功能</p><h3 id="守护进程-daemon"><a href="#守护进程-daemon" class="headerlink" title="守护进程 daemon"></a>守护进程 daemon</h3><p>开机时启动，后台运行，无交互，直至关机</p><h3 id="文件-file"><a href="#文件-file" class="headerlink" title="文件 file"></a>文件 file</h3><p>由操作系统管理的、存储在外存上的、数据的逻辑单元，位程序提供了按名存取的外存使用模式</p><h3 id="索引节点-i-node"><a href="#索引节点-i-node" class="headerlink" title="索引节点 i-node"></a>索引节点 i-node</h3><p>存放文件属性和文件的位置，每个文件有唯一的索引节点号。整个系统有一个索引节点表，存放全部文件属性和位置</p><h3 id="文件分配表-FAT"><a href="#文件分配表-FAT" class="headerlink" title="文件分配表 FAT"></a>文件分配表 FAT</h3><p>用于文件的链接分配，每个磁盘有一张文件分配表FAT，行号对应块号，每个FAT表项中存放对应磁盘块的下一块链接指针</p><h3 id="文件共享-file-sharing"><a href="#文件共享-file-sharing" class="headerlink" title="文件共享 file sharing"></a>文件共享 file sharing</h3><p>在不同的目录下访问同一个文件；不同的进程访问同一个文件</p><h3 id="保护域-protection-domain"><a href="#保护域-protection-domain" class="headerlink" title="保护域 protection domain"></a>保护域 protection domain</h3><p>对一组对象访问权限的集合{(对象，操作), …}，表示一种身份</p><h3 id="访问矩阵-Access-Matrix"><a href="#访问矩阵-Access-Matrix" class="headerlink" title="访问矩阵 Access Matrix"></a>访问矩阵 Access Matrix</h3><p>定义了系统中所有的保护域</p><h3 id="访问控制表-ACL"><a href="#访问控制表-ACL" class="headerlink" title="访问控制表 ACL"></a>访问控制表 ACL</h3><p>从文件的角度描述用户的权限，访问矩阵按列压缩</p><h3 id="用户权限表-Capability-List"><a href="#用户权限表-Capability-List" class="headerlink" title="用户权限表 Capability List"></a>用户权限表 Capability List</h3><p>从用户的角度描述对文件的操作，访问矩阵按行压缩</p><h3 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 VFS"></a>虚拟文件系统 VFS</h3><p>是物理文件系统与服务之间的一个接口层，为各类文件系统提供了一个统一的操作界面和应用编程接口</p><h3 id="同步-synchronization"><a href="#同步-synchronization" class="headerlink" title="同步 synchronization"></a>同步 synchronization</h3><p>并发环境下，保持操作之间偏序关系的行为</p><h3 id="互斥-mutual-exclusion"><a href="#互斥-mutual-exclusion" class="headerlink" title="互斥 mutual exclusion"></a>互斥 mutual exclusion</h3><p>某一资源同时只允许一个访问者对其进行访问</p><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量 semaphore"></a>信号量 semaphore</h3><p>同步工具，通过PV原子操作控制多线程对共享资源的访问</p><h3 id="管程-monitor"><a href="#管程-monitor" class="headerlink" title="管程 monitor"></a>管程 monitor</h3><p>由高级语言提供的同步方法，将共享变量及对其的所有操作封装在一个对象中，通过每次只允许一个进程在管程内部执行实现进程的互斥，通过设置条件变量及等待、唤醒操作实现进程的同步</p><h3 id="竞争条件-race-condition"><a href="#竞争条件-race-condition" class="headerlink" title="竞争条件 race condition"></a>竞争条件 race condition</h3><p>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题</p><h3 id="安全状态-safe-state"><a href="#安全状态-safe-state" class="headerlink" title="安全状态 safe state"></a>安全状态 safe state</h3><p>系统能按安全序列P1, P2, …, Pn的顺序为每个进程分配其所需的全部资源，使每个进程都能顺利完成，则称系统处于安全状态</p><h2 id="简答论述"><a href="#简答论述" class="headerlink" title="简答论述"></a>简答论述</h2><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><ul><li><p>简单结构</p><ul><li>无核：操作系统内核和应用程序的权限没有区分</li><li>单核：全部内核代码运行在同一个地址空间中，权限相同</li></ul></li><li><p>分层</p><p>系统分成若干层，每层建立在底层基础上，只能高层程序调用低层的程序</p></li><li><p>微内核</p><p>讲内核功能尽量从内核空间移到用户空间，内核尽量小</p><p>更容易扩充、移植，更可靠，更安全；内核与核外程序之间的通信降低性能</p></li><li><p>模块化</p><p>使用面向对象的技术，模块之间通过接口通信</p></li></ul><h3 id="内核、应用程序与用户的关系"><a href="#内核、应用程序与用户的关系" class="headerlink" title="内核、应用程序与用户的关系"></a>内核、应用程序与用户的关系</h3><p>内核为应用程序运行提供管理和服务</p><p>内核和用户无直接关系，用户感觉不到内核的存在</p><p>用户直接/间接执行应用程序</p><h3 id="系统调用的工作机制及其参数传递方法"><a href="#系统调用的工作机制及其参数传递方法" class="headerlink" title="系统调用的工作机制及其参数传递方法"></a>系统调用的工作机制及其参数传递方法</h3><p>工作机制</p><ul><li>正在运行的进程先传递系统调用参数，然后由陷入（trap）指令负责将用户态转化为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核服务程序，最后返回用户态。</li></ul><p>参数传递方法</p><ul><li>通过寄存器传递参数</li><li>若参数数量比寄存器多，参数通常存在内存的块和表中，并将块的地址通过寄存器来传递</li><li>参数通过程序压入堆栈中，通过操作系统弹出</li></ul><h3 id="逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）"><a href="#逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）" class="headerlink" title="逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）"></a>逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）</h3><ul><li><p>编译时（绝对装入）：编译时就知道程序将在内存中的驻留位置，则可以生成绝对代码</p><p>执行速度快</p><p>只适用于单道程序的运行环境</p></li><li><p>加载时（静态重定位）：装入时对地址进行重定位，地址变换在装入时一次性完成</p><p>适用于多道程序的运行环境</p><p>作业装入时需要分配所有要求的内存空间，一旦进入内存不能移动和申请空间</p></li><li><p>执行时（动态重定位）：程序要执行时才进行地址转换</p><p>可以把程序放在不连续的存储区中；程序运行前只装入部分代码即可运行；便于程序段的共享</p><p>需要硬件支持：基地址寄存器、限长寄存器、MMU</p></li></ul><h3 id="进程转换图"><a href="#进程转换图" class="headerlink" title="进程转换图"></a>进程转换图</h3><p><img src="/2022/01/15/OSreview/Users\31\AppData\Roaming\Typora\typora-user-images\image-20211213182347015.png" alt="image-20211213182347015"></p><h3 id="进程与线程的区别和联系"><a href="#进程与线程的区别和联系" class="headerlink" title="进程与线程的区别和联系"></a>进程与线程的区别和联系</h3><p>一个线程只能属于一个进程，而一个线程可以有多个线程且至少有一个线程</p><p>线程是操作系统最小的调度单位，进程是操作系统最小的资源分配单位</p><p>同一进程的所有线程共享该进程的所有资源</p><p>同一进程的多个线程共享代码段、数据段、堆，但每个线程拥有自己的栈段</p><p>同一进程的线程可以并发执行，进一步提高资源利用率和系统吞吐量</p><p>对于系统创建/撤销/切换的开销，进程大于线程</p><h3 id="用户级线程和内核级线程及关系"><a href="#用户级线程和内核级线程及关系" class="headerlink" title="用户级线程和内核级线程及关系"></a>用户级线程和内核级线程及关系</h3><p>用户级线程：线程的管理由用户程序（线程库）控制。非抢占式，线程切换速度快，对于操作系统内核透明，若一个线程阻塞则导致整个进程阻塞 ，不适用于多CPU</p><p>内核级线程：线程的管理（创建、撤销、调度）需要由内核控制。可以抢占，切换代价高，若一个线程阻塞则不会影响进程中其他线程的运行，适用于多CPU</p><p>多对一：程序创建的所有线程为用户级线程</p><p>一对一：程序创建的所有线程为内核级线程</p><p>多对多：多个内核级线程共同分担多个用户级线程的任务</p><h3 id="一个进程中能否既有内核级线程又有用户级线程"><a href="#一个进程中能否既有内核级线程又有用户级线程" class="headerlink" title="一个进程中能否既有内核级线程又有用户级线程"></a>一个进程中能否既有内核级线程又有用户级线程</h3><p>当采用多对多方式时，一个进程中既有内核级线程又有用户级线程。每个进程有自己的内核线程池，运行时库分派并标记可运行的用户级线程为准备好执行的线程，操作系统选择用户线程并将它映射到线程池中的可用内核线程，多个用户级线程可以分配给相同的内核级线程</p><p>Java线程属于内核级线程</p><h3 id="何时执行调度器"><a href="#何时执行调度器" class="headerlink" title="何时执行调度器"></a>何时执行调度器</h3><p>非抢占式调度</p><ul><li><p>当前线程执行结束</p></li><li><p>当前线程主动放弃CPU</p></li><li><p>当前线程阻塞</p></li></ul><p>抢占式调度</p><ul><li><p>就绪队列中出现高优先级的线程</p></li><li><p>时间片结束</p></li></ul><h3 id="操作系统需要考虑的调度及目标、方法"><a href="#操作系统需要考虑的调度及目标、方法" class="headerlink" title="操作系统需要考虑的调度及目标、方法"></a>操作系统需要考虑的调度及目标、方法</h3><ul><li><p>作业调度：将外存中的作业调入内存，为其创建进程、分配资源</p><p>先来先服务FCFS 短作业优先SJF 最高响应比优先HRN 优先级 轮转法 多级反馈队列</p></li><li><p>内存调度：为提高内存利用率和系统吞吐量，将内存中的进程暂时挂起，选择部分程序或数据留在内存，这种技术称为交换</p></li><li><p>进程调度：从就绪队列中选择进程获得CPU</p><p>先进先出FIFO 时间片轮转RR 优先级 多级反馈队列</p></li><li><p>磁盘调度：当多个进程要求访问磁盘时，使平均访问时间最小</p><p>先来先服务FCFS 最短寻道时间优先SSTF 电梯调度SCAN LOOK C-SCAN C-LOOK</p></li></ul><blockquote><p>// ？？？不懂算不算调度</p><ul><li><p>空闲分区的分配：将磁盘中一组连续的块分配给文件存储</p><p>首次适应 最佳适应 最坏适应</p></li><li><p>请求分页存储管理中的页面置换：内存空间不足时，需要从内存中调出一页</p><p>最佳置换OPT 先进先出FIFO 最近最久未使用LRU 时钟置换CLOCK</p></li></ul></blockquote><p>调度算法的目标</p><ul><li>CPU利用率 高</li><li>吞吐量 高：单位时间内完成进程的个数</li><li>等待时间 短：线程在就绪队列中的时间</li><li>响应时间 短：从用户提交请求到系统做出反馈的时间</li><li>周转时间 短：进程等待时间+运行时间</li></ul><h3 id="进程调度中多级反馈队列调度算法的基本思想"><a href="#进程调度中多级反馈队列调度算法的基本思想" class="headerlink" title="进程调度中多级反馈队列调度算法的基本思想"></a>进程调度中多级反馈队列调度算法的基本思想</h3><p>将进程按类型分成不同的队列，每个队列采用适合自身的调度算法，从最高优先级队列开始调度，若该队列中的作业未完成则将其降级到更低优先级队列，若较低优先级队列中作业等待时间过长则将其升级到更高优先级队列，能够较好实现公平性与资源利用率之间的平衡。</p><h3 id="进程通信IPC的两种模式"><a href="#进程通信IPC的两种模式" class="headerlink" title="进程通信IPC的两种模式"></a>进程通信IPC的两种模式</h3><p>共享内存：多个进程都可以访问各自的虚拟内存区域，进程虚拟地址映射到相同的物理地址；共享数据过程的同步由应用程序负责</p><p>消息传输：以Message为单位，通过send()和receive()两个原语操作进行数据交换</p><ul><li>直接通信：要求对方在线，每个进程都有消息队列</li><li>间接通信：对方可以不同时在线，通信前建立邮箱</li></ul><h3 id="图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件"><a href="#图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件" class="headerlink" title="图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件"></a>图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件</h3><p>不同作业指向相同的页框号</p><p><img src="/2022/01/15/OSreview/Users\31\AppData\Roaming\Typora\typora-user-images\image-20211214105624902.png" alt="image-20211214105624902"></p><p>由于页不是代码的逻辑单元，所以需要将逻辑单元对齐页边界</p><h3 id="CPU和操作系统在分页中各自承担了哪些工作"><a href="#CPU和操作系统在分页中各自承担了哪些工作" class="headerlink" title="CPU和操作系统在分页中各自承担了哪些工作"></a>CPU和操作系统在分页中各自承担了哪些工作</h3><p>CPU生成逻辑地址，分为页表和页偏移量两个部分；当一个进程可分配到CPU时，CPU调度程序可以根据页表副本来定义硬件页表</p><p>操作系统为每个进程维护一个页表的副本用于将逻辑地址转变成物理地址；管理物理内存，维护物理内存的分配信息保存在帧表中；</p><h3 id="图文并茂的描述虚拟地址到物理地址的映射过程"><a href="#图文并茂的描述虚拟地址到物理地址的映射过程" class="headerlink" title="图文并茂的描述虚拟地址到物理地址的映射过程"></a>图文并茂的描述虚拟地址到物理地址的映射过程</h3><p><strong>基本分页式</strong></p><p><img src="https://img-blog.csdnimg.cn/d09b292358084ef58e99d51176978e21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2Fyc2hleQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>带快表的分页式</strong></p><p><img src="https://img2020.cnblogs.com/blog/2083141/202008/2083141-20200803171427603-732589443.png" alt="img"></p><p>① 根据逻辑地址计算页号、页内偏移量</p><p>② 比较页号和页表长度，检查页号合法性</p><p>③ 查快表，若命中则获得页面存放的内存块号，转⑤；若未命中，转④</p><p>④ 查页表，根据页表始址找到页号对应页表项，获得页面存放的内存块号，并将该页表项复制到快表中</p><p>⑤ 根据内存块号和页内偏移量得到物理地址</p><p><strong>基本分段式</strong></p><p><img src="https://img-blog.csdnimg.cn/20201008202949487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTg3NzQw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>段页式</strong></p><p><img src="https://img-blog.csdnimg.cn/20201008205928813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTg3NzQw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="请求调页系统中页表项包含的数据项和作用"><a href="#请求调页系统中页表项包含的数据项和作用" class="headerlink" title="请求调页系统中页表项包含的数据项和作用"></a>请求调页系统中页表项包含的数据项和作用</h3><ul><li>页号（隐式）：给页顺序编号</li><li>内存块号：指出该页在内存中的位置</li><li>状态位：该页是否已经调入内存</li><li>访问字段：记录本页在一段时间内的访问次数或最近一次访问时间，用作置换算法的参考项</li><li>修改位：该页在调入内存后是否被修改过</li><li>外存地址：该页在外存中的位置</li></ul><h3 id="请求调页和纯分页的比较"><a href="#请求调页和纯分页的比较" class="headerlink" title="请求调页和纯分页的比较"></a>请求调页和纯分页的比较</h3><ul><li>ISA架构的改变：页故障异常、页表中增加存在位和脏位等设计</li><li>操作系统的改变：页故障异常处理程序（页置换）</li><li>硬盘的改变：对换区</li></ul><h3 id="采用工作集模型预防系统抖动的思想与过程"><a href="#采用工作集模型预防系统抖动的思想与过程" class="headerlink" title="采用工作集模型预防系统抖动的思想与过程"></a>采用工作集模型预防系统抖动的思想与过程</h3><p>根据局部性原理，进程会在某段时间间隔内相对稳定地访问某些页面。所以引入工作集的概念，指在某段时间间隔内进程实际访问的页面的集合</p><p>操作系统跟踪每个进程的工作集，并为进程分配大于其工作集大小的物理块</p><h3 id="颠簸产生的原因及解决方案"><a href="#颠簸产生的原因及解决方案" class="headerlink" title="颠簸产生的原因及解决方案"></a>颠簸产生的原因及解决方案</h3><p>进程频繁访问的页面数多于可用的物理块数</p><p>应用工作集策略为进程分配足够多的物理块；修改页面置换算法；降低多道程序的数量；增加物理内存容量</p><h3 id="I-O控制方式及特点"><a href="#I-O控制方式及特点" class="headerlink" title="I/O控制方式及特点"></a>I/O控制方式及特点</h3><p>程序直接控制：程序直接对设备轮询</p><p>中断驱动：当设备准备完成时发生中断</p><p>DMA：在I/O设备与内存之间开辟直接数据通路</p><p>通道控制：引入专门的I/O处理机进行管理</p><h3 id="输入输出过程举例"><a href="#输入输出过程举例" class="headerlink" title="输入输出过程举例"></a>输入输出过程举例</h3><ul><li><p>线程T调用驱动程序Q的启动部分的代码，启动设备</p></li><li><p>当前线程T等待设备完成操作；设备开始工作，线程T阻塞，CPU转去执行其他任务</p></li><li><p>设备完成工作，发出中断信号，激活中断处理程序，调用驱动程序Q的中断服务例程处理中断，线程T就绪</p></li><li><p>线程T被调度，继续执行</p></li></ul><h3 id="驱动程序、设备、中断服务程序、I-O子系统关系"><a href="#驱动程序、设备、中断服务程序、I-O子系统关系" class="headerlink" title="驱动程序、设备、中断服务程序、I/O子系统关系"></a>驱动程序、设备、中断服务程序、I/O子系统关系</h3><ul><li><p>驱动程序与内核I/O子系统</p><p>内核I/O子系统调用驱动程序，启动设备</p><p>驱动程序可以调用内核，如阻塞、唤醒线程</p></li><li><p>驱动程序与中断处理程序</p><p>中断处理程序调用驱动程序，执行设备中断服务例程</p></li><li><p>驱动程序与设备</p><p>驱动程序向设备发送命令，检测设备状态，通过中断机制响应设备事件</p></li></ul><h3 id="缓冲区的作用"><a href="#缓冲区的作用" class="headerlink" title="缓冲区的作用"></a>缓冲区的作用</h3><p>在内存中预留指定大小的存储空间用来临时存储I/O数据，可以缓和通信双方数据处理速度、单元的差异性，减少实际物理读写次数，提升并发性</p><p>缓冲区一直被重用，可以减少动态分配和回收内存的次数</p><h3 id="缓冲机制的三种用途并举例"><a href="#缓冲机制的三种用途并举例" class="headerlink" title="缓冲机制的三种用途并举例"></a>缓冲机制的三种用途并举例</h3><ul><li><p>处理数据流的生产者与消费者之间的速度差异</p><p>从调制解调器接收文件要保存到硬盘上。由于调制解调器大约比硬盘慢数千倍，所以在内存中创建缓冲区累计从调制解调器接收到的字节，当整个缓冲区填满后，通过一次操作将缓冲区内容写入磁盘中</p></li><li><p>协调传输数据大小不一致的设备</p><p>计算机网络中，缓冲用来处理消息的分段与重组。在发送端，一个到消息分成若干小包；在接收端，将包放在重组缓冲区内，最终生成完成的消息</p></li><li><p>支持应用程序I/O的复制语义</p><p>当某应用程序需要将缓冲区内的数据写入到磁盘上时，操作系统将应用程序缓冲区复制到内核缓冲区中，让磁盘写操作在内核缓冲区中执行，这样后来应用程序缓冲区的改变就没有影响</p></li></ul><h3 id="使用cache的意义"><a href="#使用cache的意义" class="headerlink" title="使用cache的意义"></a>使用cache的意义</h3><p>解决数据读写速度不匹配的问题</p><h3 id="高速缓存与缓冲区的区别"><a href="#高速缓存与缓冲区的区别" class="headerlink" title="高速缓存与缓冲区的区别"></a>高速缓存与缓冲区的区别</h3><p>作用上：高速缓存为了提高效率；缓冲区用于通信双方数据的交换</p><p>内容上：高速缓存中的内容是另一个存储器内容的备份；缓冲区中的数据是唯一的</p><h3 id="异步I-O-阻塞I-O-非阻塞I-O的区别，并举例"><a href="#异步I-O-阻塞I-O-非阻塞I-O的区别，并举例" class="headerlink" title="异步I/O 阻塞I/O 非阻塞I/O的区别，并举例"></a>异步I/O 阻塞I/O 非阻塞I/O的区别，并举例</h3><p>阻塞I/O：请求I/O系统调用后一直等待直到获得结果，进程变为就绪态 socket中的listen(), send(), recv()等</p><p>非阻塞式I/O：请求I/O系统调用后立即返回 socket中的select()</p><p>异步I/O：请求I/O系统调用后立即返回，I/O操作完成后向进程发出信号执行回调函数 aio_read()</p><h3 id="访存操作可能会导致I-O的进行，某进程读写文件时可能并没有I-O设备执行，为什么"><a href="#访存操作可能会导致I-O的进行，某进程读写文件时可能并没有I-O设备执行，为什么" class="headerlink" title="访存操作可能会导致I/O的进行，某进程读写文件时可能并没有I/O设备执行，为什么"></a>访存操作可能会导致I/O的进行，某进程读写文件时可能并没有I/O设备执行，为什么</h3><p>使用了假脱机技术。操作系统对于用户的读写文件请求，并没有真正把I/O设备分配给该用户进程，而是在磁盘缓冲区中为进程分配了空闲盘块和建立了一张I/O请求表，实现了虚拟设备的功能</p><h3 id="批处理、脱机、假脱机为了解决什么问题"><a href="#批处理、脱机、假脱机为了解决什么问题" class="headerlink" title="批处理、脱机、假脱机为了解决什么问题"></a>批处理、脱机、假脱机为了解决什么问题</h3><p>批处理阶段引入脱机技术（在外围控制机的控制下I/O设备的输入输出先被送到更快速的磁带上）缓解了CPU与慢速I/O设备的速度矛盾</p><p>假脱机技术用软件的方式模拟脱机技术（磁盘上开辟的输入输出井模拟磁带，输入输出进程模拟外围控制机）提高了I/O速度，把一台物理设备虚拟成逻辑上的多台设备，将独占设备改造为共享设备</p><h3 id="磁盘分配的三种方式和各自优缺点"><a href="#磁盘分配的三种方式和各自优缺点" class="headerlink" title="磁盘分配的三种方式和各自优缺点"></a>磁盘分配的三种方式和各自优缺点</h3><ul><li><p>连续分配</p><p>每个文件在磁盘上占有连续的块</p><p>优点：支持随机访问、顺序存取速度快</p><p>缺点：不方便文件扩展、会产生外碎片</p></li><li><p>链接分配</p><p>每个文件对应一个磁盘块链表，每个磁盘块有指向下一个磁盘块的指针</p><p>优点：方便文件扩展、无碎片</p><p>缺点：不支持随机访问、磁盘块指针占用空间、存取速度慢、可靠性差</p></li><li><p>索引分配</p><p>每个文件建立一张索引表，放在索引块中</p><p>优点：支持随机访问、方便文件扩展、无碎片</p><p>缺点：索引表占用空间</p></li></ul><h3 id="三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置"><a href="#三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置" class="headerlink" title="三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置"></a>三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置</h3><p>连续分配：FCB记录了文件起始块号和长度，文件物理位置=起始块号+逻辑块号</p><p>链接分配：FCB记录了文件起始块号和结束块号，从起始块开始访问，每个磁盘块都有指向下一个磁盘块的指针，直到访问到结束块</p><p>索引分配：FCB记录了索引块所在的物理块号，访问该物理块读取索引表，得到各个逻辑块对应的物理块号</p><h3 id="FAT工作原理-链接分配中引入FAT的优点"><a href="#FAT工作原理-链接分配中引入FAT的优点" class="headerlink" title="FAT工作原理 链接分配中引入FAT的优点"></a>FAT工作原理 链接分配中引入FAT的优点</h3><p>每个磁盘建立一张文件分配表FAT，行号对应块号；每个FAT表项中存放对应磁盘块的下一块链接指针</p><p>支持随机访问</p><h3 id="空闲存储空间管理"><a href="#空闲存储空间管理" class="headerlink" title="空闲存储空间管理"></a>空闲存储空间管理</h3><ul><li><p>连续空闲空间管理</p><p>空闲区列表，每一项记录空闲区起始块号和空闲块数量</p></li><li><p>空闲块链</p><p>空闲块组成链表，指针放在空闲块中</p></li><li><p>成组空闲块链</p><p>每组100个空闲块，第一组索引在内存中，下一组索引在每组最后一块</p></li><li><p>位图</p><p>连续存储空间，每位对应一个盘块，存放在内存中</p></li></ul><h3 id="文件系统如何依据用户给出的文件名找到该文件对应的FCB"><a href="#文件系统如何依据用户给出的文件名找到该文件对应的FCB" class="headerlink" title="文件系统如何依据用户给出的文件名找到该文件对应的FCB"></a>文件系统如何依据用户给出的文件名找到该文件对应的FCB</h3><p>顺序检索目录表，找到文件名对应的目录项，该目录项就是FCB</p><h3 id="文件共享的途径"><a href="#文件共享的途径" class="headerlink" title="文件共享的途径"></a>文件共享的途径</h3><p>硬连接（基于索引节点）方式中，不同文件的目录项指向同一个索引节点，索引节点中设置一个引用计数变量</p><p>软连接（基于符号链接）方式中，由系统生成一个LINK类型文件，包含被共享文件的路径名</p><h3 id="如何实现多种文件系统的共存"><a href="#如何实现多种文件系统的共存" class="headerlink" title="如何实现多种文件系统的共存"></a>如何实现多种文件系统的共存</h3><p>文件系统的挂载，挂载表记录系统已安装文件系统的类型和指向文件系统的指针，挂载位置为目录节点或独立盘符</p><p>虚拟文件系统VFS，抽象出各种文件系统共有的部分，为各种文件系统提供一个统一的操作界面和应用编程接口</p><h3 id="操作系统中打开文件的工作过程"><a href="#操作系统中打开文件的工作过程" class="headerlink" title="操作系统中打开文件的工作过程"></a>操作系统中打开文件的工作过程</h3><p>使用open系统调用，提供文件存放路径、文件名、操作类型，操作系统在系统文件打开表中查找</p><ul><li><p>该文件已经打开</p><p>检查操作类型是否合法</p><p>在进程文件打开表中为文件分配一个表项，将该表项的指针指向系统文件打开表中该文件对应的一项</p><p>在PCB中为文件分配一个文件描述符fd作为进程文件打开表项的指针，文件打开完成</p></li><li><p>该文件没有打开</p><p>根据文件存放路径查找相应的目录文件是否在内存中，若不在则装入内存</p><p>从目录中找到文件名对应的目录项，检查操作类型是否合法，得到该文件的FCB在磁盘中的位置</p><p>将该FCB装入内存中的Active Inode中</p><p>在系统文件打开表中为文件分配一个表项，将该表项的指针指向Active Inode中对应的FCB</p><p>在进程文件打开表中为文件分配一个表项，将该表项的指针指向系统文件打开表中该文件对应的一项</p><p>在PCB中为文件分配一个文件描述符fd作为进程文件打开表项的指针，文件打开完成</p></li></ul><h3 id="临界区及其使用准则"><a href="#临界区及其使用准则" class="headerlink" title="临界区及其使用准则"></a>临界区及其使用准则</h3><p>进程在并发执行中可以共享系统中的资源，但对临界资源的访问必须互斥进行，一个进程中访问临界资源的代码段为临界区。</p><p>临界区的使用准则</p><ul><li>空闲让进：无进程处于临界区时，若有进程要求进入临界区应允许进入</li><li>忙则等待：有进程处于临界区时，其他试图进入该临界区的进程必须等待</li><li>有限等待：有进程等待进入临界区时，它的等待时间应该是有限的</li><li>让权等待：等待进入临界区的进程应释放CPU</li></ul><h3 id="同步与互斥的异同"><a href="#同步与互斥的异同" class="headerlink" title="同步与互斥的异同"></a>同步与互斥的异同</h3><p>相同点</p><ul><li>都是并发环境下操作之间的时序关系</li><li>不满足条件时线程等待</li><li>运行过程中动态判定</li></ul><p>不同点</p><ul><li>同步在时序上是固定的偏序关系</li><li>互斥在时序上只要不同时执行即可</li></ul><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li>互斥：资源一次只能由一个进程使用</li><li>非抢占：资源只能在进程完成任务后自动释放</li><li>占有并等待：一个进程必须至少占用一个资源，并等待另一资源，且该资源被其他进程占有</li><li>循环等待：有一组等待进程{P0, P1, …, Pn}，P0等待的资源被P1占有，P1等待的资源被P2占有，……，Pn等待的资源被P0占有</li></ul><h3 id="CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁"><a href="#CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁" class="headerlink" title="CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁"></a>CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁</h3><p>CPU属于可剥夺性资源。只有不可剥夺资源才会因为竞争资源而产生死锁。</p><h3 id="死锁预防思路"><a href="#死锁预防思路" class="headerlink" title="死锁预防思路"></a>死锁预防思路</h3><ul><li><p>破坏互斥条件</p><p>一般不能破坏</p><p>假脱机技术可以将独占设备在逻辑上改造成共享设备</p></li><li><p>破坏占有并等待条件</p><p>一次性申请需要的所有资源；申请新资源前释放已占有资源</p><p>产生饥饿的概率增加</p></li><li><p>破坏非抢占条件</p><p>若进程请求资源不成功则回收其占有的所有资源</p><p>一般适用于易保存和恢复的资源</p></li><li><p>破坏循环等待条件</p><p>将所有资源排序编号，进程只能按序号递增的顺序申请资源</p></li></ul><h3 id="简述银行家算法避免死锁的过程"><a href="#简述银行家算法避免死锁的过程" class="headerlink" title="简述银行家算法避免死锁的过程"></a>简述银行家算法避免死锁的过程</h3><p>变量定义</p><ul><li>Allocation矩阵：当前已分配给各进程的各类资源数目</li><li>Max矩阵：各进程总共需要的各类资源数目</li><li>Need矩阵：各进程还需要的各类资源数目</li><li>Available向量：当前可供分配的各类资源数目</li><li>Work向量：用于安全检测算法中记录可供分配的各类资源数目</li><li>Finish数组：用于安全检测算法中记录是否能满足该进程所有资源请求</li></ul><p>算法过程</p><p>​    进程Pi提出申请资源的请求Request</p><ul><li><p>检查Request&lt;=Need[i]</p></li><li><p>检查Request&lt;=Available</p></li><li><p>Allocation[i]=Allocation[i]+Request</p><p>Need[i]=Need[i]-Request</p><p>Available=Available-Request</p></li><li><p>执行安全性算法</p><ul><li><p>Work=Available Finish[:]=false</p></li><li><p>查找i，使Work&gt;=Need[i]且Finish[i]=false</p><ul><li><p>若找到，则Work=Work+Allocation[i] Finish[i]=true，继续查找</p></li><li><p>若找不到，检查是否Finish数组全为true</p><p>是则安全，否则不安全</p></li></ul></li><li><p>若产生的资源分配状态安全，则满足Request请求；否则不满足，恢复到原来资源分配状态</p></li></ul></li></ul><h3 id="死锁避免、死锁预防并比较区别"><a href="#死锁避免、死锁预防并比较区别" class="headerlink" title="死锁避免、死锁预防并比较区别"></a>死锁避免、死锁预防并比较区别</h3><p>死锁预防：通过破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。是在进程申请资源的层面上进行的，系统预先确定资源分配策略，系统按照策略进行分配。</p><p>死锁避免：当进程提出资源申请时系统测试资源分配，仅当能确保系统安全的时候才把资源分配给进程，这样使得系统能一直处于安全状态。是在操作系统分配资源的层面上进行的。</p><h3 id="死锁检测和恢复的思路"><a href="#死锁检测和恢复的思路" class="headerlink" title="死锁检测和恢复的思路"></a>死锁检测和恢复的思路</h3><p>检测：资源分配图化简后形成环路；死锁检测算法</p><p>恢复：资源剥夺法；撤销进程法；进程回退法</p><h3 id="阻塞、饥饿、死锁的区别"><a href="#阻塞、饥饿、死锁的区别" class="headerlink" title="阻塞、饥饿、死锁的区别"></a>阻塞、饥饿、死锁的区别</h3><p>阻塞：一个正在执行的进程由于I/O请求等事件暂时无法继续执行，将其暂停执行</p><p>饥饿：一个进程因调度算法不合理而长时间等待；发生饥饿的进程既可能是阻塞态（长期得不到需要的I/O设备）也可能是就绪态（长期得不到CPU）；等待会被释放但不会分配给自己的资源</p><p>死锁：多个进程因竞争资源而相互等待；发生死锁的进程一定处于阻塞态；等待永远不会被释放的资源</p><h3 id="简述保护的概念"><a href="#简述保护的概念" class="headerlink" title="简述保护的概念"></a>简述保护的概念</h3><ul><li><p>硬件层面</p><p>操作系统分为内核态和用户态，将可能引起损害的机器指令作为特权指令，且只能在内核态下执行特权指令</p><p>操作系统使用定时器防止用户程序陷入死循环</p></li><li><p>文件管理</p><p>文件保护指避免文件拥有者或其它用户因错误操作使文件受到破坏，有三种方式：口令保护、密码保护、访问控制（每个文件和目录增加一个访问控制列表ACL，记录每个用户名及允许的访问类型）</p></li><li><p>设备管理</p><p>设备被看作文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中的信息判断用户是否有访问权限，来实现设备保护的功能</p></li><li><p>存储管理</p><p>保护内存使各道作业互不干扰，可以设置一对上下限寄存器或基址寄存器和限长寄存器，当进行地址变换时检查是否出现越界</p></li><li><p>进程同步</p><p>为保护临界区资源同一时间只能由一个进程访问，可以采用硬件方法：关中断、TestAndSet指令、Swap指令，软件方法：Peterson算法</p></li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="m-n-k生产者-消费者问题"><a href="#m-n-k生产者-消费者问题" class="headerlink" title="m-n-k生产者-消费者问题"></a>m-n-k生产者-消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore full=<span class="hljs-number">0</span>, empty=k, mutex=<span class="hljs-number">1</span>;<br>Item buffer[k];<br><span class="hljs-keyword">int</span> in=<span class="hljs-number">0</span>, out=<span class="hljs-number">0</span>;<br><br>producer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(empty);<br>    P(mutex);<br>    buffer[in] = item;<br>    in = (in+<span class="hljs-number">1</span>)%k;<br>    V(full);<br>    V(mutex);<br>&#125;<br><br>consumer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(full);<br>    P(mutex);<br>    item = buffer[out];<br>    out = (out+<span class="hljs-number">1</span>)%k;<br>    V(empty);<br>    V(mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore rw_mutex=<span class="hljs-number">1</span>, r_mutex=<span class="hljs-number">1</span>, w=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> r_count=<span class="hljs-number">0</span>;<br><br>writer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(w);<br>    P(rw_mutex);<br>    <span class="hljs-comment">//writing...</span><br>    V(rw_mutex);<br>    V(w);<br>&#125;<br><br>reader:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(w);<br>    P(r_mutex);<br>    <span class="hljs-keyword">if</span>(r_count == <span class="hljs-number">0</span>)&#123;<br>        P(rw_mutex);<br>    &#125;<br>    r_count++;<br>    V(r_mutex);<br>    V(w);<br>    <span class="hljs-comment">//reading...</span><br>    P(r_mutex);<br>    r_count--;<br>    <span class="hljs-keyword">if</span>(r_count == <span class="hljs-number">0</span>)&#123;<br>        V(rw_mutex);<br>    &#125;<br>    V(r_mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;, mutex=<span class="hljs-number">1</span>;<br>Philosopher_i:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>P(mutex);<br>    P(chopstick[i]);<br>    P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    <span class="hljs-comment">//eating...</span><br>    V(mutex);<br>    V(chopstick[i]);<br>    V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    <span class="hljs-comment">//thinking...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
