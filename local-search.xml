<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>This is NACHOS#2</title>
    <link href="/2022/03/30/This-is-NACHOS-2/"/>
    <url>/2022/03/30/This-is-NACHOS-2/</url>
    
    <content type="html"><![CDATA[<p>目前Nachos实现的文件系统存在诸多限制，其中之一是文件大小不能扩展，即无法在已经存在的文件尾部追加数据</p><p>该实验的任务就是让你修改Nachos的文件系统，以满足：</p><ul><li>文件创建时，其大小可初始化为0</li><li>当一个文件写入更多的数据时，其大小可随之增大</li><li>要求能够从一个文件的任意位置开始写入数据，即能够正确处理命令行参数<code>-ap</code> <code>-hap</code> <code>-nap</code></li></ul><p>例如，如果一个文件的大小为100字节，当从其偏移量50（第一个字节的偏移量是0）开始写入100个字节后，该文件的大小应该为150字节，如下图所示</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220330203148356.png" alt="文件的扩展"></p><p>Nachos的文件系统包括以下模块：</p><ul><li><code>class Disk</code>               //see ../machine</li><li><code>class SynchDisk</code>    //see ../filesys</li><li><code>class BitMap</code>          //see ../userprog</li><li><code>class FileHeader</code> //see ../filesys</li><li><code>class OpenFile</code>     //see ../filesys</li><li><code>class Directory</code>   //see ../filesys</li><li><code>class FileSystem</code> //see ../filesys</li></ul><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220330203354261.png" alt="Nachos文件系统结构"></p><p>通过该实验，你需要</p><ul><li>理解文件系统中文件操作的实现方法，如文件打开、读、写、扩展、定位、关闭等</li><li>理解如何管理硬盘空闲块</li><li>理解创建文件时，如何为文件分配目录项及文件头（FCB）</li><li>理解文件扩展时，如何为要扩展的数据查找并分配空闲块</li><li>理解文件扩展后，文件大小是如何记录与保存的</li><li>理解文件被删除后，如何回收为其分配的资源，如文件头、目录项、硬盘块等</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ul><li><code>nachos [-d f] –ap Unix_filename Nachos_filename</code><br>该命令的功能是将一个UNIX文件（unix_filename）附加到一个Nachos文件（nachos_filename）的后面，目的是用来测试当我们在一个Nachos的文件尾部追加数据后，文件大小是否会增加。</li><li><code>nachos [-d f] –hap Unix_filename Nachos_filename</code><br>该命令的功能是从一个Nachos文件（nachos_filename）的中间（文件大小的1/2）位置开始，将一个UNIX文件（unix_filename）写入到该Nachos文件中。如果这个UNIX文件大于Nachos文件的一半，则该目录执行后，新的Nachos文件的大小将增加。</li><li><code>nachos [-d f] –nap Nachos_filename1 Nachos_filename1</code><br>该命令的功能是将一个Nachos文件（nachos_filename1）附加到一个Nachos文件（nachos_filename2）的后面，目的是用来测试当我们在一个Nachos的文件尾部写入数据时，文件大小是否会增加。</li></ul><p>执行上述命令时会出现如下错误</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323130711260.png" alt></p><p>在<code>./lab5/main.cc</code>中查看对命令行参数<code>-ap</code> <code>-hap</code> <code>-nap</code>的处理过程</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220322094739607.png" alt></p><p>发现<code>-ap</code> <code>-hap</code>与函数<code>Append(..)</code>有关，<code>-nap</code>与函数 <code>NAppend(..)</code>有关</p><p>跳转阅读<code>./lab5/fstest.cc</code>中的这两个函数，找到报错行149</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323131227511.png" alt></p><p>发现是由于写数据结果<code>result</code>和已读数据<code>amountRead</code>不一致导致的报错</p><p>找到<code>result</code>的产生位置，是<code>OpenFile::Write(..)</code>的返回结果</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323131500024.png" alt></p><p>进入<code>OpenFile::Write(..)</code>函数内部查看，<code>result</code>实则是<code>OpenFile::WirteAt(..)</code>函数的返回结果，该函数试图从当前文件头对应的文件的指定位置<code>position</code>开始写入缓冲区<code>from</code>中<code>numBytes</code>大小的内容</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323132028728.png" alt></p><p>分析该函数的实现：</p><ul><li><p>首先从当前文件的文件头中获取文件长度<code>fileLength</code></p></li><li><p>约束1：如果要写入的内容不存在<code>numBytes&lt;=0</code>或是开始写入的位置为文件尾或超出了文件尾<code>position&gt;=fileLength</code>，则直接退出</p></li><li><p>约束2：如果要写入的内容过多超出了原文件的长度<code>(position+numBytes)&gt;fileLength</code>，超出部分也不再写入</p></li></ul><p>这两个<code>if</code>约束导致目前Nachos实现的文件系统不能对文件的大小进行扩展，所以需要对其进行修改：</p><ul><li>修改上面的两个约束，使Nachos文件大小可以扩展</li><li>如果文件的最后一个扇区能够容纳扩展的数据，则要修改文件头中的文件长度，再将文件头写回硬盘</li><li>如果文件的最后一个扇区不能够容纳扩展的数据，则要为这些数据分配新的扇区，那么就需要修改硬盘的位图和文件头中的文件长度、分配的扇区数、分配的扇区号，再将修改的内容写回硬盘</li></ul><p>而在<code>Append(..)</code>与 <code>NAppend(..)</code>中将文件头写回硬盘的操作<code>OpenFile::WriteBack()</code>未被实现，需要我们补充</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323153623437.png" alt></p><p>因此文件扩展操作需要涉及的内容有：</p><ul><li><p>修改<code>OpenFile::WriteAt()</code>，允许从文件尾部开始写数据，并可为要写入的数据分配新的扇区</p></li><li><p>修改<code>FileSystem</code>类，添加空闲块位示图文件的硬盘读写操作</p></li><li><p>修改<code>OpenFile::OpenFile()</code>及<code>OpenFile::WriteBack()</code>，实现文件头的硬盘读写</p></li><li><p>修改<code>FileHeader::Allocate()</code>，为添加的数据分配硬盘块（扇区）</p></li><li><p>修改<code>Append()</code>和<code>NAppend()</code>，使下次的写指针指向新写入数据的尾部，并在扩展操作结束后调用<code>OpenFile::WriteBack()</code>将修改后的文件头写入硬盘</p></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="修改OpenFile-WriteAt"><a href="#修改OpenFile-WriteAt" class="headerlink" title="修改OpenFile::WriteAt()"></a>修改<code>OpenFile::WriteAt()</code></h3><p>修改两个约束</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>((numBytes &lt;= <span class="hljs-number">0</span>) || (position &gt; fileLength))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <br><span class="hljs-keyword">if</span>((position + numBytes) &gt; fileLength)&#123;<br>    <span class="hljs-keyword">int</span> incrementBytes = (position + numBytes) - fileLength;<br>    BitMap* freeBitMap = fileSystem-&gt;<span class="hljs-built_in">getBitMap</span>(); <span class="hljs-comment">// TODO </span><br>    <span class="hljs-keyword">bool</span> hdrRet = hdr-&gt;<span class="hljs-built_in">Allocate</span>(freeBitMap, fileLength, incrementBytes); <span class="hljs-comment">// TODO</span><br>    <span class="hljs-keyword">if</span>(!hdrRet)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    fileSystem-&gt;<span class="hljs-built_in">setBitMap</span>(freeBitMap); <span class="hljs-comment">//TODO</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于约束1，如果要写入的内容不存在<code>numBytes&lt;=0</code>或是开始写入的位置超出了文件尾<code>position&gt;fileLength</code>，则直接返回错误参数<code>-1</code>。这里保留了开始写入的位置为文件尾<code>position==fileLength</code>，说明文件需要扩展。</p><p>对于约束2，保留超出部分的数据<code>incrementBytes</code>；获得当前硬盘的位图<code>freeBitMap</code>；检查是否有足够的空间分配给超出部分的数据，返回结果<code>hdrRet</code>；如果没有足够空间，则返回错误参数<code>-1</code>；如果有足够的空间，则将更新后的位图写回硬盘</p><h3 id="修改FileSystem类"><a href="#修改FileSystem类" class="headerlink" title="修改FileSystem类"></a>修改<code>FileSystem</code>类</h3><p>添加<code>setBitMap()</code>和<code>getBitMap()</code></p><p>在类<code>FileSystem</code>的构造函数中，维护了一直处于打开状态的位图文件句柄<code>OpenFile* freeMapFile</code>，我们可以直接使用它们实现对DISK的位图文件的读写操作</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BitMap* <span class="hljs-title">FileSystem::getBitMap</span><span class="hljs-params">()</span></span>&#123;<br>    BitMap* freeBitMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BitMap</span>(NumSectors);<br>    freeBitMap-&gt;<span class="hljs-built_in">FetchFrom</span>(freeMapFile);<br>    <span class="hljs-keyword">return</span> freeBitMap;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FileSystem::setBitMap</span><span class="hljs-params">(BitMap* freeMap)</span></span>&#123;<br>    freeMap-&gt;<span class="hljs-built_in">WriteBack</span>(freeMapFile);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>getBitMap()</code>调用了<code>../userprog/bitmap.cc</code>中<code>BitMap</code>类的<code>FetchFrom(OpenFile *)</code></p><p><code>setBitMap()</code>调用了<code>BitMap</code>类的<code>WriteBack(OpenFile *)</code>完成</p><h3 id="修改OpenFile-OpenFile-及OpenFile-WriteBack"><a href="#修改OpenFile-OpenFile-及OpenFile-WriteBack" class="headerlink" title="修改OpenFile::OpenFile()及OpenFile::WriteBack()"></a>修改<code>OpenFile::OpenFile()</code>及<code>OpenFile::WriteBack()</code></h3><p>分析<code>OpenFile</code>类的构造函数</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323153816341.png" alt></p><p>维护了一个<code>FileHeader</code>类对象<code>hdr</code>，从硬盘的指定扇区<code>sector</code>中读取了该文件的文件头，并将读写指针<code>seekPosition</code>设置为开始位置<code>0</code></p><p>考虑到类<code>FileHeader</code>中有函数<code>WriteBack(int sector)</code></p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323154355512.png" alt></p><p>为了将文件头写回硬盘，我们可以调用这个函数，实现<code>hdr-&gt;WriteBack(sector)</code></p><p>而该实现需要获得该文件头所在的扇区号，所以在<code>OpenFile</code>类中定义一个私有变量<code>hdrSector</code>并维护</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">OpenFile::<span class="hljs-built_in">OpenFile</span>(<span class="hljs-keyword">int</span> sector)<br>&#123; <br>    hdr = <span class="hljs-keyword">new</span> FileHeader;<br>    hdr-&gt;<span class="hljs-built_in">FetchFrom</span>(sector);<br>    seekPosition = <span class="hljs-number">0</span>;<br>    hdrSector = sector; <span class="hljs-comment">// ADD</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么，进而可以实现<code>OpenFile::WriteBack()</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OpenFile::WriteBack</span><span class="hljs-params">()</span></span>&#123;<br>    hdr-&gt;<span class="hljs-built_in">WriteBack</span>(hdrSector);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="修改FileHeader-Allocate"><a href="#修改FileHeader-Allocate" class="headerlink" title="修改FileHeader::Allocate()"></a>修改<code>FileHeader::Allocate()</code></h3><p>重载函数<code>FileHeader::Allocate(BitMap* freeMap, int fileSize, int incrementBytes)</code>，以根据要扩展的数据大小<code>incrementBytes</code>判断是否需要分配新的扇区块来返回结果，并更新文件头三元组</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FileHeader::Allocate</span><span class="hljs-params">(BitMap* freeMap, <span class="hljs-keyword">int</span> fileSize, <span class="hljs-keyword">int</span> incrementBytes)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(numSectors &gt; NumDirect)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>((fileSize == <span class="hljs-number">0</span>) &amp;&amp; (incrementBytes &gt; <span class="hljs-number">0</span>))&#123;<br>        <span class="hljs-keyword">if</span>(freeMap-&gt;<span class="hljs-built_in">NumClear</span>() &lt; <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        dataSectors[<span class="hljs-number">0</span>] = freeMap-&gt;<span class="hljs-built_in">Find</span>();<br>        numSectors = <span class="hljs-number">1</span>;<br>        numBytes = <span class="hljs-number">0</span>;<br>    &#125;<br>    numBytes = fileSize;<br>    <span class="hljs-keyword">int</span> offset = numBytes % SectorSize;<br>    <span class="hljs-keyword">int</span> newSectorBytes = incrementBytes - (SectorSize - (offset + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span>(newSectorBytes &lt;= <span class="hljs-number">0</span>)&#123;<br>        numBytes += incrementBytes;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> moreSectors = <span class="hljs-built_in">divRoundUp</span>(newSectorBytes, SectorSize);<br>    <span class="hljs-keyword">if</span>(numSectors + moreSectors &gt; NumDirect)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(freeMap-&gt;<span class="hljs-built_in">NumClear</span>() &lt; moreSectors)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=numSectors; i&lt;numSectors+moreSectors; i++)<br>        dataSectors[i] = freeMap-&gt;<span class="hljs-built_in">Find</span>();<br>    numBytes += incrementBytes;<br>    numSectors += moreSectors;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>如果当前文件已分配的扇区数大于限制，则退出不予分配</li><li>如果当前文件是空文件且要写入数据，那么首先要为该文件分配一个空闲扇区，并更新文件头信息</li><li>如果当前文件最后一个扇区的剩余空间足以容纳要写入的<code>incrementBytes</code>个字节，就不需要为写入操作分配新的扇区，在最后一个扇区中写入数据即可。但要修改文件头中文件大小信息</li><li>如果当前文件最后一个扇区的剩余空间无法容纳要写入的<code>incrementBytes</code>个字节，就需要为写入操作分配新的扇区，通过计算得出需要分配的扇区数<code>moreSectors</code><ul><li>如果扩展后文件过大超出限制，则退出不予分配</li><li>如果硬盘中没有足够的空闲扇区，则退出无法分配</li><li>如果符合条件可以分配，则要更新文件头信息</li></ul></li></ul><h3 id="修改Append-和NAppend"><a href="#修改Append-和NAppend" class="headerlink" title="修改Append()和NAppend()"></a>修改<code>Append()</code>和<code>NAppend()</code></h3><p><code>Append()</code>和<code>NAppend()</code>调用了修改后的<code>OpenFile::WriteAt()</code>，<code>OpenFile::WriteAt()</code>调用了重载的<code>FileHeader::Allocate()</code>，<code>FileHeader::Allocate()</code>根据每次写入的数据修改文件头三元组，但一直在内存中，尚未写回硬盘，因此在<code>Append()</code>和<code>NAppend()</code>的写操作结束后，应该调用<code>OpenFile::WriteBack()</code>将修改后的文件头写回到硬盘的相应的扇区中</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">openFile-&gt;<span class="hljs-built_in">WriteBack</span>();<br></code></pre></div></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>为容易识别硬盘DISK信息的改变，修改<code>../file/test/</code>下的文件内容</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192417516.png" alt></p></li><li><p><code>nachos –f</code>  在硬盘DISK上初始化一个Nachos文件系统</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192531213.png" alt></p><p><code>nachos –D</code> </p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192624590.png" alt></p><p>考察Nachos在硬盘DISK上初始化的文件系统情况：</p><ul><li>空闲块位图的头文件（0号扇区）</li><li>空闲块位图文件数据块（2号扇区）</li><li>目录表头文件（1号扇区）</li><li>目录表数据块（3、4号扇区)</li></ul></li><li><p><code>nachos –cp test/small small</code>复制test目录下的UNIX文件small到DISK中</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192819418.png" alt></p><p><code>nachos –D</code> </p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323192905582.png" alt></p><p>查看硬盘DISK中的文件信息：</p><ul><li><p>空闲块位图的头文件（0号扇区）</p></li><li><p>空闲块位图文件数据块（2号扇区）</p></li><li><p>目录表头文件（1号扇区）</p></li><li><p>目录表数据块（3、4号扇区）</p></li><li><p>文件small的头文件（5号扇区）</p></li><li><p>文件small的数据块（6号扇区）</p></li></ul></li><li><p><code>nachos –ap test/small small</code> 测试给一个已存在的文件追加数据</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193208886.png" alt></p><p><code>nachos –D</code>  查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193600435.png" alt></p><p>系统成功将small文件的内容扩展到small文件原扇区的剩余空间中</p></li><li><p><code>nachos –ap test/big small</code> 测试为文件分配新扇区的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193710627.png" alt></p><p><code>nachos –D</code> 以及 <code>hexdump -C DISK</code>查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193803974.png" alt></p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323193915926.png" alt></p><p>系统将samll文件原扇区的剩余空间写满后，为small分配新的扇区块，写入big的内容</p></li><li><p><code>nachos –ap test/medium medium</code>，测试给一个空文件追加数据的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194032389.png" alt></p><p><code>nachos –D</code>  查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194152122.png" alt></p><p>如果DISK中不存在文件，将会自动创建一个空的文件，然后将源文件内容追加到Nachos空文件中</p></li><li><p><code>nachos –ap test/big small</code> 测试Nachos为small新分配的扇区块的位置</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194326272.png" alt></p></li><li><p><code>nachos –D</code>查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323194427520.png" alt></p><p>在执行它之前，由于small的数据块之后的扇区是medium文件的文件头及其数据块，因此，系统会在medium文件之后为small分配新的扇区10</p><p>Nachos的文件系统采取索引分配文件数据块的方式，文件的数据块在硬盘上可以是非连续存放的，这使文件的扩展易于实现</p></li><li><p><code>nachos –hap test/medium small</code> 测试从small的中间写入文件的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195008517.png" alt></p><p><code>nachos –D</code> 查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195050848.png" alt></p><p>系统成功在small的中间写入文件<code>test/medium</code>的内容</p></li><li><p><code>nachos –nap medium small</code> 测试将一个nachos文件附加到另一个nachos文件的功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195231325.png" alt></p><p><code>nachos –D</code> 查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195307639.png" alt></p><p>系统成功将nachos文件medium附加到nachos文件small的尾部</p></li><li><p><code>nachos –r small</code> 测试文件删除功能</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195352234.png" alt></p><p><code>nachos –D</code> 及<code>hexdump –C DISK</code>查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195423461.png" alt></p><p>原来的small文件相关信息都消失不见，其他文件信息保持不变</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323195701406.png" alt></p><p>位示图数据块：值变为<code>0x31f</code>，即<code>1100011111</code>，表示5号、6号、7号扇区空闲，即为原small文件的文件头和数据部分占用的扇区</p><p>目录表数据块：<code>inUse</code>值变为0，表示为原small文件分配的目录项空闲，而其他内容保持不变</p><p>small的文件头以及small文件内容：均被保留</p></li><li><p>测试<code>nachos –l</code>（列目录）命令</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200257908.png" alt></p></li><li><p>测试<code>nachos –p</code> （显示文件内容）命令</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200330654.png" alt></p></li><li><p>反复运行<code>nachos –ap test/big small</code> 测试nachos文件系统中对一个文件长度的限制</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200607481.png" alt></p><p><code>nachos –D</code> 查看硬盘DISK中的文件信息</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323200721073.png" alt></p><p>一个文件最多可分配30个扇区，每个扇区128字节，因此理论上文件最大限制为3840B</p><p>但测试中small文件大小为3832B，因为写文件的过程中不是逐字节写入的，而是使用了一个10B大小的缓冲区。big文件大小为99B，所以在38次追加big文件后，small文件达到3762B，而在第39次追加big文件时，每10B写入small文件，当写入70B后达到3832B，这之后再想写入10B则会超过限额3840B，则不进行该次写入操作，最终small文件的大小即为3832B</p></li><li><p>反复运行<code>nachos –ap</code> 在硬盘DISK上新建文件，测试nachos文件系统中最多可创建多少个文件</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323201540449.png" alt></p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323201612333.png" alt></p><p>报错之后共有10个文件，因为nachos采用一级目录，最多有10个目录项，因此最多可存储10个文件</p></li><li><p>测试创建一个大小为0的文件</p><p><img src="/2022/03/30/This-is-NACHOS-2/image-20220323201937280.png" alt></p><p>将空文件<code>test/empty</code>复制到硬盘中，使用<code>nachos -D</code>查看DISK中的文件信息，发现empty文件的大小为0，没有为它分配数据块</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>This is NACHOS#1</title>
    <link href="/2022/03/28/This-is-NACHOS-1/"/>
    <url>/2022/03/28/This-is-NACHOS-1/</url>
    
    <content type="html"><![CDATA[<p>Nachos模拟了一个硬盘，实现的文件系统比较简单，该实验将熟悉一些文件系统的操作命令，观察这些命令对硬盘（DISK）的影响，根据结果分析理解Nachos文件系统的实现原理。</p><p>该实验中需要理解一些Nachos文件的基本知识，特别是文件头（FCB或索引节点）的结构与作用，空闲块的标识方法，空闲块的分配与回收过程等。</p><p>文件的扩展实质上是从一个给定的位置开始对文件进行写操作，涉及到文件的打开、定位，空闲块的分配等操作，写操作结束后还需要将文件头、空闲块位示图写到硬盘中，以保存修改后的信息。</p><p>该实验完成后，需要你：</p><ul><li>理解Nachos硬盘是如何创建的</li><li>熟悉查看Nachos硬盘上的内容的方法</li><li>理解硬盘初始化的过程（如何在硬盘上创建一个文件系统）</li><li>了解Nachos文件系统提供了哪些命令，哪些命令已经实现，哪些需要你自己实现</li><li>理解已经实现的文件系统命令的实现原理</li><li>理解硬盘空闲块的管理方法</li><li>理解目录文件的结构与管理</li><li>理解文件的结构与文件数据块的分配方法</li><li>了解一个文件系统命令执行后，硬盘的布局</li><li>分析目前Nachos不能对文件进行扩展的原因，考虑解决方案</li></ul><h2 id="理解Nachos创建硬盘的过程与方法"><a href="#理解Nachos创建硬盘的过程与方法" class="headerlink" title="理解Nachos创建硬盘的过程与方法"></a>理解Nachos创建硬盘的过程与方法</h2><p>../lab5/main.cc调用了../threads/system.cc中的<code>Initialize()</code>创建了硬盘DISK</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316101048494.png" alt></p><p><code>SynchDisk</code>的初始化函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ../filesys/synchdisk.cc</span><br>SynchDisk::<span class="hljs-built_in">SynchDisk</span>(<span class="hljs-keyword">char</span>* name)<br>&#123;<br>    semaphore = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Semaphore</span>(<span class="hljs-string">&quot;synch disk&quot;</span>, <span class="hljs-number">0</span>);<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Lock</span>(<span class="hljs-string">&quot;synch disk lock&quot;</span>);<br>    disk = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Disk</span>(name, DiskRequestDone, (_int) <span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>初始化了物理硬盘的同步接口：用于同步的信号量和互斥锁</p><p>创建了模拟硬盘，其初始化函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ../machine/disk.cc</span><br>Disk::<span class="hljs-built_in">Disk</span>(<span class="hljs-keyword">char</span>* name, VoidFunctionPtr callWhenDone, _int callArg)<br>&#123;<br>    <span class="hljs-keyword">int</span> magicNum;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&quot;Initializing the disk, 0x%x 0x%x\n&quot;</span>, callWhenDone, callArg);<br>    handler = callWhenDone;<br>    handlerArg = callArg;<br>    lastSector = <span class="hljs-number">0</span>;<br>    bufferInit = <span class="hljs-number">0</span>;<br>    <br>    fileno = <span class="hljs-built_in">OpenForReadWrite</span>(name, FALSE);<br>    <span class="hljs-keyword">if</span> (fileno &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// file exists, check magic number </span><br><span class="hljs-built_in">Read</span>(fileno, (<span class="hljs-keyword">char</span> *) &amp;magicNum, MagicSize);<br><span class="hljs-built_in">ASSERT</span>(magicNum == MagicNumber);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// file doesn&#x27;t exist, create it</span><br>        fileno = <span class="hljs-built_in">OpenForWrite</span>(name);<br>magicNum = MagicNumber;  <br><span class="hljs-built_in">WriteFile</span>(fileno, (<span class="hljs-keyword">char</span> *) &amp;magicNum, MagicSize); <span class="hljs-comment">// write magic number</span><br><br><span class="hljs-comment">// need to write at end of file, so that reads will not return EOF</span><br>        <span class="hljs-built_in">Lseek</span>(fileno, DiskSize - <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>), <span class="hljs-number">0</span>);<br><span class="hljs-built_in">WriteFile</span>(fileno, (<span class="hljs-keyword">char</span> *)&amp;tmp, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">int</span>));  <br>    &#125;<br>    active = FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>打开一个UNIX文件（若不存在则创建）用于读写，向该文件写入一个<code>magicNum</code>来标识该文件是一个硬盘存储文件，并在该文件最末尾写入<code>0</code>标记文件结束，腾出存储空间</p><h2 id="了解Nachos文件系统提供的命令并测试"><a href="#了解Nachos文件系统提供的命令并测试" class="headerlink" title="了解Nachos文件系统提供的命令并测试"></a>了解Nachos文件系统提供的命令并测试</h2><p>分析../lab5/main.cc</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316102901201.png" alt></p><p>Nachos文件系统提供的命令有：</p><ul><li><code>-cp</code>：复制UNIX文件到Nachos文件（正确运行）</li><li><code>-ap</code>：将UNIX文件内容增加到Nachos文件后（未正确运行）</li><li><code>-hap</code>：将Nachos文件内容剪掉后半部分再将UNIX文件内容增至其后（未正确运行）</li><li><code>-nap</code>：将Nachos文件内容增加到Nachos文件后（未正确运行）</li><li><code>-p</code>：打印Nachos文件内容（正确运行）</li><li><code>-r</code>：删除Nachos文件（正确运行）</li><li><code>-l</code>：列出Nachos文件列表（正确运行）</li><li><code>-D</code>：打印整个文件系统（正确运行）</li><li><code>-t</code>：性能测试（未正确运行）</li></ul><h2 id="理解Nachos硬盘格式化（创建文件系统）的处理过程"><a href="#理解Nachos硬盘格式化（创建文件系统）的处理过程" class="headerlink" title="理解Nachos硬盘格式化（创建文件系统）的处理过程"></a>理解Nachos硬盘格式化（创建文件系统）的处理过程</h2><p>分析../filesys/filesys.cc中的构造函数<code>FileSystem::FileSystem(..)</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// ../filesys/filesys.cc</span><br>FileSystem::<span class="hljs-built_in">FileSystem</span>(<span class="hljs-keyword">bool</span> format)<br>&#123; <br>    <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Initializing the file system.\n&quot;</span>);<br>    <span class="hljs-keyword">if</span> (format) &#123;<br>        BitMap *freeMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BitMap</span>(NumSectors);<br>        Directory *directory = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Directory</span>(NumDirEntries);<br>        FileHeader *mapHdr = <span class="hljs-keyword">new</span> FileHeader;<br>        FileHeader *dirHdr = <span class="hljs-keyword">new</span> FileHeader;<br><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Formatting the file system.\n&quot;</span>);<br><br>    <span class="hljs-comment">// First, allocate space for FileHeaders for the directory and bitmap</span><br>    <span class="hljs-comment">// (make sure no one else grabs these!)</span><br>freeMap-&gt;<span class="hljs-built_in">Mark</span>(FreeMapSector);    <br>freeMap-&gt;<span class="hljs-built_in">Mark</span>(DirectorySector);<br><br>    <span class="hljs-comment">// Second, allocate space for the data blocks containing the contents</span><br>    <span class="hljs-comment">// of the directory and bitmap files.  There better be enough space!</span><br><br><span class="hljs-built_in">ASSERT</span>(mapHdr-&gt;<span class="hljs-built_in">Allocate</span>(freeMap, FreeMapFileSize));<br><span class="hljs-built_in">ASSERT</span>(dirHdr-&gt;<span class="hljs-built_in">Allocate</span>(freeMap, DirectoryFileSize));<br><br>    <span class="hljs-comment">// Flush the bitmap and directory FileHeaders back to disk</span><br>    <span class="hljs-comment">// We need to do this before we can &quot;Open&quot; the file, since open</span><br>    <span class="hljs-comment">// reads the file header off of disk (and currently the disk has garbage</span><br>    <span class="hljs-comment">// on it!).</span><br><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Writing headers back to disk.\n&quot;</span>);<br>mapHdr-&gt;<span class="hljs-built_in">WriteBack</span>(FreeMapSector);    <br>dirHdr-&gt;<span class="hljs-built_in">WriteBack</span>(DirectorySector);<br><br>    <span class="hljs-comment">// OK to open the bitmap and directory files now</span><br>    <span class="hljs-comment">// The file system operations assume these two files are left open</span><br>    <span class="hljs-comment">// while Nachos is running.</span><br><br>        freeMapFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(FreeMapSector);<br>        directoryFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(DirectorySector);<br>     <br>    <span class="hljs-comment">// Once we have the files &quot;open&quot;, we can write the initial version</span><br>    <span class="hljs-comment">// of each file back to disk.  The directory at this point is completely</span><br>    <span class="hljs-comment">// empty; but the bitmap has been changed to reflect the fact that</span><br>    <span class="hljs-comment">// sectors on the disk have been allocated for the file headers and</span><br>    <span class="hljs-comment">// to hold the file data for the directory and bitmap.</span><br><br>        <span class="hljs-built_in">DEBUG</span>(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&quot;Writing bitmap and directory back to disk.\n&quot;</span>);<br>freeMap-&gt;<span class="hljs-built_in">WriteBack</span>(freeMapFile); <span class="hljs-comment">// flush changes to disk</span><br>directory-&gt;<span class="hljs-built_in">WriteBack</span>(directoryFile);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DebugIsEnabled</span>(<span class="hljs-string">&#x27;f&#x27;</span>)) &#123;<br>    freeMap-&gt;<span class="hljs-built_in">Print</span>();<br>    directory-&gt;<span class="hljs-built_in">Print</span>();<br><br>        <span class="hljs-keyword">delete</span> freeMap; <br><span class="hljs-keyword">delete</span> directory; <br><span class="hljs-keyword">delete</span> mapHdr; <br><span class="hljs-keyword">delete</span> dirHdr;<br>&#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// if we are not formatting the disk, just open the files representing</span><br>    <span class="hljs-comment">// the bitmap and directory; these are left open while Nachos is running</span><br>        freeMapFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(FreeMapSector);<br>        directoryFile = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenFile</span>(DirectorySector);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>参数<code>format</code>表示是否将硬盘格式化，当命令行输入<code>-f</code>后则置其为<code>true</code></p><p>需要初始化磁盘使其包含一个空的目录<code>directory</code>和空闲块位图<code>freeMap</code></p><blockquote><p>Nachos模拟的硬盘DISK共有32个道，每个道有32个扇区，每个扇区128个字节，每个盘块仅包含一个扇区，所以共有1024个盘块，所以位图共1024位</p><p>Nachos文件系统采用单级目录结构，根目录中只有10个目录项，意味着Nachos的硬盘中最多可创建10个文件</p></blockquote><p>而这两个也被视作文件，同样需要文件头<code>mapHdr</code> <code>dirHdr</code></p><ol><li>为这两个文件头分配空间，位图的文件头被分配在0号扇区，目录的文件头被分配在1号扇区</li></ol><blockquote><p>思考：为什么将空闲块管理的位示图文件头与目录表文件头存放在0号和1号这两个特殊的扇区中？</p><p>初始化文件系统时，将这两个特殊的扇区设置为已使用，确保其他文件不会访问到。而对于一个真正的操作系统，由于系统启动时需要根据目录文件的文件头访问根目录，所以为了便于系统启动时从已知的、固定的位置访问它们，将这两个特殊的结构分配到0号和1号两个特殊的扇区中。</p></blockquote><ol><li>为目录和位图的数据块分配空间，同时更新对应的文件头内容</li></ol><blockquote><p>文件头内容包含：</p><ul><li><code>numBytes</code>文件大小</li><li><code>numSectors</code>分配给文件的块数</li><li><code>dataSector[]</code>文件每个数据块对应的扇区号</li></ul><p>位图文件大小为1024/8=128B，目录文件大小为目录项大小*10=20*10=200B</p><blockquote><p>目录项内容包含：</p><ul><li><code>inUser</code>该目录项是否已分配</li><li><code>sector</code>文件头所在的扇区号</li><li><code>name</code>文件名</li></ul></blockquote></blockquote><ol><li>将目录和位图的文件头内容写回到磁盘（0号和1号扇区）中</li><li>打开目录和位图文件</li><li>将位图的数据内容写回磁盘中，因为刚刚的初始化分配了空闲块，位图发生了变化，而目录仍然为空</li><li>文件系统创建完毕</li></ol><h2 id="理解文件系统管理涉及的数据结构组织与使用"><a href="#理解文件系统管理涉及的数据结构组织与使用" class="headerlink" title="理解文件系统管理涉及的数据结构组织与使用"></a>理解文件系统管理涉及的数据结构组织与使用</h2><p>利用命令<code>hexdump –C DISK</code>查看硬盘格式化后硬盘的布局，分析如下：</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316181837619.png" alt></p><ul><li><p>0x0~0x3：起始的4个字节为磁盘标识，设置为<code>magicNum=0x456789ab</code></p></li><li><p>0x4~0x83：0号扇区，共128个字节，存放位图的文件头，细分如下：</p><ul><li><p>0x4~0x7：4个字节，位图所占的字节数。值为<code>0x80</code>，表示位图大小为128字节</p></li><li><p>0x8~0xB：4个字节，系统为位图数据所分配的扇区数。值为<code>0x1</code>，表示位图数据只需1个扇区</p></li><li><p>0xC~0XF：位图数据块所在的扇区号。值为<code>0x2</code>，表示系统将位图数据保存在2号扇区中</p></li><li><p>0x10~0x83：空，因为位图数据只占1个扇区。</p><blockquote><p>每个扇区号占4个字节，所以0xC~0x83最多能存放30个扇区号，所以一个文件大小最大为<code>30*128=3840B</code></p></blockquote></li></ul></li><li><p>0x84~0x103：1号扇区，共128个字节，存放目录的文件头，细分如下：</p><ul><li>0x84~0x87：4个字节，目录所占的字节数。值为<code>0xc8</code>，表示目录大小为200字节</li><li>0x88~0x8B：4个字节，系统为目录数据所分配的扇区数。值为<code>0x2</code>，表示目录数据需要2个扇区</li><li>0x8C~0x8F：系统为目录数据分配的第一个扇区号，值为<code>0x3</code></li><li>0x90~0x93：系统为目录数据分配的第二个扇区号，值为<code>0x4</code></li><li>0x94~0x103：空</li></ul></li><li><p>0x104~0x183：2号扇区，共128个字节，存放位图的数据部分，值为<code>0x1f</code>，表示扇区0,1,2,3,4已被分配</p></li><li><p>0x184~0x203：3号扇区 + 0x204~0x283：4号扇区 </p><p>这两个扇区存放目录表，目前为空，值为<code>0x0</code></p></li></ul><h2 id="理解创建一个文件后相关的结构在硬盘上的存储布局"><a href="#理解创建一个文件后相关的结构在硬盘上的存储布局" class="headerlink" title="理解创建一个文件后相关的结构在硬盘上的存储布局"></a>理解创建一个文件后相关的结构在硬盘上的存储布局</h2><p>利用命令<code>nachos –cp ./test/small samll</code>复制small文件硬盘DISK中</p><p>利用命令<code>hexdump –C DISK</code>查看新建一个文件后的硬盘布局，分析如下：</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316190040837.png" alt></p><ul><li><p>0x0~0x3：磁盘标识符，不变</p></li><li><p>0x4~0x83：0号扇区，存放位图文件头，内容不变</p></li><li><p>0x84~0x103：1号扇区，存放目录文件头，内容不变</p></li><li><p>0x104~0x183：2号扇区，存放位图数据部分，由<code>0x1f</code>变为<code>0x7f</code>，说明5号和6号扇区也被分配使用，即分配给small文件头和文件内容</p></li><li><p>0x184~0x203：3号扇区，存放目录表，发生改变。因为新建了文件small，所以需要在一个空闲的目录项中添加small对应的信息：</p><ul><li>0x184~0x187：4个字节，<code>inUse</code>该目录项是否已被使用（虽然为bool类型，但为了对齐，分配4个字节）。值为<code>0x1</code>，说明该目录项正被一个文件使用</li><li>0x188~0x18B：4个字节，<code>sector</code>该目录项所记录的文件的文件头所在的扇区号。值为<code>0x5</code>，说明small文件的文件头在5号扇区，若要考察small的详细信息，则要到5号扇区访问其文件头</li><li><p>0x18C~0x195：10个字节，<code>name</code>文件名（文件名占用9个字节，最后一个字节是字符串结束符<code>\0</code>）。这里的文件名经过转码为<code>small</code></p></li><li><p>0x196~0x203：其余目录项为空</p></li></ul></li><li><p>0x204~0x283：4号扇区，存放目录表，依旧为空</p></li><li><p>0x284~0x303：5号扇区，存放small的文件头</p><ul><li>0x284~0x287：4个字节，文件所占的字节数。值为`0xc54，表示small文件大小为84字节</li><li>0x288~0x28B：4个字节，系统为文件数据所分配的扇区数。值为<code>0x1</code>，表示small数据需要1个扇区</li><li>0x28C~0x28F：系统为文件数据分配的扇区号。值为<code>0x6</code>，表示系统将small数据保存在6号扇区中</li><li>0x290~0x303：为空</li></ul></li><li><p>0x304~0x383：6号扇区，存放small的文件数据</p></li></ul><h2 id="分析文件系统的管理策略"><a href="#分析文件系统的管理策略" class="headerlink" title="分析文件系统的管理策略"></a>分析文件系统的管理策略</h2><p>复制文件medium, big到DISK中</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316192831856.png" alt></p><p>然后删除small文件</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316192918500.png" alt></p><p>利用<code>hexdump –C DISK</code>查看文件的布局</p><p><img src="/2022/03/28/This-is-NACHOS-1/image-20220316193020855.png" alt></p><ul><li>0x104~0x183：2号扇区，存放位图数据部分。值为<code>0x3f9f</code>，二进制为<code>11111110011111</code>，表示5号和6号扇区空闲，即为small文件的文件头和数据部分占用的扇区</li><li>0x184~0x203：3号扇区，存放目录表。0x184字节处变为<code>0x0</code>，表示为small分配的目录项的<code>inUse</code>位变为0，即为small文件分配的目录项空闲。而该目录项的其他内容不变</li><li>0x284~0x303：5号扇区，存放small的文件头，不变</li><li>0x304~0x383：6号扇区，存放small的文件数据，不变</li></ul><p>分析删除small文件的过程：该文件的目录表中的文件头所在扇区号和文件名、文件头信息、文件数据均未被清除；只是在位图中将该文件的扇区置为空闲，在目录表中将该文件的目录项置为空闲</p><p>因此，要恢复一个被删除的文件，只要该文件的相关信息未被覆盖，就可以根据文件名在目录表中找到该文件对应的目录项，将<code>inUse</code>恢复为1，并在位图中恢复文件头占用的扇区号，再根据文件头的信息恢复文件数据占用的扇区号。</p><p>这种删除文件的策略为恢复文件带来了极大的便利。</p>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统课程设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算作业#2</title>
    <link href="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/"/>
    <url>/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/</url>
    
    <content type="html"><![CDATA[<h1 id="列举威胁作用者有哪些，并简要说明"><a href="#列举威胁作用者有哪些，并简要说明" class="headerlink" title="列举威胁作用者有哪些，并简要说明"></a>列举威胁作用者有哪些，并简要说明</h1><h2 id="匿名攻击者"><a href="#匿名攻击者" class="headerlink" title="匿名攻击者"></a>匿名攻击者</h2><p><strong>是云中没有权限的、不被信任的云服务用户。</strong>它通常是一个<strong>外部</strong>软件程序，通过公网发动网络攻击。匿名攻击者往往诉诸绕过用户账号或窃取用户证书的手段，同时使用能确保匿名性或需要大量资源才能被检举的方法。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316154044175.png" alt="anonymous attacker"></p><h2 id="恶意服务作用者"><a href="#恶意服务作用者" class="headerlink" title="恶意服务作用者"></a>恶意服务作用者</h2><p><strong>截取网络通信，试图恶意地使用或篡改数据。</strong>它通常是带有被损害的或恶意逻辑的服务代理，或是伪装成服务代理的程序，或是能够远程截取并破坏消息内容的外部程序。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316154320361.png" alt="malicious service agent"></p><h2 id="授信的攻击者"><a href="#授信的攻击者" class="headerlink" title="授信的攻击者"></a>授信的攻击者</h2><p><strong>是经过授权的云服务用户，具有合法的证书。</strong>他们会滥用合法的证书或挪用敏感和保密的信息，在云的信任边界内部发动攻击，将云提供者以及与他们共享IT资源的云租户作为攻击目标。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316154954084.png" alt="trusted attacker"></p><h2 id="恶意的内部人员"><a href="#恶意的内部人员" class="headerlink" title="恶意的内部人员"></a>恶意的内部人员</h2><p><strong>是试图滥用对云资源范围的访问特权的人。</strong>他们通常是现任或前任雇员，或是能够访问云提供者资源范围的第三方。这种类型的威胁作用者会带来极大的破坏的可能性，因为恶意的内部人员可能拥有访问云用户IT资源的管理特权。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316155223495.png" alt="malicious insider"></p><h1 id="列举云安全威胁有哪些，并简要说明"><a href="#列举云安全威胁有哪些，并简要说明" class="headerlink" title="列举云安全威胁有哪些，并简要说明"></a>列举云安全威胁有哪些，并简要说明</h1><h2 id="流量监听"><a href="#流量监听" class="headerlink" title="流量监听"></a>流量监听</h2><p>数据在传输到云中或在云内部传输时<strong>被恶意服务作用者被动地截获</strong>，用于非法的信息收集之目的。这种攻击直接破坏了数据的保密性，可能也破坏了云用户和云提供者之间关系的保密性。由于其被动性，这种攻击更容易长时间进行而不被发现。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316155745470.png" alt="traffic eavesdropping"></p><h2 id="恶意媒介"><a href="#恶意媒介" class="headerlink" title="恶意媒介"></a>恶意媒介</h2><p><strong>消息被恶意服务作用者截获并且被篡改。</strong>这种攻击可能会破坏消息的保密性和完整性，还有可能在把消息转发到目的地之前插入有害数据。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316160005721.png" alt="malicious intermediary"></p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p><strong>使IT资源过载至无法正确运行</strong>。可以由以下方式发起：</p><ul><li>发送伪造的消息或重复的通信请求使云服务上的负载不正常地增加</li><li>网络流量过载，降低响应性，性能下降</li><li>发出多个云服务请求，每个请求都设计成消耗过量的内存和处理资源</li></ul><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316160613891.png" alt="DoS"></p><p>常见的DoS攻击：</p><ul><li>TCP SYN泛洪</li><li>ping泛洪</li><li>UDP泛洪</li><li>缓冲区溢出</li><li>ICMP路由重定向炸弹</li><li>分片炸弹</li></ul><h2 id="授权不足"><a href="#授权不足" class="headerlink" title="授权不足"></a>授权不足</h2><p><strong>错误地授予了攻击者访问权限或是授权太宽泛</strong>，导致攻击者能够访问到本应受保护的IT资源。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161032041.png" alt="lack of authorization"></p><p>这种攻击的一种变种称为<strong>弱认证</strong>，如果使用弱密码或共享账户来保护IT资源就可能导致这种攻击。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161133033.png" alt="weak authentication"></p><h2 id="虚拟化攻击"><a href="#虚拟化攻击" class="headerlink" title="虚拟化攻击"></a>虚拟化攻击</h2><p>虚拟化方法使IT资源共享底层硬件但逻辑上互相独立。云提供者给予云用户对虚拟化的IT资源的管理权限，带来的风险就是<strong>云用户会滥用这种访问权限来攻击底层物理IT资源</strong>。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161535380.png" alt="virtualization attack"></p><h2 id="信任边界重叠"><a href="#信任边界重叠" class="headerlink" title="信任边界重叠"></a>信任边界重叠</h2><p>当云中的物理IT资源由多个云服务用户共享时，他们的信任边界是重叠的。<strong>恶意的云服务用户可以损害其他共享同样信任边界的云服务用户或IT资源</strong>。</p><p><img src="/2022/03/16/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A2/image-20220316161827159.png" alt="trust boundary overlapping"></p>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云计算作业#1</title>
    <link href="/2022/03/09/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A1/"/>
    <url>/2022/03/09/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%BD%9C%E4%B8%9A1/</url>
    
    <content type="html"><![CDATA[<h1 id="云使能技术包括哪些技术组件？用一句话简要说明其关键特征"><a href="#云使能技术包括哪些技术组件？用一句话简要说明其关键特征" class="headerlink" title="云使能技术包括哪些技术组件？用一句话简要说明其关键特征"></a>云使能技术包括哪些技术组件？用一句话简要说明其关键特征</h1><ul><li><p>宽带网络和Internet架构</p><p>云用户和云提供者通常利用Internet进行通信，Internet以无中心的供给和管理模型为基础，不受任何集中式实体的控制</p></li><li><p>数据中心技术</p><p>数据中心用于集中放置IT资源，有利于能源共享、提高共享IT资源使用率以及提高IT人员的效率</p></li><li><p>虚拟化技术</p><p>将物理IT资源转换为虚拟IT资源，提供了硬件无关性、服务器整合、资源复制、对资源池更强的支持和灵活的可扩展性</p></li><li><p>Web技术</p><p>Web技术经常被用于云服务的实现，并在前端用于远程管理云IT资源</p></li><li><p>多租户技术</p><p>一个物理或虚拟服务器运行着一个应用程序，该应用程序允许被多个不同用户共享，每个用户都感觉只有自己在使用该应用程序</p></li><li><p>服务技术</p><p>服务技术是云计算的基石，它形成了“作为服务”的云交付模型的基础</p></li><li><p>数据存储技术</p><p>选择分布式存储方式，采用多个副本存储同一数据或多份备份，在服务上采取并行的方法为用户提供所需服务，高传输率也是其一大特色</p></li><li><p>大规模数据管理技术</p><p>对海量数据进行处理、利用的前提是具备高效的管理大量数据的能力</p></li><li><p>编程模型</p><p>使用户能够简便、轻松地获取云环境下的编程服务</p></li></ul><h1 id="列举至少3种虚拟化软件，并用一句话概括其特点"><a href="#列举至少3种虚拟化软件，并用一句话概括其特点" class="headerlink" title="列举至少3种虚拟化软件，并用一句话概括其特点"></a>列举至少3种虚拟化软件，并用一句话概括其特点</h1><ul><li><p>VMware ESXi</p><p>侧重于服务器虚拟化，技术较成熟，功能也多，支持虚机系统多</p></li><li><p>Xenserver</p><p>重点在于桌面虚拟化，性价比高，网络性能好，适用于快速与大规模部署，支持系统也相对较多</p></li><li><p>Hype-V </p><p>微软开发，起步相对较晚，对于MS的系统较为支持</p></li><li><p>Oracle VM VirtualBox </p><p>开源，支持的系统种类繁多</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Consistency论文阅读</title>
    <link href="/2022/01/23/Consistency%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/01/23/Consistency%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://idl.cs.washington.edu/files/2018-Consistency-InfoVis.pdf">原文地址</a></p></blockquote><h1 id="保持多个视图一致：可视化创作中的约束、验证和异常"><a href="#保持多个视图一致：可视化创作中的约束、验证和异常" class="headerlink" title="保持多个视图一致：可视化创作中的约束、验证和异常"></a>保持多个视图一致：可视化创作中的约束、验证和异常</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>可视化通常以多个出现，或者以单个显示（例如，小型的多个可视化，仪表盘)，或者跨越时间或空间显示（例如，幻灯片，一组仪表板）。然而，现有的可视化设计指南通常关注单个而不是多个视图。仅仅遵循这些指导方针可能会导致有效但不一致的视图（例如，相同的字段在不同的图表中有不同的轴域)，使得解释缓慢且容易出错。此外，很少有人知道如何将一致性与其他设计相平衡，这使得在可视化创作软件中加入一致性机制是很困难的。我们将呈现一份绿野仙踪式的研究，在这项研究中，我们观察了Tableau用户如何在一个从探索到展示的可视化设计场景中实现和牺牲一致性。我们（从之前的工作中）扩展了一组编码特定约束用来定义跨视图的一致性。在我们的研究中将这些约束作为检查单来使用，我们观察到了参与者自发保持一致编码的案例和忽略一致性的警告性案例。参与者们对于警告，做出的回应要么是修改视图以保持一致性，要么是说明他们为什么认为一致性应该被覆盖。我们将参与者的行为和响应分类为约束验证和异常，描述一致性的相对重要性和在各种情况下对其他设计的考虑（例如，数据基数，可用的编码资源，图表布局)。我们讨论将自动一致性检查作为约束满足问题，并提供向用户传达不一致信息的设计意义。</p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>可视化通常以多个的形式创建和呈现。在分析中，用户用不同的变量或编码组合进行实验来寻找使人感兴趣的模型。对于相同的数量字段，在一个视图中用x刻度编码，在另一个视图中可能用一种颜色编码。或者说，一个字段在两个视图中会被不同地筛选，导致不同的x轴域([min;max])。当单独的可视化结合在一起后在指示板或幻灯片演示时，作者可能会忽略相同变量在视图间被不同地编码和不同变量在视图间看起来完全相同之间的不一致性，导致了观众地困惑或误解。</p><p><img src="/2022/01/23/Consistency%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_2.png" alt="Fig. 2"></p><p>可视化系统通常让用户手动选择编码细节以一致地显示数据。然而，对于多视图设计者来说，用户可以依赖的大多数现有的可视化设计标准是不能提供有效信息的。相反，聚焦于单独可视化的标准，比如最大化单张图表中中数据与墨水的比例[28]或给定名词或定量数据字段使用最有效的视觉编码[16]。因此，用户经常<br>不得不设计自己的手动策略来实现编码一致性。例如，一张图显示马力，一张图显示平均马力，作者需要手动调整刻度域以使均值更具有可比性(图2)。这里，决定是否和如何要实现编码一致性需要仔细考虑，因为使刻度具有可比性意味着不仅能充分利用现有空间来描述数据。在理想情况下，可视化工具可以帮助用户<br>确定并决定何时以及如何保持一致性和与其他设计达成平衡。然而，关于作者在创建多个视图时希望在什么时候和达成什么类型的编码一致性目前所知甚少。</p><p>在这项工作中，我们首次密切关注可视化作者在设计多个视图时如何理解并实现视图之间的一致性。我们将展示一项绿野仙踪式受启发的研究的结果，其中，一个“精灵”模拟为一名自动设计助手来评估作者设计过程中作品在不同阶段的一致性。为了使这项研究设计成为可能，我们通过扩展2D多元可视化中不同编码通道的一致性约束集[19]，促进了之前关于可视化的一致性准则[9,19,30]的工作。<br>我们通过观察作者如何感知可视化间各种形式一致性的重要性提供了对于一致性约束的初步验证。我们的工作首次对作者在某些情况下容忍不一致性的逻辑依据进行了详细的描述。最终，我们将描述在可视化创作工具中集成一致性支持的设计意义，该可视化创作工具则是我们研究的产物。</p>]]></content>
    
    
    <categories>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SEEDB论文阅读</title>
    <link href="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.vldb.org/pvldb/vol8/p2182-vartak.pdf">原文地址</a></p></blockquote><h1 id="SEEDB-高效的数据驱动可视化推荐以支持可视化分析"><a href="#SEEDB-高效的数据驱动可视化推荐以支持可视化分析" class="headerlink" title="SEEDB: 高效的数据驱动可视化推荐以支持可视化分析"></a>SEEDB: 高效的数据驱动可视化推荐以支持可视化分析</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>数据分析师通常将建立可视化作为分析工作流中的第一步。但是，当处理高维数据集时，可视化显示相关或期望的数据趋势是很耗时费力的。我们提出了SEEDB，这是一个便于快速可视化分析的可视化推荐引擎：给定要研究的数据子集，SEEDB会智能地探索出可视化空间，评估期望的可视化趋势，并且推荐那些他认为最“有用”或者最“有趣”的方案。推荐有趣可视化的两个主要障碍是(a)规模：在交互时间尺度内评估大量的候选可视化方案并作出响应；(b)实用：确定用于评估可视化有趣程度的合理度量标准。对于前者，SEEDB引入了剪枝优化来快速识别高实用性的可视化，并且通过分享最优方案来最大限度地共享可视化计算。对于后者，第一步我们采用了一个基于偏差的度量标准来实现可视化，同时表明了如何将其推广到其他影响实用性的因素。我们实现了SEEDB，将它作为可以运行在任何数据库管理系统上的中间件。我们的实验表明，我们的架构能够以高准确率识别有趣的可视化。我们的优化使相关行列存储速度提高了多个数量级，并在交互时间尺度内提供了推荐方案。最终，我们通过一项用户研究论证了基于偏差的实用性度量的有效性，以及支持可视化分析的推荐的意义。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h2><p>数据可视化通常是数据分析的第一步。给出一个新的数据集或者是关于现有数据集的一个新问题时，数据分析师需要建立各种各样的可视化感受数据，来发现异常和离群值，并且找出值得进一步研究的模式。然而，当处理高维数据集时，识别显示出有趣变化和数据趋势的可视化并非易事：数据分析师必须手动指定大量的可视化，探究不同属性之间的关系（及其组合），并且检查不同的数据子集，最终才能实现有趣的或有洞察力的可视化。这种手动指定和检查每个可视化的需要妨碍了快速分析和探索。</p><p>在本篇文章中，我们解决了自动识别和推荐可视化的问题。可视化推荐的核心挑战之一是，一个可视化的有趣与否取决于很多因素。在本篇文章中，我们采用了一个简单的标准去评价可视化的有趣程度：如果一个可视化与某些参考（例如另一个数据集、历史数据或是剩余数据）有很大偏差，那么它极有可能是有趣的。虽然它简单，但我们在用户研究中（<a href="#6">第6节</a>）发现，偏差通常可以引导用户走向他们认为有趣的可视化。当然，其他因素也会使一个可视化变得有趣，比如美学，所呈现的数据特定属性（我们的交互工具允许分析师选择感兴趣的属性)，或者数据中的其他类型的趋势(例如在某些情况下缺乏偏差可能是有趣的)。因此，尽管我们的焦点在于大偏差的可视化，但我们开发了一个名为SEEDB的系统，并且它的技术支持很大程度上与有趣程度的特定定义是无关的。在<a href="#7">第7节</a>中，我们将描述如何扩展该系统以支持一个通用的实用性度量标准。</p><p>给定一个特定的趣味性标准（称为效用指标），基于这个指标推荐可视化有以下几个问题：第一，即使对于具有少量属性的中等数据集，需要考虑的可视化的数量也常常是数百或数千；对于一些数据集，单是生成它们的可视化就需要很多分钟（正如我们将在本文中看到的）。第二，评估这些可视化的效用需要对相同的底层数据进行重复计算，浪费时间和计算资源。第三，推荐需要以交互速度给出，需要以略低精度返回可视化结果的近似方法。在我们的系统SEEDB中解决这些挑战和权衡是本文的主要重点。</p><p>我们从一个解释性的示例开始，该示例解释了SEEDB用例，并激发了我们使用基于偏差的效用度量的想法。</p><p><em>例1.1 假设一名记者正在为一篇关于千禧一代的新闻文章进行研究。此前的分析显示，千禧一代比前几代人的结婚年龄更大，这引发了人们对这种变化会对更广泛的社会产生何种影响的疑问。</em></p><p><em>因此，记者正在研究婚姻状况如何影响社会经济指标，如教育和收入等。她利用美国人口普查数据[28]对美国未婚成年人和已婚成年人进行了分析。</em></p><p><em>正如许多分析工作流程中常见的那样，记者首先使用她最喜欢的可视化软件来绘制数据中的各种指标。例如，她可以构建一个图表，将平均收入作为婚姻状况的函数显示出来，将婚姻状况可视化为受教育程度的函数，绘制出与种族和性别的关系，将每周工作时间可视化，等等。根据创建的可视化的类型，可能的可视化的数量会随着数据集中指示器的数量呈指数增长。因此，创建和检查所有可能的可视化很快变得难以处理。</em></p><p><em><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_1.png" alt="Figure 1: Motivating Example"></em></p><p><em>我们已经发现，在许多分析中，显示目标数据（未婚成年人）趋势与参考数据（已婚成年人）趋势的可视化方法可能会引起分析人员的兴趣。例如，从我们的用户研究（<a href="#6">第6节</a>）中，我们知道对于这个特定的任务，分析人员会在图中找到可视化这很有趣，因为它描述的数据属性对于未婚成年人与已婚成年人是不同的。具体来说，图表显示，虽然未婚成年女性和未婚成年男性的资本收益大致相等，但已婚成年女性的资本收益仅为已婚成年男性的一半（图1c）。同一用户研究还显示，图1b是一个分析人员不感兴趣的可视化图。请注意，这张图表显示未婚和已婚成年人的年龄趋势没有不同（图1d）。</em></p><p>上面的例子表明，描述参考偏差的可视化可能会引起分析人员的兴趣；我们在本文中的目标是构建一个系统，该系统使用偏差作为一种手段，从大量潜在的可视化中识别最有趣的可视化。据我们所知，没有一个现有的系统会使用来自参考的变化来推荐可视化。正如前面所提到的，除了基于偏差的度量之外，当然还有许多其他维度可以影响可视化的感知效用，其中一些我们将在<a href="#7">第7节</a>中讨论，并将对这些度量的详细研究留给未来的工作。</p><p>我们对SEEDB的实现整合了端到端数据查询和可视化环境，允许分析师手动生成他们自己的可视化（如Tableau或Spotfire），或者根据需要获得数据驱动的建议，可以使用手动界面进一步细化。我们选择在SEEDB中同时支持自动化和手动交互，因为我们相信混合活动接口[12]对于保持分析人员处于决策圈中并允许他们驱动分析过程是必不可少的。</p><p>在将SEEDB开发为可以在任何数据库系统上运行的中间件层时，我们开发并验证了两种正交技术的使用，以使基于偏差的可视化推荐问题变得易于处理:</p><ul><li>共享计算。我们开发了一套多查询优化技术，以便在候选可视化中共享计算，从而减少了最多40倍的时间。</li><li>剪枝计算。我们开发了剪枝技术，以避免在明显低效用的可视化上浪费计算，并采用了传统基于置信区间的top-k排序[11]和多臂老虎机[38]的技术，进一步减少了5倍的时间。</li></ul><p>最后，我们开发了一个通用的基于阶段的执行框架，该框架允许我们同时利用这两种技术的优点，将执行时间减少了100倍以上，并使许多推荐实时可行。综上所述，本文的贡献有:</p><ul><li>我们构建了一个系统，该系统将参考偏差作为为分析任务找到最有趣的可视化结果的标准（<a href="#2">第2节</a>）</li><li>我们将SEEDB设计为一个中间件层，它可以在任何符合sql的DBMS上运行（<a href="#3">第3节</a>）</li><li>我们将描述SEEDB的执行引擎（<a href="#4">第4节</a>），它使用共享技术在可视化中共享计算（章节4.1）和剪枝技术，以避免低效用的可视化计算（章节4.2）</li><li>我们评估了SEEDB的性能并证明了SEEDB可以在交互的时间尺度上以高精度识别高实用性的可视化（<a href="#5">第5节</a>）</li><li>我们展示了一个受控用户研究的结果，该研究验证了我们基于偏差的效用度量，并根据手工图表构建工具评估了SEEDB，表明SEEDB可以加速有趣的可视化标识（<a href="#6">第6节</a>）</li></ul><p>我们注意到，这项工作建立在我们的短期愿景论文[24]和演示论文[36]中所描述的SEEDB的高层思想之上。</p><h2 id="2-问题描述"><a href="#2-问题描述" class="headerlink" title="2 问题描述"></a><span id="2">2 问题描述</span></h2><p>在OLAP的标准中，以及在可视化分析工具如Tableau和Polaris[1,35]中，我们关注雪花模式数据库$D$。在可视化中，我们将想要进行group-by的属性表示为维度属性$A$，将想要进行聚类的属性表示为度量属性$M$。进一步地，我们用$F$表示度量属性上的潜在聚合函数集(如COUNT, SUM, AVG)。出于可视化的目的，假设我们可以依据任何维度属性$A$对$D$进行分组，并且可以聚合任何度量属性$M$。这就产生了一个两列的表格，可以通过标准的可视化机制（如条形图或趋势线）轻松地进行可视化。(最近的研究表明，柱状图是使用可视化分析工具[22]创建的绝大多数可视化效果。)我们的技术还应用于一般的Polaris表代数[35]，在这里，我们可以一次跨多个属性进行聚合，并group-by多个属性，可能会产生两个以上的列。为了便于阐述，我们在本文中将重点介绍两列结果可视化，可以使用条形图或趋势线方便地进行可视化。</p><p>除了数据库$D$之外，我们假设分析人员表示希望研究由查询$Q$指定的数据子集。SEEDB的目标是推荐具有高效用的$Q$的可视化(我们使用偏差来测量，正如本节中所解释的那样)。我们支持的在$D$上提出的查询Q包含了选择事实表的水平部分和一个或多个维度表的常规查询。从概念上说，我们可以将此视为一个简单的选择查询，连接雪花模式中涉及的所有表的结果。即便如此，我们还可以支持投影和连接，它们的作用是在可视化中分别删除某些列或表。因此，我们在雪花模式上支持一般类型的选择-项目-连接(SPJ)查询。出于本讨论的目的，我们将重点关注连接雪花模式中所有表的结果的简单选择查询。我们注意到这类查询可以满足大多数可视化任务。例如在我们的示例中，$Q$可以从人口普查表中选择记录的任何子集。我们将$Q$的结果表示为$D_Q$。</p><p>每个SEEDB可视化都可以转换为对底层数据进行group-by查询的聚合。我们将一个可视化$V_i$视为一个函数，由一个三元组$(a,m,f)$表示，其中$m\in M, a\in A, f\in F$。我们称它为聚合视图，或者简称为视图。聚合视图对$a$执行group-by，并应用聚合函数$f$来度量属性$m$​。举个例子，$V_i(D)$表示将$D$中的数据按$a$分组，再用$f$对$m$值进行聚合的结果；$V_i(D_Q)$表示应用于$D_Q$中数据的类似的可视化。</p><p>SEEDB通过偏差确定可视化的效用；显示出查询数据集(即$D_Q$)与参考数据集(称为$D_R$)中不同趋势的可视化被认为具有很高的实用性。参考数据集$D_R$可以定义为整个基础数据集$(D)$、$D_Q$的补集$(D-D_Q)$或任意查询$Q’$ 选择的数据$(D_{Q’})$。分析师可以选择指定$D_R$；如果分析师没有指定，我们使用$D_R=D$作为默认值。给定一个视图$V_i$，基于偏差的效用计算结果为应用$V_i$于查询数据$D_Q$和应用$V_i$于参考数据$D_R$的结果偏差。应用$V_i$于查询数据的视图可以表示为下面的查询$Q_T$。我们称之为目标视图。</p><script type="math/tex; mode=display">Q_T=SELECT \ a,f(m)\ FROM\ D_Q \ GROUP\ BY \ a</script><p>类似地，应用$V_i$于参考数据的视图可以表示为$Q_R$。我们称之为参考视图。</p><script type="math/tex; mode=display">Q_R=SELECT\ a,f(m)\ FROM\ D_R\ GROUP\ BY\ a</script><p>对应于每个视图的（两个）SQL查询称为视图查询。上面的视图查询的结果是包含两列的汇总，即$a$和$f(m)$。为了确保所有聚合汇总具有相同的规模，我们将每个汇总归一化为概率分布（即$f(m)$值和为1）。在我们的例子中，平均资本收益与性别的可视化（图1），$V_i(D_Q)$（未婚成年人，数据见表1c）目标视图的概率分布表示为$P[V_i(D_Q)]:(F:0.52,M:0.48)$，而$V_i(D_R)$（已婚成年人，表1c）参考视图的概率分布表示为$P[V_i(D_R)]:(F:0.31,M:0.69)$。相比之下，平均年龄与性别的可视化分布（数据见表1d）为目标视图$(F:0.5,M:0.5)$，参考视图$(F:0.51,M:0.49)$。定性地说，我们看到前者的分布有很大的偏差，而后者几乎没有任何偏差。</p><p>给定聚合视图$V_i$以及目标视图的概率分布$(P[V_i(D_Q)])$和参考视图的概率分布$(P[Vi(DR)])$，我们将$V_i$的效用定义为这两个概率分布之间的距离。两个分布之间的距离越远，可视化就越可能有趣，因此效用也就越高。形式化讲，如果$S$是距离函数，</p><script type="math/tex; mode=display">U(V_i)=S(P[V_i(D_Q)],P[V_i(D_R)])</script><p>计算概率分布之间的距离已经在文献中得到了很好的研究，并且SEEDB支持各种距离函数去计算效用，包括Earth Mover’s Distance, Euclidean Distance, Kullback-Leibler Divergence (K-L divergence), and Jenson-Shannon Distance. SEEDB使用Earth Mover ‘s Distance作为默认的距离函数，我们发现使用其他距离函数可以得到类似的结果[37]。</p><p>我们可以将SEEDB问题正式表述如下：</p><p><em>问题2.1    给定数据库$D$上一个用户指定的查询$Q$，一个参考数据集$D_R$，一个效用函数$U$，和一个正数$k$，需要找到$k$个分类的视图$V\equiv (a,m,f)$，它是所有视图中$U(V)$最大的，同时最小化总计算时间。</em></p><p>在<a href="#7">第7节</a>中，我们将描述如何将我们的度量标准一般化以捕获除偏差之外的与可视化有趣程度有关的因素。</p><h2 id="3-SEEDB前端及架构"><a href="#3-SEEDB前端及架构" class="headerlink" title="3 SEEDB前端及架构"></a><span id="3">3 SEEDB前端及架构</span></h2><p>我们现在描述SEEDB的前端用户体验，然后更详细地描述体系结构和执行引擎。</p><p><strong>前端体验。</strong>SEEDB的可视化推荐功能被打包成端到端的可视化分析环境，带有基本的可视化功能，比如由Tableau提供的功能。SEEDB前端允许分析人员手动生成可视化，或者根据需要获得数据驱动的建议，这些建议可以使用手动界面进一步细化。我们将前端设计成一个混合式驱动界面，以保持人在决策圈内，并允许用户控制分析。图2显示了SEEDB的web前端所包含的四个部分：(A)用于连接数据库的数据集选择器和用于规定查询的查询创建器；(B)用于手动指定可视化的可视化生成器；(C)可视化显示面板；(D)显示推荐的可视化效果的推荐插件。由SEEDB提供的推荐会变化，以响应数据库发出的查询(A)中的变化。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_2.png" alt="Figure 2: SEEDB Frontend"></p><p><strong>架构概述。</strong>SEEDB作为一个中间件层被实现，它可以运行在任何符合sql标准的数据库系统之上。图3描述了系统的总体架构。SEEDB客户端是一个基于web的前端，它捕获用户的输入并渲染呈现由SEEDB服务器产生的可视化结果。SEEDB服务器由两个主要组件组成：视图生成器负责解析输入查询、查询系统元数据和生成必须被评估的可视化查询列表；执行引擎的目标是使用我们在底层DBMS上的优化来评估查询集合。所选中的聚合视图（例如，那些有很大偏差的视图）被发送到SEEDB客户端，并作为可视化建议显示给用户，然后用户可以与这些可视化进行交互。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_3.png" alt="Figure 3: SEEDB Architecture"></p><p><strong>基础执行引擎</strong>。为了激发对优化的需求，我们首先描述执行引擎在没有优化的情况下是如何工作的。为了确定$k$个最佳聚合视图，SEEDB需要做以下工作：对于每个聚合视图，它生成一个对应于目标视图和引用视图的SQL查询，并向底层DBMS发出这两个查询。它对每个聚合视图重复这个过程。当接收到结果时，它计算目标和参考视图分布之间的距离，并识别具有最高效用的$k$可视化结果。这个基础实现有许多低效之处。在一张具有$a$个维度属性、$m$个度量属性和$f$个聚合函数的表上，$2\times f\times a\times m$个查询需要被执行。正如我们在第五节中说明的，对于大的数据集，这需要耗费$&gt;100s$的时间。这种延迟对于交互使用是不可接受的。</p><p><strong>优化执行引擎。</strong>为了减少评估聚合视图集的延迟，SEEDB引擎应用了两种优化：共享，聚合视图查询被组合在一起，以尽可能地共享计算；以及剪枝，在不扫描整个数据集的情况下，将与低效用可视化相对应的聚合视图查询删除。这些优化在很大程度上是相互正交的。为了从这两种优化中获益，我们开发了一个分阶段执行框架。每个阶段对数据集的一个子集进行操作。阶段$n$的第$i$个对数据集的$n$个大小相等的分区中的第$i$个进行操作。例如，假设我们有$100,000$条记录和$10$个阶段，那么阶段$i=4th$就会处理记录$30,001$~$40,000$。执行引擎从在考虑范围内的整个聚合视图集开始。在阶段$i$期间，SEEDB使用数据集的第$i$个部分更新仍在考虑中的视图的部分结果。执行引擎应用基于共享的优化来最小化数据集的第$i$个部分上的扫描代价。在阶段$i$的末尾，执行引擎使用基于剪枝的优化来确定要丢弃哪些聚合视图。从部分1到$i$的每个聚合视图的结果都被用来估计每个视图的质量，而那些效用较低的视图则被丢弃。然后在第$i+1$轮处理保留的聚合视图，并继续这个过程。通过这种方式，在这些阶段中考虑的视图集减小，在第$1$阶段开始时所有的聚合视图，在第$n$阶段结束时只剩下$k$个视图。</p><h2 id="4-SEEDB执行引擎"><a href="#4-SEEDB执行引擎" class="headerlink" title="4 SEEDB执行引擎"></a><span id="4">4 SEEDB执行引擎</span></h2><p>在本节中，我们将描述用于有效生成可视化推荐的共享和修剪优化。我们的扩展技术报告[37]描述了额外的离线预计算和剪枝技术。</p><h3 id="4-1-基于共享的优化"><a href="#4-1-基于共享的优化" class="headerlink" title="4.1 基于共享的优化"></a>4.1 基于共享的优化</h3><p>在执行引擎的基本实现中，每个可视化被转换为在DBMS上独立执行的两个视图查询。然而，对于特定的用户输入，由SEEDB评估的查询非常相似：它们扫描相同的底层数据，不同的只是用于分组和聚合的属性。这为智能地合并和批处理查询提供了机会，从而减少了向数据库发出查询的数量，进而减少了底层数据的扫描次数。我们设置中的共享计算是一般多查询优化问题[33]的一个特例；我们将在<a href="#8">第8节</a>更详细地讨论这种关系。具体来说，我们应用了以下优化：</p><p><strong>合并多个聚合</strong>：具有相同group-by属性的聚合视图查询可以被重写为具有多个聚合的单个查询。因此，对于视图$(a_1,m_1,f_1),(a_1,m_2,f_2)…(a_1,m_k,f_k)$，每个都需要执行两次查询，我们可以将这些视图合并为一个视图$(a,\{m_1,m_2…m_k\},\{f_1,f_2…f_k\})$来代替，总共只需要两次查询。我们发现，合并行和列存储中的聚合对延迟的影响很小，甚至没有影响。</p><p><strong>合并多个group-by</strong>：在应用了我们的多个聚合优化之后，SEEDB剩下了许多具有多个聚合的查询，但只有单属性分组。这些查询可以进一步组合，以利用多属性分组的优势。但是，与合并多个聚合不同，添加分组属性会显著增加必须维护的组的数量，并且(可能)导致大量组的整体性能下降。</p><p>我们声明（并在<a href="#5">第5节</a>中验证），只要保持分组的内存利用率在一个阈值以下，分组就可以提高性能。而内存利用率又与查询中出现的不同组的数量成比例。如果一组属性$a_1…a_m$被用于分组，那么不同组的数量上界由$\prod_{i=1}^m|a_i|$决定。给定一个内存预算$S$，现在的挑战是确定最优的属性分组，使每个组都尊重内存预算。</p><p><em>问题4.1（最优分组）    给定内存预算$S$和一组维度属性$A={a_1…a_n}$，将维度属性A分组为$A_1,…,A_l$(其中$A_i\subseteq A,\bigcup A_i=A$ )，使得查询$Q$根据任意$A_i$对表进行分组，$Q$的内存利用率都不超过$S$。</em></p><p>注意到上述问题与NP-Hard装箱问题[18]同构，如果我们让每个维度属性$a_i$对应于装箱问题中带有重量$\log|a_i|$的一个物品，并且将箱子的大小设置为$\log S$，然后将这些物品装入箱子中，这与寻找组$A_1,…,A_l$是相同的，这样任何组的估计内存利用率都低于$S$。我们使用标准的首次适应算法[14]来寻找维度属性的最优分组。</p><p><strong>合并目标视图和引用视图查询</strong>：因为目标视图和引用视图仅在执行查询的数据子集上不同，所以SEEDB将这两个视图查询重写为一个。例如，假设目标视图为$Q1$，参考视图为$Q2$，它们可以被合并为一个视图$Q3$。</p><script type="math/tex; mode=display">\begin{aligned}Q1&=SELECT \ a,f(m) \ FROM\ D\ WHERE\ x<10\ GROUP\ BY\ a\\Q2&=SELECT \ a,f(m) \ FROM\ D\ GROUP\ BY\ a\\Q3&=SELECT \ a,f(m),CASE\ IF\ x<10\ THEN\ 1\ ELSE\ 0\ END\\&as\ g1,1\ as\ g2\ FROM\ D\ GROUP\ BY\ a,g1,g2\end{aligned}</script><p><strong>并行查询执行</strong>：SEEDB并行执行多个视图查询，因为这些查询通常可以共享缓冲池页面，从而减少磁盘访问时间。然而，精确的并行查询数目需要考虑缓冲池争用、锁定和缓存线争用等因素进行调优。</p><h3 id="4-2-基于剪枝的优化"><a href="#4-2-基于剪枝的优化" class="headerlink" title="4.2 基于剪枝的优化"></a>4.2 基于剪枝的优化</h3><p>实际上，大多数可视化都是低效用的，这意味着计算它们会浪费计算资源。因此，如前所述，在每个阶段的末尾，执行引擎使用剪枝优化来确定要丢弃哪些聚合视图。具体来说，基于到目前为止处理的数据，每个视图的部分结果被用于估计效用，而低效用的视图被删除。SEEDB执行引擎支持两种剪枝方案：第一种使用置信区间技术来绑定视图的效用；第二种使用多臂老虎机分配策略来找到顶级效用视图。</p><p><strong>基于置信区间的剪枝。</strong>我们的第一个剪枝方案使用最坏情况统计置信区间来约束视图效用。这种技术（称为CI）类似于在其他背景中开发的基于top-k的剪枝算法[13,27]。我们的方案如下：在每个阶段，我们对每个聚合视图$V_i$保留一个平均效用的估计值，并在该均值附近设置一个置信区间。在一个阶段结束时，我们使用以下规则来剪枝低效用视图：<em>如果视图$V_i$的效用上界低于$k$个或更多视图的效用下界，则$V_i$被丢弃。</em>举例来说，假设一个数据集有4个视图$V_1…V_4$，我们想要找出排行前二的视图。进一步假设在阶段$i$结束时，$V_1$-$V_4$具有如图4所示的置信区间。到此为止，视图$V_1$和$V_2$的效用估计最高，可能在前二视图中。视图$V_3$目前不在前二中，但它的置信区间与前二重叠，这使得$V_3$有可能取代$V_1$或$V_2$。另一方面，$V_4$的置信区间完全低于$V_1$和$V_2$的置信区间。因为我们很大程度上可以断言$V_4$的效用在它的置信区间内，也就是说，$V_4$的效用很有可能比$V_1$和$V_2$的效用都低，它也不会出现在前二视图中。我们的修剪方案的伪代码可以在我们的技术报告[37]中找到。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_4.png" alt="Figure 4: Confidence Interval based Pruning"></p><p>我们使用从Hoeffding-Serfling不等式[34]得到的最坏情况下的置信区间。这个不等式声明了假设给定$[0,1]$上均值为$\mu$的$N$个值$y_1,…,y_N$，而且有$m$个不需要替代的值$Y_1,…,Y_m$，然后我们可以计算这$m$个值的当前均值附近的运行置信区间，使得$N$的实际均值总是以$1-\delta$的概率在这个置信区间内：</p><p><em>定理4.1    $\forall \delta&gt;0$，对于$1\le m\le N-1$，定义</em></p><script type="math/tex; mode=display">\varepsilon_m=\sqrt{\frac{(1-\frac{m-1}{N})(2\log\log(m)+\log(\pi^2/3\delta))}{2m}}\\then: Pr[\exists m,1\le m\le N: |\frac{\sum_{i=1}^mY_i}{m}-\mu|>\varepsilon_m]\le \delta</script><p>在我们的设置中，每个$Y_i$对应的是根据迄今为止看到的记录计算出的效用估计值。</p><p><strong>基于多臂老虎机的剪枝。</strong>我们的第二个剪枝方案采用了一个多臂老虎机策略[38]。在MAB中，一种在线算法通过一系列的试验从一组可选臂中重复地进行选择来最大化回报。我们注意到，这是老虎机策略第一次被应用于识别有趣的可视化效果的问题。</p><p>最近研究的MAB变体集中于寻找具有最高平均奖励的臂[5,4]。这种变化与SEEDB处理的问题相同：我们的目标是找到可视化（臂）和最高的效用（奖励）。具体来说，我们采用[5]的连续接受和拒绝算法来寻找具有最高平均奖励的臂。在每个阶段结束时，仍在考虑中的视图按其效用平均值排序。然后我们计算出效用平均值之间的两个差异：$\Delta_1$是最高均值和第$k+1$高均值的差值，$\Delta_n$是最低均值和第$k$高均值的差。如果$\Delta_1$比$\Delta_n$大，那么均值最高的视图被”接受”为top-k的一部分（它不再参与剪枝计算）。另一方面，如果$\Delta_n$更大，那么在运行过程中均值最低的视图将从视图集合中被丢弃。伪代码可以在技术报告[37]中找到。[5]证明了在一定的奖励分配假设下，上述技术识别出了高概率的top-k臂。</p><p><strong>一致的距离函数。</strong>注意到上面描述的两个修剪方案在其他设置中都有前提条件，这些条件不会直接转移到我们的设置中。比如，MAB设置假设每个试验的样本来自一个固定的底层分布，而实际上我们的试验对应于$m$个分布（组）中的随机值，它们聚合在一起形成给定视图的效用估计。在我们的评估中，我们发现尽管有这个限制，修剪方案在实践中工作得相当好。</p><p>然而，我们可以得到一个较弱的前提：我们可以证明，当我们采样越来越多时，估计的效用$\hat{U}$可以任意接近于所有聚合视图的$U$。本质上，这意味着使用足够大样本的修剪算法（如CI和MAB）将以高概率删除低效用视图。我们可以这样形式化地表示这个性质。</p><p><em>性质4.1（一致性）    使目标和参考可视化都有$m$个组。$\hat{U}$表示基于$m$组均匀随机样本所估计的效用值$U$。那么随着样本个数趋于$\infty$，$\hat{U}$以$1-\delta$的概率趋于$U$，$\delta$越小越好。</em></p><p>我们称具有这个性质的距离函数为一致距离函数。一致的距离函数允许剪枝方案随着时间的推移收集越来越好的效用值估计（只要样本足够大）。在扩展的技术报告[37]中，我们用Hoeffding不等式证明了这个性质对于欧几里德距离是成立的。我们在5.4节和[37]的结果以经验为主地表明，基于CI和MAB的修剪方案适合各种指标，包括基于EMD的偏差、基于欧氏距离的偏差，以及根据目标分布和参考分布中各自组之间的差异对可视化进行排序的MAX_DIFF指标。</p><h2 id="5-性能评估"><a href="#5-性能评估" class="headerlink" title="5 性能评估"></a><span id="5">5 性能评估</span></h2><p>在接下来的两个部分中，我们将从返回可视化时的性能和用户研究两方面对SEEDB进行评估。在这两部分中，我们报告了在表1中列出的各种真实和合成数据集上的SEEDB结果。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Table_1.png" alt="Table 1: Datasets used for testing"></p><p>在本节中，我们将重点放在性能研究上，我们的目标是评估我们的共享和剪枝优化如何改善延迟，以及我们的剪枝优化如何影响准确性。在每个实验中，我们主要的评估指标是延迟，也就是说，SEEDB返回top-k可视化需要多长时间。对于涉及我们的剪枝策略的实验，我们通过两个额外的度量来衡量结果的质量，即准确性和效用距离（在第5.4节中进一步讨论）。因为我们期望数据布局会影响我们的优化效果，所以我们在面向行数据库（记作ROW）和面向列数据库（记作COL）上评估了我们的技术。</p><p>下面的实验使用EMD距离作为我们计算偏差的距离函数。所有的实验都是在一台8 GB RAM、16核Intel Xeon E5530处理器的机器上运行的。除非另有说明，否则我们报告三次运行的平均测量结果。我们首先总结了实验结果，然后深入研究各个优化的性能结果。</p><h3 id="5-1-结果总结"><a href="#5-1-结果总结" class="headerlink" title="5.1 结果总结"></a>5.1 结果总结</h3><p>图5.a和5.b通过表1中四个真实数据集(BANK、DIAB、AIR和AIR10)显示了SEEDB的表现概况。对于每个数据集，我们将显示在ROW和COL通过基本的SEEDB框架(NO OPT)存储并应用共享优化(SHARING)与剪枝优化(COMB)后的延迟。我们还展示了使用COMB (COMB_EARLY)产生早期结果的延迟，在这里，我们会在确定了top-k的可视化后返回近似结果。图5中的结果使用了置信区间(CI)修剪方案，k=10。</p><p><img src="/2022/01/18/SEEDB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/Figure_5.png" alt="Figure 5: Performance gains from all optimizations"></p><ul><li><p>【&gt;100X的总体提速】 我们的共享和修剪优化的结合提供了50X的提速(COMB)</p><p>- 300X用于于ROW (COMB EARLY)(图5a)和10X (COMB)</p><p>- 30X用于COL(COMB EARLY)(图5b)。这将小型数据集(如DIAB)的延迟从12秒缩短到200ms，大型数据集(如AIR10)的延迟从2小时缩短到数十秒。</p></li><li><p>【6-40X的共享提速】 共享优化(章节4.1)单独产生用于ROW的高达40X的性能增益和用于COL的6X提速</p></li><li><p>【5X的不损失精度的剪枝提速】 修剪优化(章节4.2)提供高达5X的额外增益。特别是，早期的结果返回能够实现对大型数据集的实时响应，例如，对于AIR, COMB_EARLY策略能使在处理完整数据集需要数十秒时，SEEDB在不到4s的时间内返回结果。我们还发现，修剪对结果的质量没有负面影响：我们的剪枝策略的效用距离(稍后定义)接近于0。</p></li><li><p>【乘数增益】 用于ROW存储的共享优化带来的40X增益与剪枝优化带来的5X增益相结合可以产生超过200X的总体增益(图5a)。</p></li><li><p>【在更大的数据集上的增益提高】AIR10 (300X)的总体增益要比BANK (10X)大得多。我们发现我们的共享优化最适合于像BANK和DIAB这样的小数据集，而COMB和COMB_EARLY对于像AIR和AIR10这样的大数据集是必不可少的。</p></li></ul><h2 id="6-用户研究"><a href="#6-用户研究" class="headerlink" title="6 用户研究"></a><span id="6">6 用户研究</span></h2><h2 id="7-效用指标-讨论"><a href="#7-效用指标-讨论" class="headerlink" title="7 效用指标: 讨论"></a><span id="7">7 </span>效用指标: 讨论</h2><h2 id="8-相关工作"><a href="#8-相关工作" class="headerlink" title="8 相关工作"></a><span id="8">8 相关工作</span></h2><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9 结论"></a>9 结论</h2><h2 id="10-参考文献"><a href="#10-参考文献" class="headerlink" title="10 参考文献"></a>10 参考文献</h2>]]></content>
    
    
    <categories>
      
      <category>paper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU机器学习试题回忆</title>
    <link href="/2022/01/15/MLmemory/"/>
    <url>/2022/01/15/MLmemory/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1 线性回归和正则化 (15’)</p></blockquote><p>求线性回归的Hessian矩阵</p><p>证明对于线性回归，使用牛顿法，迭代⼀次即得最优解$\theta^*=(X^TX)^{-1}X^T\vec{y}$</p><p>证明对于正则化的线性回归，使用牛顿法，迭代⼀次即得最优解$\theta^*=(X^TX+\lambda L)^{-1}X^T\vec{y}$</p><blockquote><p>2 朴素贝叶斯的计算 (20’)</p></blockquote><p>计算所有$p(Y),p(x_i|Y)$</p><p>结果为$arg \max_y P(y)\prod P(x_i|y)$</p><blockquote><p>3 Soft-Margin SVM的变体 (30’)</p></blockquote><p>证明约束条件$\xi_i \ge 0$不用显式给出</p><p>写出原问题的KKT条件</p><p>写出原问题的对偶问题</p><blockquote><p>4 EM的变体 将原始M-step改用梯度上升法 (20’)</p></blockquote><p>证明收敛性</p><p>证明正确性即两式求导结果相等</p><blockquote><p>5 论述 (15’)</p></blockquote><p>K-means步骤</p><p>PCA步骤</p><p>Bias, Variance, Complexity关系</p>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU计算机图形学复习笔记</title>
    <link href="/2022/01/15/CGreview/"/>
    <url>/2022/01/15/CGreview/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="计算机图形学的主要研究内容是什么？"><a href="#计算机图形学的主要研究内容是什么？" class="headerlink" title="计算机图形学的主要研究内容是什么？"></a>计算机图形学的主要研究内容是什么？</h2><p>计算机中图形的表示方法，以及利用计算机进行图形的计算、处理和显示的相关原理与算法</p><h2 id="列举三个以上图形学的应用领域"><a href="#列举三个以上图形学的应用领域" class="headerlink" title="列举三个以上图形学的应用领域"></a>列举三个以上图形学的应用领域</h2><p>计算机辅助设计与制造（CAD/CAM）</p><p>可视化</p><p>真实感图形实时绘制与自然景物仿真</p><p>计算机动画</p><p>用户接口</p><p>计算机艺术</p><h2 id="一个图形系统通常由哪些图形设备组成？"><a href="#一个图形系统通常由哪些图形设备组成？" class="headerlink" title="一个图形系统通常由哪些图形设备组成？"></a>一个图形系统通常由哪些图形设备组成？</h2><p>图形处理器、图形输入设备和输出设备</p><h2 id="图形和图像的区别是什么？"><a href="#图形和图像的区别是什么？" class="headerlink" title="图形和图像的区别是什么？"></a>图形和图像的区别是什么？</h2><p>图像：计算机内以位图形式存在的灰度信息</p><p>图形：含有几何属性，由场景的几何模型和景物的物理属性共同组成的</p><h2 id="CRT显示器的原理是什么？"><a href="#CRT显示器的原理是什么？" class="headerlink" title="CRT显示器的原理是什么？"></a>CRT显示器的原理是什么？</h2><p>高速的电子束由电子枪发出，经过聚焦系统、加速系统和磁偏转系统就会到达荧光屏的特定位置</p><h2 id="LCD有哪些技术指标？"><a href="#LCD有哪些技术指标？" class="headerlink" title="LCD有哪些技术指标？"></a>LCD有哪些技术指标？</h2><p>可视角度 CR10、CR5</p><p>点距</p><p>分辨率</p><h2 id="有哪些常用的图形输入设备？"><a href="#有哪些常用的图形输入设备？" class="headerlink" title="有哪些常用的图形输入设备？"></a>有哪些常用的图形输入设备？</h2><p>键盘、鼠标</p><p>跟踪球、空间球、数据手套、光笔、触摸屏</p><h2 id="图形学之父"><a href="#图形学之父" class="headerlink" title="图形学之父"></a>图形学之父</h2><p>Ivan E. Sutherland</p><h2 id="ACM-Siggraph最高奖以谁的名字命名"><a href="#ACM-Siggraph最高奖以谁的名字命名" class="headerlink" title="ACM Siggraph最高奖以谁的名字命名"></a>ACM Siggraph最高奖以谁的名字命名</h2><p>Steven A. Coons</p><h1 id="第二章-光栅图形学"><a href="#第二章-光栅图形学" class="headerlink" title="第二章 光栅图形学"></a>第二章 光栅图形学</h1><h2 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h2><h3 id="数值微分法（DDA）"><a href="#数值微分法（DDA）" class="headerlink" title="数值微分法（DDA）"></a>数值微分法（DDA）</h3><p>增量思想：对于直线y=kx+b，x每递增1，y则递增k</p><p>在该算法中，y和k都要用浮点数表示，且每一步都需要对y四舍五入取整，不适合硬件实现</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDALine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br> <span class="hljs-keyword">float</span> dx, dy, y, k;<br>    dx = x1-x0;<br>    dy = y1-y0;<br>    k = dy/dx;<br>    y = y0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=x0; x&lt;=x1; x++)&#123;<br>        drawpixel(x, <span class="hljs-keyword">int</span>(y+<span class="hljs-number">0.5</span>));<br>        y += k;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h3><p>采用了直线的一般形式：F(x,y)=Ax+By+C=0，其中A=-dy，B=dx</p><p>画直线段过程中当前像素点为(x0,y0)，下一个像素点有两种选择P1(x0+1,y0), P2(x0+1,y0+1)，设M(x0+1,y0+0.5)是P1P2中点，Q为理想直线与x=x0+1的交点，当M在Q下方时F(M)<0，下一个像素点为P2，当M在Q上方时F(M)>0，下一个像素点为P1</0，下一个像素点为P2，当M在Q上方时F(M)></p><p>采用增量计算，令d=F(M)=a+0.5b，取正右方P1后判断下一个像素时d1=d+a，取右上方P2后判断下一个像素时d2=d+a+b</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MidpointLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a, b, d1, d2, d, x, y;<br>    a = y0-y1;<br>    b = x1-x0;<br>    d = <span class="hljs-number">2</span>*a+b;<br>    d1 = <span class="hljs-number">2</span>*a;<br>    d2 = <span class="hljs-number">2</span>*(a+b);<br>    x = x0, y = y0;<br>    <span class="hljs-keyword">while</span>(x&lt;x1)&#123;<br>        <span class="hljs-keyword">if</span>(d&lt;<span class="hljs-number">0</span>)&#123;<br>            x++;<br>            y++;<br>            d += d2;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            x++;<br>            d += d1;<br>        &#125;<br>        drawpixel(x, y);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h3><p>过各行各列像素中心构造一组虚拟网格线，按照直线起点到终点的顺序计算直线与各垂直网格线的交点，根据误差项的符号确定该列像素中与此交点最近的像素</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">IntegerBresenhamLine</span><span class="hljs-params">(x0, y0, x1, y1)</span></span>&#123;<br>    x = x0;<br>    y = y0;<br>    dx = x1-x0;<br>    dy = y1-y0;<br>    e = -dx;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;=dx; i++)&#123;<br>        drawpixel(x, y);<br>        x++;<br>        e += <span class="hljs-number">2</span>*dy;<br>        <span class="hljs-keyword">if</span>(e&gt;=<span class="hljs-number">0</span>)&#123;<br>            y++;<br>            e -= <span class="hljs-number">2</span>*dx;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="多边形的扫描转换"><a href="#多边形的扫描转换" class="headerlink" title="多边形的扫描转换"></a>多边形的扫描转换</h2><blockquote><p>多边形有两种重要的表示方法：顶点表示和点阵表示</p><p>多边形的顶点表示转换为点阵表示，这种转换称为多边形的扫描转换</p></blockquote><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>按扫描线顺序，计算扫描线与多边形的相交区间，再用要求的颜色显示这些区间的像素，以完成填充工作</p><p>对于一条扫描线，多边形的扫描步骤为：</p><ol><li>求交。计算扫描线与多边形各边的交点</li><li>排序。把所有交点按照x值递增顺序排序</li><li>配对。将第一个与第二个、第三个与第四个等交点配对，每对交点代表扫描线与多边形的一个相交区间</li><li>填色。把相交区间内的像素置成多边形的颜色，把相交区间外的像素置成背景色</li></ol><p>涉及的数据结构：</p><ul><li><p>活性边表AET：为提高效率，在处理一条扫描线时仅对与它相交的多边形的边进行求交运算，与当前扫描线相交的边称为活性边，把活性边按与扫描线交点x坐标递增的顺序存放在一个链表中，该链表为AET</p><p>结点内容：</p><ol><li><p>当前扫描线与边的交点坐标x值</p></li><li><p>从当前扫描线到下一条扫描线间x的增量$\Delta x$</p></li><li><p>该边所交的最高扫描线号$y_{max}$</p></li></ol></li><li><p>新边表NET：为方便AET的建立与更新，为每一条扫描线建立一个NET，存放在该扫描线第一次出现的边</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scanLinePolyFill</span><span class="hljs-params">(polygon)</span></span>&#123;<br>    <span class="hljs-comment">//初始化新边表NET</span><br>    <span class="hljs-keyword">for</span>(各条扫描线i)&#123;<br>        初始化NET[i]头指针;<br>        把ymin=i的边放入NET[i]中;<br>    &#125;<br>    <span class="hljs-comment">//扫描准备</span><br>    初始化AET为空;<br>    y=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//开始扫描</span><br>    <span class="hljs-keyword">for</span>(各条扫描线i)&#123;<br>        <span class="hljs-comment">//加入边</span><br>        将NET[i]中的边插入排序到AET中;<br>        若要自交,则对AET冒泡排序;<br>        <span class="hljs-comment">//区间填色</span><br>        遍历AET，配对交点区间，对区间上的点改写像素值;<br>        <span class="hljs-comment">//删除边 </span><br>        删除ymax=i的边;<br>        <span class="hljs-comment">//更新AET</span><br>        将AET中结点的x值递增dx;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="边界标志算法"><a href="#边界标志算法" class="headerlink" title="边界标志算法"></a>边界标志算法</h3><p>帧缓冲器对多边形进行直线扫描转换时在边界像素打上标志，再采用和扫描线算法类似的方法将位于多边形的各个区间填色。适合硬件实现</p><h2 id="多边形的区域填充"><a href="#多边形的区域填充" class="headerlink" title="多边形的区域填充"></a>多边形的区域填充</h2><blockquote><p>这里的区域是指已经表示成点阵形式的填充图形，它是像素的集合</p><p>区域可采用内点表示和边界表示</p><p>区域可分为四连通区域和八连通区域（容易穿出脆弱边界）</p></blockquote><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>假设在多边形内有一个像素已知，由此出发利用连通性找到区域内的所有像素</p><h3 id="扫描线算法-1"><a href="#扫描线算法-1" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>给定种子点时，首先填充种子点所在扫描线上位于给定区域的一个区间，然后确定与这一区间相连通的上下两条扫描线上位于给定区域内的区间，并依次保存下来，反复这个过程直到填充结束</p><p>区域填充的扫描线算法步骤：</p><ol><li>初始化。堆栈置空，将种子点(x,y)入栈</li><li>出栈。若栈空则结束；否则取栈顶元素(x,y)，以y作为当前扫描线</li><li>填充并确定种子点所在区段。从种子点(x,y)出发，沿当前扫描线向左、右两个方向填充，直到边界。分别标记区段的左右端点坐标为xl和xr</li><li>确定新的种子点。在区间[xl,xr]中检查与当前扫描线y上下相邻的两条扫描线上的像素。若存在非边界、未填充的像素，则把每一区间的最右像素作为种子点压入堆栈，返回第2步</li></ol><h2 id="直线段裁剪"><a href="#直线段裁剪" class="headerlink" title="直线段裁剪"></a>直线段裁剪</h2><h3 id="Cohen-Sutherland法"><a href="#Cohen-Sutherland法" class="headerlink" title="Cohen-Sutherland法"></a>Cohen-Sutherland法</h3><p>对线段端点进行编码<code>code1</code> <code>code2</code>，判断直线段与窗口的关系，分为三种情况：</p><ol><li><p>全在窗口内，显示该线段；<code>code1 | code2 == 0</code></p></li><li><p>完全不在窗口内，丢弃该线段；<code>code1 &amp; code2 != 0</code></p></li><li><p>线段与窗口有交，求出该交点，把线段一分为二，丢弃在窗口外的一段，对另一端重复上述处理</p></li></ol><h3 id="中点分割法"><a href="#中点分割法" class="headerlink" title="中点分割法"></a>中点分割法</h3><p>首先对线段端点进行编码，并把线段与窗口的关系分为三种情况：</p><ol><li>全在窗口内，显示该线段</li><li>完全不在窗口内，丢弃该线段</li><li>线段与窗口有交，用<strong>中点分割</strong>的方法求出线段与窗口的交点</li></ol><p>改进之处：不用解方程组求交，而是采用二分法求交</p><p>改进理由：主要计算过程只用到加法和除2运算，适合硬件实现和并行计算</p><h3 id="梁友栋-Barskey裁剪算法"><a href="#梁友栋-Barskey裁剪算法" class="headerlink" title="梁友栋-Barskey裁剪算法"></a>梁友栋-Barskey裁剪算法</h3><p>参数化裁剪条件：</p><script type="math/tex; mode=display">\begin{cases}XL \le x_1+u\Delta x\le XR\\YB \le y_1+u\Delta y\le YT\end{cases}</script><p>可以表示为统一形式：$up_k\le q_k$</p><ul><li><p>$p_k=0$，直线段平行于裁剪边界之一</p><ul><li>$q_k&lt;0$，则线段完全在边界外，舍弃该线段</li><li>$q_k\ge0$，则该线段平行于裁剪边界并且在窗口内</li></ul></li><li><p>$p_k&lt;0$，线段从裁剪边界所在直线的外部指向内部</p><p>计算线段与边界k的延长线的交点u值$r_k=q_k/p_k$，$u_1=max\{0,r_k\}$</p></li><li><p>$p_k&gt;0$，线段从裁剪边界所在直线的内部指向外部</p><p>计算线段与边界k的延长线的交点u值$r_k=q_k/p_k$，$u_2=min\{1,r_k\}$</p></li></ul><p>如果$u_1&gt;u_2$则线段完全落在裁剪窗口之外被舍弃；否则裁剪线段由参数$u_1,u_2$计算出来，它们定义了在裁剪矩形内的线段部分</p><p>它比前两种方法快，因为线段与窗口边界的交点仅需计算一次，且更新参数$u1,u2$仅需要一次除法</p><h2 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h2><h3 id="Sutherland-Hodgman算法"><a href="#Sutherland-Hodgman算法" class="headerlink" title="Sutherland-Hodgman算法"></a>Sutherland-Hodgman算法</h3><p>一次用窗口的一条边裁剪多边形，得到一个顶点序列，作为下一条裁剪边处理过程的输入</p><p>每条线段端点S,P与裁剪线的位置关系有如下4种，红色标注点为输出的点：</p><p><img src="https://img-blog.csdnimg.cn/20201226192313592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDkwMjI4,size_16,color_FFFFFF,t_70" alt></p><p>算法优点：裁剪窗口可以是任意凸多边形</p><p>算法不足：只能裁剪凸多边形；裁剪窗口不能是凹多边形</p><p>算法改进：可以将凹多边形分割成多个凸多边形再去运行该算法</p><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><h3 id="字库的分类"><a href="#字库的分类" class="headerlink" title="字库的分类"></a>字库的分类</h3><p>点阵型：存储空间大、易于显示</p><p>矢量型：存储空间小、美观、变换方便</p><h3 id="字符裁剪"><a href="#字符裁剪" class="headerlink" title="字符裁剪"></a>字符裁剪</h3><p>串精度</p><p>字符精度</p><p>笔画或像素精度</p><h2 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h2><p>走样aliasing：用离散量表示连续量引起的失真现象</p><p>反走样antialiasing：用于减少或消除这种效果的技术</p><h3 id="提高分辨率"><a href="#提高分辨率" class="headerlink" title="提高分辨率"></a>提高分辨率</h3><p>把显示器分辨率提高一倍，直线经过两倍像素，锯齿增加一倍，但同时每个阶梯也减少了一倍，显示的直线段看起来平直光滑。方法简单，但不经济，只能减轻而不能消除锯齿问题</p><h3 id="非加权区域采样"><a href="#非加权区域采样" class="headerlink" title="非加权区域采样"></a>非加权区域采样</h3><p>假定每个像素是具有一定面积的小区域，直线段是具有一定宽度的狭长矩形，当直线段与像素有交时，求出两者相交区域的面积，然后根据相交区域面积的大小确定该像素的亮度值</p><p>两个缺点：</p><ul><li>像素的亮度与相交区域的面积成正比，而与相交区域落在像素内的位置无关，这仍然会导致锯齿效应</li><li>直线条上沿理想直线方向的相邻两个像素有时会有较大的灰度差</li></ul><h3 id="加权区域采样"><a href="#加权区域采样" class="headerlink" title="加权区域采样"></a>加权区域采样</h3><p>使相交区域对像素亮度的贡献依赖于该区域与像素中心的距离</p><h2 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h2><h3 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h3><p>先把屏幕置成背景色，再把物体各个面按离视点的远近进行排序，结果存放在深度优先级表中，按照由远到近的顺序绘制各个面</p><p>优点：原理简单</p><p>缺点：只能处理互不相交的面，而且深度优先级表中面的顺序可能出错，深度排序计算量大</p><h3 id="Z-Buffer算法"><a href="#Z-Buffer算法" class="headerlink" title="Z-Buffer算法"></a>Z-Buffer算法</h3><p>设置帧缓存存放每个像素的颜色值，深度缓存来存放每个像素的深度值。把显示对象的每个面上每一点的属性值填入帧缓冲区相应单元前，要把这点的z坐标值与Z缓冲器中相应单元的值进行比较，只有前者大于后者时才改变帧缓冲区该单元的值，同时Z缓冲器相应单元的值更新</p><p>优点：比总体排序灵活简单，有利于硬件实现</p><p>缺点：占用空间大，没有利用图形的相关性与连续性</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>帧缓存全置为背景色;<br>    深度缓存全置为最小Z值;<br>    <span class="hljs-keyword">for</span>(每一个多边形)&#123;<br>        扫描转换该多边形;<br>        <span class="hljs-keyword">for</span>(该多边形覆盖的每个像素(x,y))&#123;<br>            计算该多边形在该像素的深度值Z(x,y);<br>            <span class="hljs-keyword">if</span>(Z(x,y)大于Z缓存在(x,y)的值)&#123;<br>            把Z(x,y)存入Z缓存中(x,y)处;<br>                把多边形在(x,y)处的颜色值存入帧缓存的(x,y)处;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="改进的Z-Buffer算法"><a href="#改进的Z-Buffer算法" class="headerlink" title="改进的Z-Buffer算法"></a>改进的Z-Buffer算法</h3><p>用一个深度缓存变量zb代替缓存数组。对屏幕上的每个像素，对于每个多边形，若该像素在该多边形内，则计算该多边形在该像素的深度值，找出对应最大深度值的多边形，更新像素属性值</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>帧缓存全置为背景色;<br>    <span class="hljs-keyword">for</span>(屏幕上的每一个像素(x,y))&#123;<br>        深度缓存变量zb置最小值MinValue;<br>        <span class="hljs-keyword">for</span>(每个多边形P)&#123;<br>            <span class="hljs-keyword">if</span>(像素(x,y)在该多边形P_k内)&#123;<br>                计算该多边形在该像素的深度值depth;<br>                <span class="hljs-keyword">if</span>(depth&gt;zb)&#123;<br>            zb=depth;<br>                    index=k;<br>            &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(zb!=MinValue)<br>            计算多边形P_index在像素(x,y)的光照颜色并显示;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第6行的包含性检测可采用射线法或弧长法</p><h3 id="扫描线Z-Buffer算法"><a href="#扫描线Z-Buffer算法" class="headerlink" title="扫描线Z-Buffer算法"></a>扫描线Z-Buffer算法</h3><p>在处理当前扫描线时，开一个一维数组作为当前扫描线的Z-Buffer。首先找出与当前扫描线相关的多边形，以及每个多边形中相关的边对；然后计算边对之间区间上各像素的深度，与Z-Buffer中的值相比较，找出各像素处对应的可见平面，计算颜色，写帧缓存。对深度计算采用增量算法。</p><p>优点：将整个绘图窗口内的消隐问题分解到扫描线上解决，使所需的Z缓冲器大大减小；计算深度时利用了面的连贯性，只用了一个加法</p><p>缺点：被多个多边形覆盖的像素还要进行多次计算，计算量仍然很大</p><p>数据结构：</p><ul><li>多边形Y表：保存所有多边形的序号和其顶点最大y坐标，根据多边形顶点最小y坐标插入到Y表相应位置</li><li>活化多边形表APT：保存与当前扫描线相交的多边形</li><li>边表ET：每个APT中的多边形都有一个边表，存放每条边端点中较大的y值，增量$\Delta x$，y值较小一端的x坐标和z坐标</li><li>活化边对表AET：存放当前多边形中与当前扫描线相交的各边对的信息</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">Z-Buffer()&#123;<br>    建立多边形Y表;<br>    初始化活化多边形表APT，活化边对表AET为空;<br>    <span class="hljs-keyword">for</span>(每条扫描线i)&#123;<br>        帧缓存CB置为背景色;<br>        深度缓存ZB置为负无穷;<br>        将对应扫描线i的Y表中的多边形加入APT中;<br>        生成新加入多边形的边表ET;<br>        对APT中每一个多边形，若其边表ET中对应扫描线i增加了新边，则将新边配对，加入AET中;<br>        对AET中每一个边对:<br>            对xl&lt;j&lt;xr的每一个像素，按增量公式z=z+dz_a计算各点深度depth;<br>        若depth&gt;ZB(j)则令ZB(j)=depth，并计算颜色值写帧缓存;<br>        删除APT中多边形顶点最大y坐标为i的多边形，并删除相应的边;<br>        对AET中每一个边对:<br>        删除y_lmax或y_rmax等于i的边，若一边对中只删除了一边则对该多边形的边重新配对;<br>        用增量公式计算新的x_l,x_r,z_l=z_l+dx_l*dz_a+dz_b;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h3><p>把当前扫描线各多边形在投影平面的投影的交点进行排序后，使扫描线分为若干子区间，只要在区间任一点处找出在该处z值最大的一个面，这个区间上的每一个像素就用这个面的颜色来表示</p><p>优点：在一条扫描线上每个区间只计算一次深度值，并且不需要Z缓冲器</p><h3 id="区域子分割算法（Warnack算法）"><a href="#区域子分割算法（Warnack算法）" class="headerlink" title="区域子分割算法（Warnack算法）"></a>区域子分割算法（Warnack算法）</h3><p>把物体投影到全屏幕窗口上，然后递归分割窗口，直到窗口内目标足够简单，可以显示为止</p><p>如果窗口内没有物体，则按背景色显示；如果窗口内只有一个面，则把该面显示出来；如果窗口内含有两个以上的面，则把窗口等分成4个子窗口，对每个小窗口作上述同样的处理</p><p>窗口与多边形的覆盖关系有4种：内含，相交，包围，分离</p><h3 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h3><p>考查由视点出发穿过观察屏幕的一个像素而射入场景的一条射线，则可确定出场景中与该射线相交的物体。在计算出光线与物体表面的交点后，离像素最近的交点所在面片的颜色为该像素的颜色；如果没有交点，说明没有多边形的投影覆盖此像素，用背景色显示。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">for</span>(屏幕上的每一像素)&#123;<br>    形成通过该屏幕像素的射线;<br>    <span class="hljs-keyword">for</span>(场景中的每一物体)<br>        将该射线于物体求交;<br>    <span class="hljs-keyword">if</span>(存在交点)<br>        以最近的交点所属的颜色显示像素;<br>    <span class="hljs-keyword">else</span><br>        以背景色显示像素;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第三章-几何造型技术"><a href="#第三章-几何造型技术" class="headerlink" title="第三章 几何造型技术"></a>第三章 几何造型技术</h1><h2 id="曲线的基本概念"><a href="#曲线的基本概念" class="headerlink" title="曲线的基本概念"></a>曲线的基本概念</h2><p>位置矢量</p><p>切矢量</p><p>法矢量</p><p>曲率：弯曲程度，曲线的单位切矢对弧长的转动率</p><p>挠率：扭曲程度，副法线方向对于弧长的转动率</p><h2 id="三次Hermite曲线"><a href="#三次Hermite曲线" class="headerlink" title="三次Hermite曲线"></a>三次Hermite曲线</h2><p>三次曲线的代数形式：$P(t)=a_3t^3+a_2t^2+a_1t+a_0, t\in[0,1]$</p><p>三次曲线的几何形式：用端点位矢$P_0,P_1$，切矢$P’_0,P’_1$表示</p><p>代入<strong>推导(……)</strong>，几何系数是$P_0,P_1,P’_0,P’_1$，调和函数是$F_0, F_1, G_0, G_1$</p><script type="math/tex; mode=display">P(t)=F_0P_0+F_1P_1+G_0P'_0+G_1P'_1, t\in[0,1]</script><p>矩阵化表达</p><script type="math/tex; mode=display">P(t)=\left( \begin{matrix}P_0 & P_1 & P'_0 & P'_1\end{matrix}\right)\left( \begin{matrix}F_0 \\ F_1 \\ G_0 \\ G_1\end{matrix}\right)=\left( \begin{matrix}P_0 & P_1 & P'_0 & P'_1\end{matrix}\right)\left( \begin{matrix}2 & -3 & 0 & 1\\-2 & 3 & 0 & 0\\1 & -2 & 1 & 0\\1 & -1 & 0 & 0\\\end{matrix}\right)\left( \begin{matrix}t^3 \\ t^2 \\ t \\ 1\end{matrix}\right)\\</script><h2 id="Bezier曲线"><a href="#Bezier曲线" class="headerlink" title="Bezier曲线"></a>Bezier曲线</h2><script type="math/tex; mode=display">P(t)=\sum_{i=0}^nP_iC_n^it^i(1-t)^{n-i},t\in[0,1]</script><p>性质：</p><ul><li><p>端点性质</p><ul><li><p>起点终点与对应的特征多边形的起点终点重合</p></li><li><p>端点切向量$P’(t)=n\sum_{i=1}^{n-1}P_i[B_{i-1,n-1}(t)-B_{i,n-1}(t)]$</p><p>起点终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致</p></li></ul></li><li><p>对称性：曲线的起点终点处几何性质一样</p></li><li><p>凸包性：曲线落在$P_i$构成的凸包之中</p></li><li><p>几何不变性：曲线的位置和形状不依赖坐标系的选择</p></li><li><p>变差缩减性：平面内任意直线与$P(t)$的交点个数不多于该直线与其特征多边形的交点个数，反映了bezier曲线比特征多边形的折线更光顺</p></li><li><p>仿射不变性：在仿射变换下，$P(t)$的形式不变</p></li></ul><p>de Casteljau算法：</p><script type="math/tex; mode=display">P_i^k=\begin{cases}P_i,&k=0\\(1-t)P_i^{k-1}+tP_{i+1}^{k-1},&k=1,2,...,n,i=0,1,...,n-k\end{cases}</script><p>升阶：保持Bezier曲线的形状与定向不变，增加定义它的控制顶点数</p><script type="math/tex; mode=display">P_i^*=\frac{i}{n+1}P_{i-1}+(1-\frac{i}{n+1})P_i\\i=0,1,...,n+1</script><p>不足：</p><ul><li>Bezier曲线不能做局部修改</li><li>Bezier曲线的拼接比较复杂</li></ul><h2 id="B样条"><a href="#B样条" class="headerlink" title="B样条"></a>B样条</h2><p>k阶（k-1次）B样条曲线的定义为：</p><script type="math/tex; mode=display">P(t)=\sum_{i=0}^n P_iN_{i,k}(t) \\t\in[t_{k-1},t_{n+1}]</script><p>de Boor算法：</p><p>给定控制顶点$P_i(i=0,1,…,n)$和节点矢量$T=[t_0,t_1,…,t_{n+k}]$，定义k阶（k-1次）B样条曲线</p><script type="math/tex; mode=display">t\in[t_j,t_{j+1}](k-1\le j\le n)\\P_i^r(t)=\begin{cases}P_i,&r=0;\\&i=j-k+1,j-k+2,...,j\\\frac{t-t_i}{t_{i+k-r}-t_i}P_i^{r-1}(t)+\frac{t_{i+k-r}-t}{t_{i+k-r}-t_i}P_{i-1}^{r-1}(t),&r=1,2,..,k-1;\\&i=j-k+r+1,j-k+r+2,...,j\end{cases}\\P(t)=P_j^{k-1}(t)</script><p>三次B样条的Bezier表示：</p><p>在区间$[t_j,t_{j+1}]$上的B样条曲线，如表示成三次Bezier曲线，则控制顶点为：</p><script type="math/tex; mode=display">P_{j-1}^{[2]}(t_j),P_{j-1}^{[1]}(t_j),P_{j-1}^{[1]}(t_{j+1}),P_{j}^{[2]}(t_{j+1})</script><script type="math/tex; mode=display">P(t)=\sum_{i=j-3}^j P_iN_{i,4}(t)\\=P_{j-1}^{[2]}(t_j)B_{0,3}(\frac{t-t_j}{\Delta t_j})+P_{j-1}^{[1]}(t_j)B_{1,3}(\frac{t-t_j}{\Delta t_j})+P_{j-1}^{[1]}(t_{j+1})B_{2,3}(\frac{t-t_j}{\Delta t_j})+P_{j}^{[2]}(t_{j+1})B_{3,3}(\frac{t-t_j}{\Delta t_j})</script><h2 id="三角网格"><a href="#三角网格" class="headerlink" title="三角网格"></a>三角网格</h2><h3 id="半边表示"><a href="#半边表示" class="headerlink" title="半边表示"></a>半边表示</h3><p>把一条无向的边拆分成两条有向的半边，半边的方向在模型中总是沿着逆时针方向</p><p>每条半边需要存储的信息：</p><ul><li>该半边的源顶点<code>origin(e)</code></li><li>该半边在同一三角形中的下一半边<code>next(e)</code></li><li>与该半边同属一条边的对边<code>opposite(e)</code></li><li>该半边所属的面<code>IncFace(e)</code></li></ul><h3 id="网格简化"><a href="#网格简化" class="headerlink" title="网格简化"></a>网格简化</h3><p>三种基本化简操作：顶点删除、边压缩、面片收缩</p><h3 id="网格细分"><a href="#网格细分" class="headerlink" title="网格细分"></a>网格细分</h3><p>Loop细分方法：第一步增加顶点，第二步调整顶点位置使网格更加平滑</p><h1 id="第四章-真实感图形学"><a href="#第四章-真实感图形学" class="headerlink" title="第四章 真实感图形学"></a>第四章 真实感图形学</h1><h2 id="颜色的特性"><a href="#颜色的特性" class="headerlink" title="颜色的特性"></a>颜色的特性</h2><p>心理学和视觉的角度：色调(hue)、饱和度(saturation)、亮度(lightness)</p><p>光学物理学的角度：主波长、纯度、明度</p><h2 id="三色学说"><a href="#三色学说" class="headerlink" title="三色学说"></a>三色学说</h2><p>是真实感图形学的生理视觉基础，是颜色视觉中最基础、最根本的理论</p><h2 id="CIE色度图"><a href="#CIE色度图" class="headerlink" title="CIE色度图"></a>CIE色度图</h2><p>马蹄形区域</p><h2 id="常见的颜色模型"><a href="#常见的颜色模型" class="headerlink" title="常见的颜色模型"></a>常见的颜色模型</h2><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>用于彩色光栅图形显示设备，采用红、绿、蓝为原色，面向硬件</p><p>三维直角坐标系，单位立方体来表示，原点为黑色，从黑色中加入某种颜色</p><h3 id="CMY"><a href="#CMY" class="headerlink" title="CMY"></a>CMY</h3><p>用于印刷行业，采用青(Cyan)、品红(Magenta)、黄(Yellow)为原色，面向硬件</p><p>减性原色系统，单位立方体，原点为白色，在白色中减去某种颜色</p><h3 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h3><p>面向用户，对应于画家的配色方法，圆锥形</p><h2 id="写出Phong模型公式，并指出其中各个参数的含义"><a href="#写出Phong模型公式，并指出其中各个参数的含义" class="headerlink" title="写出Phong模型公式，并指出其中各个参数的含义"></a>写出Phong模型公式，并指出其中各个参数的含义</h2><p>环境光ambient + 漫反射光diffuse + 镜面反射光specular</p><p><img src="https://img-blog.csdnimg.cn/20190502153628116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FqaDU2MDY=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;"></p><script type="math/tex; mode=display">I=I_aK_a+I_pK_d(L\cdot N)+I_pK_s(R\cdot V)^n\\R=2N(L\cdot N)-L</script><p>$I_a$——环境光强度</p><p>$K_a$——物体对环境光的反射系数</p><p>$I_p$——入射光强度</p><p>$K_d$——物体的漫反射系数</p><p>$L$——光源方向单位向量</p><p>$N$——物体法向量</p><p>$K_s$——物体的镜面反射系数</p><p>$R$——反射方向单位向量</p><p>$V$——视线方向单位向量</p><p>$n$——镜面反射指数</p><h2 id="Gouraud明暗处理"><a href="#Gouraud明暗处理" class="headerlink" title="Gouraud明暗处理"></a>Gouraud明暗处理</h2><ol><li>计算多边形顶点的平均法向 相邻多边形的平均法向</li><li>用Phong光照明模型计算顶点的平均光强</li><li>插值计算离散边上的各点光强</li><li>插值计算多边形内域中各点的光强</li></ol><p>优点：能有效地显示漫反射效果，计算量小</p><p>缺点：镜面发射效果不理想，相邻多边形边界处的马赫带效应不能完全消除</p><h2 id="Phong明暗处理"><a href="#Phong明暗处理" class="headerlink" title="Phong明暗处理"></a>Phong明暗处理</h2><ol><li>计算多边形顶点的平均法向</li><li>插值计算离散边上的各点法向</li><li>插值计算多边形内域中各点的法向</li><li>用Phong光照明模型计算各点的光强</li></ol><p>优点：可以产生正确的高光区域</p><p>缺点：计算量大</p><h2 id="针对多面体模型，直接用Phong模型绘制会有什么问题？"><a href="#针对多面体模型，直接用Phong模型绘制会有什么问题？" class="headerlink" title="针对多面体模型，直接用Phong模型绘制会有什么问题？"></a>针对多面体模型，直接用Phong模型绘制会有什么问题？</h2><p>由于光源和视点都被假定为无穷远，且每一个多边形由于法向一致，所以多边形内部像素的颜色都是相同的，因此在不同法向的多边形邻接处不仅有光强突变还会产生马赫带效应</p><h2 id="两种增量式光照明模型的基本思想及算法区别"><a href="#两种增量式光照明模型的基本思想及算法区别" class="headerlink" title="两种增量式光照明模型的基本思想及算法区别"></a>两种增量式光照明模型的基本思想及算法区别</h2><p>在每一个多边形的顶点处计算合适的光照明强度或其他参数，然后在各个多边形内部进行均匀插值，最后得到多边形的光滑颜色分布</p><p>Gouraud明暗处理采用光强插值，Phong明暗处理采用法向插值</p><h2 id="局部光照明模型"><a href="#局部光照明模型" class="headerlink" title="局部光照明模型"></a>局部光照明模型</h2><script type="math/tex; mode=display">I_r=I_aK_a+I_i(N\cdot L)d\omega (K_dR_d+K_sR_s)</script><p>与简单光照模型比较的优点：</p><ol><li>是基于入射光能量导出的光辐射模型，更具有理论基础</li><li>可以反映表面的粗糙度对反射光强的影响</li><li>可以根据材料的物理性质决定颜色</li><li>可以改进简单光照模型的失真现象</li><li>可以模拟金属的光泽</li></ol><h2 id="整体光照明模型—光线跟踪算法"><a href="#整体光照明模型—光线跟踪算法" class="headerlink" title="整体光照明模型—光线跟踪算法"></a>整体光照明模型—光线跟踪算法</h2><p>终止条件：</p><ul><li>该光线未碰到任何物体</li><li>该光线碰到了背景</li><li>光线在经过多次反射和折射后衰减，光线对于视点的光强贡献很小</li><li>光线反射或折射次数大于给定值</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">RayTracing(start, direction, weight, color)&#123;<br><span class="hljs-comment">//光线起点start 光线方向direction 光线衰减权值weight 返回光线方向上的颜色值color</span><br>    <span class="hljs-keyword">if</span>(weight &lt; MinWeight)<br>        color = black;<br>    <span class="hljs-keyword">else</span>&#123;<br>    计算光线与所有物体的交点中离start最近的点;<br>        <span class="hljs-keyword">if</span>(没有交点)<br>            color = black;<br>        <span class="hljs-keyword">else</span>&#123;<br>            I_local = 在交点处用局部光照模型计算出的光强;<br>            计算反射方向R = <span class="hljs-number">2</span>N(L*N)-L;<br>            RayTracing(最近的交点, R, weight*w_r, I_r);<br>            计算折射方向T;<br>            RayTracing(最近的交点, T, weight*<span class="hljs-keyword">w_t</span>, I_t);<br>            color = I_local + K_sI_r + K_tI_t;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>加速方法：自适应深度控制；包围盒及层次结构；三维DDA算法；空间八叉树剖分技术</p><h2 id="包围盒"><a href="#包围盒" class="headerlink" title="包围盒"></a>包围盒</h2><p>基本思想：用体积稍大且特性简单的集合体来近似代替复杂的几何对象</p><h3 id="AABB"><a href="#AABB" class="headerlink" title="AABB"></a>AABB</h3><p>包含该对象，且边平行于坐标轴的最小六面体。六个标量即可表示$(x_{min},y_{min},z_{min})(x_{max},y_{max},z_{max})$。</p><p>不随物体旋转，紧密性差。</p><h3 id="OBB"><a href="#OBB" class="headerlink" title="OBB"></a>OBB</h3><p>包围盒无需和坐标轴垂直，根据物体表面的顶点，通过PCA获得特征向量，即OBB的主轴。具有方向性，可以旋转。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="二维图形的几何变换"><a href="#二维图形的几何变换" class="headerlink" title="二维图形的几何变换"></a>二维图形的几何变换</h2><p>平移变换</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & t_x\\0 & 1 & t_y\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\1\end{matrix}\right]</script><p>旋转变换（逆时针）</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & -\sin\theta & 0\\\sin\theta & \cos\theta & 0\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\1\end{matrix}\right]</script><p>关于$(x_f,y_f)$点的旋转变换：需要先将该点移到坐标原点处，然后再进行旋转变换，最后将该点移回原来的位置</p><script type="math/tex; mode=display">T(x_f,y_f)\cdot R(\theta)\cdot T(-x_f,-y_f)=\left[ \begin{matrix}1 & 0 & x_f\\0 & 1 & y_f\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}\cos\theta & -\sin\theta & 0\\\sin\theta & \cos\theta & 0\\0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}1 & 0 & -x_f\\0 & 1 & -y_f\\0 & 0 & 1\\\end{matrix}\right]</script><h2 id="三维图形的几何变换"><a href="#三维图形的几何变换" class="headerlink" title="三维图形的几何变换"></a>三维图形的几何变换</h2><p>绕x轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & 0 & 0\\0 & \cos\theta & -\sin\theta & 0\\0 & \sin\theta & \cos\theta & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕y轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & 0 & \sin\theta & 0\\0 & 1 & 0 & 0\\-\sin\theta & 0 & \cos\theta & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕z轴旋转</p><script type="math/tex; mode=display">\left[ \begin{matrix}\cos\theta & -\sin\theta & 0 & 0\\\sin\theta & \cos\theta & 0 & 0\\0 & 0 & 1 & 0\\0 & 0 & 0 & 1\\\end{matrix}\right]\left[ \begin{matrix}x\\y\\z\\1\end{matrix}\right]</script><p>绕任意轴AB旋转</p><ul><li>将A点移到坐标原点</li><li>使AB分别绕x轴、y轴旋转与z轴重合</li><li>将AB绕z轴旋转$\theta$角</li><li>作上述变换的逆操作，使AB回到原来位置</li></ul><h2 id="矩形求交"><a href="#矩形求交" class="headerlink" title="矩形求交"></a>矩形求交</h2><p>给定两个矩形A和B，矩形A的左上角坐标为$(x_{a1},y_{a1})$，右下角坐标为$(x_{a2},y_{b2})$；矩形B的左上角坐标为$(x_{b1},y_{b1})$，右下角坐标为$(x_{b2},y_{b2})$。</p><p>假设两矩形相交区域为矩形C，左上角坐标为$(x_{c1},y_{c1})$，右下角坐标为$(x_{c2},y_{c2})$</p><p>分析相交情况可知</p><script type="math/tex; mode=display">x_{c1}=max(x_{a1},x_{b1})\\y_{c1}=min(y_{a1},y_{b1})\\x_{c2}=min(x_{a2},y_{b2})\\y_{c2}=max(y_{a2},y_{b2})</script><p>若要相交则$\begin{cases}x_{c1}<x_{c2}\\y_{c1}>y_{c2}\end{cases}$，即</x_{c2}\\y_{c1}></p><script type="math/tex; mode=display">\begin{cases}max(x_{a1},x_{b1})<min(x_{a2},x_{b2})\\min(y_{a1},y_{b1})>max(y_{a2},y_{b2})\\\end{cases}</script><h2 id="线面求交"><a href="#线面求交" class="headerlink" title="线面求交"></a>线面求交</h2><p>圆柱面</p><script type="math/tex; mode=display">x^2+y^2=r^2</script><p>线的参数方程$x=x(t),y=y(t),z=z(t)$</p><p>代入解方程t</p><h2 id="判断点在多边形内部"><a href="#判断点在多边形内部" class="headerlink" title="判断点在多边形内部"></a>判断点在多边形内部</h2><p>根据向量叉乘，按照逆时针（顺时针）取向量进行叉乘，所得值同号，则说明点在多边形内部。</p><p>即判断方式为：取向量AB和AP、BC和BP、CD和CP、DE和DP、EA和EP进行叉乘，判断所得值是否同号。</p><p><img src="https://img-blog.csdnimg.cn/20200113093410275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdV9mZW5nX3ppXw==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;"></p><h2 id="三角形相关"><a href="#三角形相关" class="headerlink" title="三角形相关"></a>三角形相关</h2><p>已知三角形三顶点A$(x_1,y_1)$，B$(x_2,y_2)$，C$(x_3,y_3)$</p><p>$\vec{AB}=(x_2-x_1,y_2-y_1,z_2-z_1)$，$\vec{AC}=(x_3-x_1,y_3-y_1,z_3-z_1)$</p><h3 id="单位法向量"><a href="#单位法向量" class="headerlink" title="单位法向量"></a>单位法向量</h3><p>$\frac{\vec{AB}\times\vec{AC}}{|{\vec{AB}\times\vec{AC}}|}$</p><h3 id="面积"><a href="#面积" class="headerlink" title="面积"></a>面积</h3><p>$\frac{1}{2}|\vec{AB}||\vec{AC}|\sin\theta=\frac{1}{2}|\vec{AB}\times\vec{AC}|$</p><h3 id="两个三角形是否相交"><a href="#两个三角形是否相交" class="headerlink" title="两个三角形是否相交"></a>两个三角形是否相交</h3><p>设两个三角形$T_1,T_2$，所在平面分别为$\pi_1,\pi_2$</p><ul><li><p>计算$T_1$每个顶点到$\pi_2$的距离，若同号则$T_1$在$\pi_2$一边，两三角形不相交</p></li><li><p>计算$T_2$每个顶点到$\pi_1$的距离，若同号则$T_2$在$\pi_1$一边，两三角形不相交</p></li><li><p>否则可能相交，计算$T_1$和$\pi_2$的交线$l_1$，$T_2$和$\pi_1$的交线$l_2$</p><p>若$l_1$和$l_2$有重叠，则两三角形相交；否则不相交</p></li></ul><h2 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h2><h3 id="世界坐标到观察坐标"><a href="#世界坐标到观察坐标" class="headerlink" title="世界坐标到观察坐标"></a>世界坐标到观察坐标</h3><ul><li><p>原点平移矩阵</p><script type="math/tex; mode=display">\left[ \begin{matrix}1 & 0 & 0 & -x_0\\0 & 1 & 0 & -y_0\\0 & 0 & 1 & -z_0\\0 & 0 & 0 & 1\\\end{matrix} \right]</script></li><li><p>旋转矩阵（单位矢量法）</p><ul><li>取观察坐标系的z轴方向为观察平面的法向，单位化得$n=(n_x,n_y,n_z)$</li><li>取观察坐标系的x轴方向为观察方向，单位化得$u=(u_x,u_y,u_z)$</li><li>取观察坐标系的y轴方向的单位矢量，或直接计算得$v=n\times u=(v_x,v_y,v_z)$</li></ul><script type="math/tex; mode=display">\left[ \begin{matrix}u_x & v_x & n_x & 0\\u_y & v_y & n_y & 0\\u_z & v_z & n_z & 0\\0 & 0 & 0 & 1\\\end{matrix} \right]</script></li></ul><h3 id="一点透视"><a href="#一点透视" class="headerlink" title="一点透视"></a>一点透视</h3><p>假定视点位置为 (0,-2,0)，沿y轴正方向投影，投影面与y轴垂直并经过点 (0,1,0)</p><p>  (a) 请写出点 (2, 2, 2) 经过透视投影后的坐标。</p><p>  (b) 请写出投影矩阵。</p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p>Bresenham与中点画线法相比的改进</p><p>灭点个数</p><p>曲线参数方程</p><p>Phong明暗处理中代价最高的步骤</p><p>颜色代码000000为什么颜色</p><h2 id="简答计算题"><a href="#简答计算题" class="headerlink" title="简答计算题"></a>简答计算题</h2><p>多边形的扫描填充伪代码</p><p>简述面消隐的各种算法</p><p>Phong光照模型公式及示意图，反射方向R的推导</p><p>对称变换矩阵</p><p>空间中一正方形和一多边形求交</p><p>给定控制点求Bezier曲线方程，转换为B-Spline的新控制点，转换为Hermite曲线的端点和切矢</p><p>给定视点、投影面，在世界坐标与观察坐标下的投影矩阵</p>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CG</tag>
      
      <tag>review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDU操作系统复习笔记</title>
    <link href="/2022/01/15/OSreview/"/>
    <url>/2022/01/15/OSreview/</url>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="操作系统-operating-system"><a href="#操作系统-operating-system" class="headerlink" title="操作系统 operating system"></a>操作系统 operating system</h3><p>操作系统是为应用程序提供运行环境的资源管理软件</p><h3 id="虚拟机-virtual-machine"><a href="#虚拟机-virtual-machine" class="headerlink" title="虚拟机 virtual machine"></a>虚拟机 virtual machine</h3><p>通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p><h3 id="运行时系统-runtime-system"><a href="#运行时系统-runtime-system" class="headerlink" title="运行时系统 runtime system"></a>运行时系统 runtime system</h3><p>编译程序除了把用户程序中的语句翻译成机器代码外，还要为用户程序的运行提供管理工作，这部分代码就是运行时系统</p><h3 id="装入程序-loader"><a href="#装入程序-loader" class="headerlink" title="装入程序 loader"></a>装入程序 loader</h3><p>将装入模块装入内存的程序，实现虚拟地址到内存地址的映射，分为绝对装入、静态重定位、动态重定位</p><h3 id="运行栈-execution-stack"><a href="#运行栈-execution-stack" class="headerlink" title="运行栈 execution stack"></a>运行栈 execution stack</h3><p>存放有关正在运行的子程序消息的栈，存放子程序的返回地址、传递给子程序的参数、局部运行环境</p><h3 id="系统调用-system-call"><a href="#系统调用-system-call" class="headerlink" title="系统调用 system call"></a>系统调用 system call</h3><p>操作系统提供给用户程序的一组接口，用于获取内核提供的服务</p><h3 id="应用程序接口-API"><a href="#应用程序接口-API" class="headerlink" title="应用程序接口 API"></a>应用程序接口 API</h3><p>由操作系统或高级语言提供，为应用程序提供跨平台的I/O服务</p><h3 id="特权指令-privileged-instruction"><a href="#特权指令-privileged-instruction" class="headerlink" title="特权指令 privileged instruction"></a>特权指令 privileged instruction</h3><p>能对系统中关键资源进行操作的指令，为保证计算机系统的安全可靠特权指令只能在核心态下使用</p><h3 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程 thread"></a>线程 thread</h3><p>程序在虚拟CPU上的执行过程，是操作系统能够进行调度的最小单位。</p><h3 id="线程控制块-TCB"><a href="#线程控制块-TCB" class="headerlink" title="线程控制块 TCB"></a>线程控制块 TCB</h3><p>操作系统描述和管理线程的数据结构</p><h3 id="进程-process"><a href="#进程-process" class="headerlink" title="进程 process"></a>进程 process</h3><p>一组线程及其所依赖的虚拟运行环境，是操作系统进行资源分配的最小单位。</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>操作系统描述和管理进程的数据结构。主要内容有线程TCB、资源描述、虚实资源映射关系、进程的档案</p><h3 id="多线程进程"><a href="#多线程进程" class="headerlink" title="多线程进程"></a>多线程进程</h3><p>进程中可以包含多个线程，所有线程共享进程的虚拟运行环境，进程内线程之间并发执行，每个线程有自己的线程控制块、运行栈</p><h3 id="僵尸进程-zombie-process"><a href="#僵尸进程-zombie-process" class="headerlink" title="僵尸进程 zombie process"></a>僵尸进程 zombie process</h3><p>子进程已经结束，但父进程并不执行wait()为子进程释放资源</p><h3 id="孤儿进程-orphan-process"><a href="#孤儿进程-orphan-process" class="headerlink" title="孤儿进程 orphan process"></a>孤儿进程 orphan process</h3><p>父进程已经退出，剩下的子进程被init进程收留</p><h3 id="进程上下文-process-context"><a href="#进程上下文-process-context" class="headerlink" title="进程上下文 process context"></a>进程上下文 process context</h3><p>进程执行活动全过程的静态描述，包括用户进程传递给内核的参数、CPU的所有寄存器中的值、进程的状态以及堆栈内容</p><h3 id="CPU调度器-scheduler"><a href="#CPU调度器-scheduler" class="headerlink" title="CPU调度器 scheduler"></a>CPU调度器 scheduler</h3><p>按调度算法选择一个就绪线程并将CPU分配给它运行，是操作系统中关键的程序模块</p><h3 id="抢占式调度-preemptive-scheduling"><a href="#抢占式调度-preemptive-scheduling" class="headerlink" title="抢占式调度 preemptive scheduling"></a>抢占式调度 preemptive scheduling</h3><p>进程还没有执行完成就被剥夺CPU，切换执行其他的进程</p><h3 id="对换技术-swapping"><a href="#对换技术-swapping" class="headerlink" title="对换技术 swapping"></a>对换技术 swapping</h3><p>内存空间紧张时，将内存中某些进程暂时调出到外存，腾出足够的内存空间后把具备运行条件的进程调入内存</p><h3 id="多道程序设计-multiprogramming"><a href="#多道程序设计-multiprogramming" class="headerlink" title="多道程序设计 multiprogramming"></a>多道程序设计 multiprogramming</h3><p>允许多个程序同时装入计算机内存中，在管理程序控制下宏观上并行、微观上串行</p><h3 id="请求调页-demand-paging"><a href="#请求调页-demand-paging" class="headerlink" title="请求调页 demand paging"></a>请求调页 demand paging</h3><p>执行一个进程前仅将PCB装入内存，程序和数据并没有实际装入内存；程序执行过程中，如果访问到的页还没有装入内存就通过缺页异常处理将其装入内存</p><h3 id="局部模式-locality-model"><a href="#局部模式-locality-model" class="headerlink" title="局部模式 locality model"></a>局部模式 locality model</h3><p>进程执行过程中，其访问的内存空间从一个局部迁移到另一个局部，这种运行方式被称为局部模式</p><h3 id="颠簸-thrashing"><a href="#颠簸-thrashing" class="headerlink" title="颠簸 thrashing"></a>颠簸 thrashing</h3><p>在页面置换过程中频繁的页面调度导致CPU利用率极低的现象</p><h3 id="工作集-working-model"><a href="#工作集-working-model" class="headerlink" title="工作集 working model"></a>工作集 working model</h3><p>进程在某个时刻t之前$\Delta$次访问中所访问页的集合</p><h3 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区 critical section"></a>临界区 critical section</h3><p>进程中访问临界资源的代码段，临界区不能并发执行</p><h3 id="字符设备-character-device"><a href="#字符设备-character-device" class="headerlink" title="字符设备 character device"></a>字符设备 character device</h3><p>指在I/O传输过程中以字符为单位进行传输的设备，例如键盘，打印机等，数据没有地址</p><h3 id="块设备-block-device"><a href="#块设备-block-device" class="headerlink" title="块设备 block device"></a>块设备 block device</h3><p>将信息存储在固定大小的块中，每个块都有自己的地址，I/O传输过程中以块为单位</p><h3 id="物理格式化-physical-formatting"><a href="#物理格式化-physical-formatting" class="headerlink" title="物理格式化 physical formatting"></a>物理格式化 physical formatting</h3><p>将磁盘划分出一系列同心圆磁道，各个磁道划分为扇区</p><h3 id="逻辑格式化-logical-formatting"><a href="#逻辑格式化-logical-formatting" class="headerlink" title="逻辑格式化 logical formatting"></a>逻辑格式化 logical formatting</h3><p>在磁盘上建立一个空文件系统，使操作系统对其进行后续文件读写的过程</p><h3 id="磁盘冗余阵列-RAID"><a href="#磁盘冗余阵列-RAID" class="headerlink" title="磁盘冗余阵列 RAID"></a>磁盘冗余阵列 RAID</h3><p>通过在多个磁盘上存储相同的数据改善性能、增加可靠性的技术</p><h3 id="设备驱动程序-device-driver"><a href="#设备驱动程序-device-driver" class="headerlink" title="设备驱动程序 device driver"></a>设备驱动程序 device driver</h3><p>直接控制设备的程序</p><h3 id="设备依赖的-device-dependent"><a href="#设备依赖的-device-dependent" class="headerlink" title="设备依赖的 device-dependent"></a>设备依赖的 device-dependent</h3><p>指程序只能在特定的设备环境下运行，也称设备相关的</p><h3 id="中断服务例程-ISR"><a href="#中断服务例程-ISR" class="headerlink" title="中断服务例程 ISR"></a>中断服务例程 ISR</h3><p>驱动程序的一部分，处理中断信号，检查自己负责的设备是否发出中断以处理中断事件</p><h3 id="假脱机-SPOOLing"><a href="#假脱机-SPOOLing" class="headerlink" title="假脱机 SPOOLing"></a>假脱机 SPOOLing</h3><p>外围设备同时联机操作，是低速I/O设备与主机交换的一种技术。利用程序模拟脱机输入输出技术中外围控制机的功能，提高了输入输出速度、将独占设备改造为共享设备、实现了虚拟设备的功能</p><h3 id="守护进程-daemon"><a href="#守护进程-daemon" class="headerlink" title="守护进程 daemon"></a>守护进程 daemon</h3><p>开机时启动，后台运行，无交互，直至关机</p><h3 id="文件-file"><a href="#文件-file" class="headerlink" title="文件 file"></a>文件 file</h3><p>由操作系统管理的、存储在外存上的、数据的逻辑单元，位程序提供了按名存取的外存使用模式</p><h3 id="索引节点-i-node"><a href="#索引节点-i-node" class="headerlink" title="索引节点 i-node"></a>索引节点 i-node</h3><p>存放文件属性和文件的位置，每个文件有唯一的索引节点号。整个系统有一个索引节点表，存放全部文件属性和位置</p><h3 id="文件分配表-FAT"><a href="#文件分配表-FAT" class="headerlink" title="文件分配表 FAT"></a>文件分配表 FAT</h3><p>用于文件的链接分配，每个磁盘有一张文件分配表FAT，行号对应块号，每个FAT表项中存放对应磁盘块的下一块链接指针</p><h3 id="文件共享-file-sharing"><a href="#文件共享-file-sharing" class="headerlink" title="文件共享 file sharing"></a>文件共享 file sharing</h3><p>在不同的目录下访问同一个文件；不同的进程访问同一个文件</p><h3 id="保护域-protection-domain"><a href="#保护域-protection-domain" class="headerlink" title="保护域 protection domain"></a>保护域 protection domain</h3><p>对一组对象访问权限的集合{(对象，操作), …}，表示一种身份</p><h3 id="访问矩阵-Access-Matrix"><a href="#访问矩阵-Access-Matrix" class="headerlink" title="访问矩阵 Access Matrix"></a>访问矩阵 Access Matrix</h3><p>定义了系统中所有的保护域</p><h3 id="访问控制表-ACL"><a href="#访问控制表-ACL" class="headerlink" title="访问控制表 ACL"></a>访问控制表 ACL</h3><p>从文件的角度描述用户的权限，访问矩阵按列压缩</p><h3 id="用户权限表-Capability-List"><a href="#用户权限表-Capability-List" class="headerlink" title="用户权限表 Capability List"></a>用户权限表 Capability List</h3><p>从用户的角度描述对文件的操作，访问矩阵按行压缩</p><h3 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 VFS"></a>虚拟文件系统 VFS</h3><p>是物理文件系统与服务之间的一个接口层，为各类文件系统提供了一个统一的操作界面和应用编程接口</p><h3 id="同步-synchronization"><a href="#同步-synchronization" class="headerlink" title="同步 synchronization"></a>同步 synchronization</h3><p>并发环境下，保持操作之间偏序关系的行为</p><h3 id="互斥-mutual-exclusion"><a href="#互斥-mutual-exclusion" class="headerlink" title="互斥 mutual exclusion"></a>互斥 mutual exclusion</h3><p>某一资源同时只允许一个访问者对其进行访问</p><h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量 semaphore"></a>信号量 semaphore</h3><p>同步工具，通过PV原子操作控制多线程对共享资源的访问</p><h3 id="管程-monitor"><a href="#管程-monitor" class="headerlink" title="管程 monitor"></a>管程 monitor</h3><p>由高级语言提供的同步方法，将共享变量及对其的所有操作封装在一个对象中，通过每次只允许一个进程在管程内部执行实现进程的互斥，通过设置条件变量及等待、唤醒操作实现进程的同步</p><h3 id="竞争条件-race-condition"><a href="#竞争条件-race-condition" class="headerlink" title="竞争条件 race condition"></a>竞争条件 race condition</h3><p>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题</p><h3 id="安全状态-safe-state"><a href="#安全状态-safe-state" class="headerlink" title="安全状态 safe state"></a>安全状态 safe state</h3><p>系统能按安全序列P1, P2, …, Pn的顺序为每个进程分配其所需的全部资源，使每个进程都能顺利完成，则称系统处于安全状态</p><h2 id="简答论述"><a href="#简答论述" class="headerlink" title="简答论述"></a>简答论述</h2><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><ul><li><p>简单结构</p><ul><li>无核：操作系统内核和应用程序的权限没有区分</li><li>单核：全部内核代码运行在同一个地址空间中，权限相同</li></ul></li><li><p>分层</p><p>系统分成若干层，每层建立在底层基础上，只能高层程序调用低层的程序</p></li><li><p>微内核</p><p>讲内核功能尽量从内核空间移到用户空间，内核尽量小</p><p>更容易扩充、移植，更可靠，更安全；内核与核外程序之间的通信降低性能</p></li><li><p>模块化</p><p>使用面向对象的技术，模块之间通过接口通信</p></li></ul><h3 id="内核、应用程序与用户的关系"><a href="#内核、应用程序与用户的关系" class="headerlink" title="内核、应用程序与用户的关系"></a>内核、应用程序与用户的关系</h3><p>内核为应用程序运行提供管理和服务</p><p>内核和用户无直接关系，用户感觉不到内核的存在</p><p>用户直接/间接执行应用程序</p><h3 id="系统调用的工作机制及其参数传递方法"><a href="#系统调用的工作机制及其参数传递方法" class="headerlink" title="系统调用的工作机制及其参数传递方法"></a>系统调用的工作机制及其参数传递方法</h3><p>工作机制</p><ul><li>正在运行的进程先传递系统调用参数，然后由陷入（trap）指令负责将用户态转化为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核服务程序，最后返回用户态。</li></ul><p>参数传递方法</p><ul><li>通过寄存器传递参数</li><li>若参数数量比寄存器多，参数通常存在内存的块和表中，并将块的地址通过寄存器来传递</li><li>参数通过程序压入堆栈中，通过操作系统弹出</li></ul><h3 id="逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）"><a href="#逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）" class="headerlink" title="逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）"></a>逻辑地址和物理地址绑定的时间有哪几种及优缺点（装入的三种方式）</h3><ul><li><p>编译时（绝对装入）：编译时就知道程序将在内存中的驻留位置，则可以生成绝对代码</p><p>执行速度快</p><p>只适用于单道程序的运行环境</p></li><li><p>加载时（静态重定位）：装入时对地址进行重定位，地址变换在装入时一次性完成</p><p>适用于多道程序的运行环境</p><p>作业装入时需要分配所有要求的内存空间，一旦进入内存不能移动和申请空间</p></li><li><p>执行时（动态重定位）：程序要执行时才进行地址转换</p><p>可以把程序放在不连续的存储区中；程序运行前只装入部分代码即可运行；便于程序段的共享</p><p>需要硬件支持：基地址寄存器、限长寄存器、MMU</p></li></ul><h3 id="进程转换图"><a href="#进程转换图" class="headerlink" title="进程转换图"></a>进程转换图</h3><p><img src="/2022/01/15/OSreview/Users\31\AppData\Roaming\Typora\typora-user-images\image-20211213182347015.png" alt="image-20211213182347015"></p><h3 id="进程与线程的区别和联系"><a href="#进程与线程的区别和联系" class="headerlink" title="进程与线程的区别和联系"></a>进程与线程的区别和联系</h3><p>一个线程只能属于一个进程，而一个线程可以有多个线程且至少有一个线程</p><p>线程是操作系统最小的调度单位，进程是操作系统最小的资源分配单位</p><p>同一进程的所有线程共享该进程的所有资源</p><p>同一进程的多个线程共享代码段、数据段、堆，但每个线程拥有自己的栈段</p><p>同一进程的线程可以并发执行，进一步提高资源利用率和系统吞吐量</p><p>对于系统创建/撤销/切换的开销，进程大于线程</p><h3 id="用户级线程和内核级线程及关系"><a href="#用户级线程和内核级线程及关系" class="headerlink" title="用户级线程和内核级线程及关系"></a>用户级线程和内核级线程及关系</h3><p>用户级线程：线程的管理由用户程序（线程库）控制。非抢占式，线程切换速度快，对于操作系统内核透明，若一个线程阻塞则导致整个进程阻塞 ，不适用于多CPU</p><p>内核级线程：线程的管理（创建、撤销、调度）需要由内核控制。可以抢占，切换代价高，若一个线程阻塞则不会影响进程中其他线程的运行，适用于多CPU</p><p>多对一：程序创建的所有线程为用户级线程</p><p>一对一：程序创建的所有线程为内核级线程</p><p>多对多：多个内核级线程共同分担多个用户级线程的任务</p><h3 id="一个进程中能否既有内核级线程又有用户级线程"><a href="#一个进程中能否既有内核级线程又有用户级线程" class="headerlink" title="一个进程中能否既有内核级线程又有用户级线程"></a>一个进程中能否既有内核级线程又有用户级线程</h3><p>当采用多对多方式时，一个进程中既有内核级线程又有用户级线程。每个进程有自己的内核线程池，运行时库分派并标记可运行的用户级线程为准备好执行的线程，操作系统选择用户线程并将它映射到线程池中的可用内核线程，多个用户级线程可以分配给相同的内核级线程</p><p>Java线程属于内核级线程</p><h3 id="何时执行调度器"><a href="#何时执行调度器" class="headerlink" title="何时执行调度器"></a>何时执行调度器</h3><p>非抢占式调度</p><ul><li><p>当前线程执行结束</p></li><li><p>当前线程主动放弃CPU</p></li><li><p>当前线程阻塞</p></li></ul><p>抢占式调度</p><ul><li><p>就绪队列中出现高优先级的线程</p></li><li><p>时间片结束</p></li></ul><h3 id="操作系统需要考虑的调度及目标、方法"><a href="#操作系统需要考虑的调度及目标、方法" class="headerlink" title="操作系统需要考虑的调度及目标、方法"></a>操作系统需要考虑的调度及目标、方法</h3><ul><li><p>作业调度：将外存中的作业调入内存，为其创建进程、分配资源</p><p>先来先服务FCFS 短作业优先SJF 最高响应比优先HRN 优先级 轮转法 多级反馈队列</p></li><li><p>内存调度：为提高内存利用率和系统吞吐量，将内存中的进程暂时挂起，选择部分程序或数据留在内存，这种技术称为交换</p></li><li><p>进程调度：从就绪队列中选择进程获得CPU</p><p>先进先出FIFO 时间片轮转RR 优先级 多级反馈队列</p></li><li><p>磁盘调度：当多个进程要求访问磁盘时，使平均访问时间最小</p><p>先来先服务FCFS 最短寻道时间优先SSTF 电梯调度SCAN LOOK C-SCAN C-LOOK</p></li></ul><blockquote><p>// ？？？不懂算不算调度</p><ul><li><p>空闲分区的分配：将磁盘中一组连续的块分配给文件存储</p><p>首次适应 最佳适应 最坏适应</p></li><li><p>请求分页存储管理中的页面置换：内存空间不足时，需要从内存中调出一页</p><p>最佳置换OPT 先进先出FIFO 最近最久未使用LRU 时钟置换CLOCK</p></li></ul></blockquote><p>调度算法的目标</p><ul><li>CPU利用率 高</li><li>吞吐量 高：单位时间内完成进程的个数</li><li>等待时间 短：线程在就绪队列中的时间</li><li>响应时间 短：从用户提交请求到系统做出反馈的时间</li><li>周转时间 短：进程等待时间+运行时间</li></ul><h3 id="进程调度中多级反馈队列调度算法的基本思想"><a href="#进程调度中多级反馈队列调度算法的基本思想" class="headerlink" title="进程调度中多级反馈队列调度算法的基本思想"></a>进程调度中多级反馈队列调度算法的基本思想</h3><p>将进程按类型分成不同的队列，每个队列采用适合自身的调度算法，从最高优先级队列开始调度，若该队列中的作业未完成则将其降级到更低优先级队列，若较低优先级队列中作业等待时间过长则将其升级到更高优先级队列，能够较好实现公平性与资源利用率之间的平衡。</p><h3 id="进程通信IPC的两种模式"><a href="#进程通信IPC的两种模式" class="headerlink" title="进程通信IPC的两种模式"></a>进程通信IPC的两种模式</h3><p>共享内存：多个进程都可以访问各自的虚拟内存区域，进程虚拟地址映射到相同的物理地址；共享数据过程的同步由应用程序负责</p><p>消息传输：以Message为单位，通过send()和receive()两个原语操作进行数据交换</p><ul><li>直接通信：要求对方在线，每个进程都有消息队列</li><li>间接通信：对方可以不同时在线，通信前建立邮箱</li></ul><h3 id="图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件"><a href="#图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件" class="headerlink" title="图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件"></a>图示说明页式存储管理系统对页面共享的方法，并说明共享代码和共享数据有何限制条件</h3><p>不同作业指向相同的页框号</p><p><img src="/2022/01/15/OSreview/Users\31\AppData\Roaming\Typora\typora-user-images\image-20211214105624902.png" alt="image-20211214105624902"></p><p>由于页不是代码的逻辑单元，所以需要将逻辑单元对齐页边界</p><h3 id="CPU和操作系统在分页中各自承担了哪些工作"><a href="#CPU和操作系统在分页中各自承担了哪些工作" class="headerlink" title="CPU和操作系统在分页中各自承担了哪些工作"></a>CPU和操作系统在分页中各自承担了哪些工作</h3><p>CPU生成逻辑地址，分为页表和页偏移量两个部分；当一个进程可分配到CPU时，CPU调度程序可以根据页表副本来定义硬件页表</p><p>操作系统为每个进程维护一个页表的副本用于将逻辑地址转变成物理地址；管理物理内存，维护物理内存的分配信息保存在帧表中；</p><h3 id="图文并茂的描述虚拟地址到物理地址的映射过程"><a href="#图文并茂的描述虚拟地址到物理地址的映射过程" class="headerlink" title="图文并茂的描述虚拟地址到物理地址的映射过程"></a>图文并茂的描述虚拟地址到物理地址的映射过程</h3><p><strong>基本分页式</strong></p><p><img src="https://img-blog.csdnimg.cn/d09b292358084ef58e99d51176978e21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAa2Fyc2hleQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p><strong>带快表的分页式</strong></p><p><img src="https://img2020.cnblogs.com/blog/2083141/202008/2083141-20200803171427603-732589443.png" alt="img"></p><p>① 根据逻辑地址计算页号、页内偏移量</p><p>② 比较页号和页表长度，检查页号合法性</p><p>③ 查快表，若命中则获得页面存放的内存块号，转⑤；若未命中，转④</p><p>④ 查页表，根据页表始址找到页号对应页表项，获得页面存放的内存块号，并将该页表项复制到快表中</p><p>⑤ 根据内存块号和页内偏移量得到物理地址</p><p><strong>基本分段式</strong></p><p><img src="https://img-blog.csdnimg.cn/20201008202949487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTg3NzQw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>段页式</strong></p><p><img src="https://img-blog.csdnimg.cn/20201008205928813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTg3NzQw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="请求调页系统中页表项包含的数据项和作用"><a href="#请求调页系统中页表项包含的数据项和作用" class="headerlink" title="请求调页系统中页表项包含的数据项和作用"></a>请求调页系统中页表项包含的数据项和作用</h3><ul><li>页号（隐式）：给页顺序编号</li><li>内存块号：指出该页在内存中的位置</li><li>状态位：该页是否已经调入内存</li><li>访问字段：记录本页在一段时间内的访问次数或最近一次访问时间，用作置换算法的参考项</li><li>修改位：该页在调入内存后是否被修改过</li><li>外存地址：该页在外存中的位置</li></ul><h3 id="请求调页和纯分页的比较"><a href="#请求调页和纯分页的比较" class="headerlink" title="请求调页和纯分页的比较"></a>请求调页和纯分页的比较</h3><ul><li>ISA架构的改变：页故障异常、页表中增加存在位和脏位等设计</li><li>操作系统的改变：页故障异常处理程序（页置换）</li><li>硬盘的改变：对换区</li></ul><h3 id="采用工作集模型预防系统抖动的思想与过程"><a href="#采用工作集模型预防系统抖动的思想与过程" class="headerlink" title="采用工作集模型预防系统抖动的思想与过程"></a>采用工作集模型预防系统抖动的思想与过程</h3><p>根据局部性原理，进程会在某段时间间隔内相对稳定地访问某些页面。所以引入工作集的概念，指在某段时间间隔内进程实际访问的页面的集合</p><p>操作系统跟踪每个进程的工作集，并为进程分配大于其工作集大小的物理块</p><h3 id="颠簸产生的原因及解决方案"><a href="#颠簸产生的原因及解决方案" class="headerlink" title="颠簸产生的原因及解决方案"></a>颠簸产生的原因及解决方案</h3><p>进程频繁访问的页面数多于可用的物理块数</p><p>应用工作集策略为进程分配足够多的物理块；修改页面置换算法；降低多道程序的数量；增加物理内存容量</p><h3 id="I-O控制方式及特点"><a href="#I-O控制方式及特点" class="headerlink" title="I/O控制方式及特点"></a>I/O控制方式及特点</h3><p>程序直接控制：程序直接对设备轮询</p><p>中断驱动：当设备准备完成时发生中断</p><p>DMA：在I/O设备与内存之间开辟直接数据通路</p><p>通道控制：引入专门的I/O处理机进行管理</p><h3 id="输入输出过程举例"><a href="#输入输出过程举例" class="headerlink" title="输入输出过程举例"></a>输入输出过程举例</h3><ul><li><p>线程T调用驱动程序Q的启动部分的代码，启动设备</p></li><li><p>当前线程T等待设备完成操作；设备开始工作，线程T阻塞，CPU转去执行其他任务</p></li><li><p>设备完成工作，发出中断信号，激活中断处理程序，调用驱动程序Q的中断服务例程处理中断，线程T就绪</p></li><li><p>线程T被调度，继续执行</p></li></ul><h3 id="驱动程序、设备、中断服务程序、I-O子系统关系"><a href="#驱动程序、设备、中断服务程序、I-O子系统关系" class="headerlink" title="驱动程序、设备、中断服务程序、I/O子系统关系"></a>驱动程序、设备、中断服务程序、I/O子系统关系</h3><ul><li><p>驱动程序与内核I/O子系统</p><p>内核I/O子系统调用驱动程序，启动设备</p><p>驱动程序可以调用内核，如阻塞、唤醒线程</p></li><li><p>驱动程序与中断处理程序</p><p>中断处理程序调用驱动程序，执行设备中断服务例程</p></li><li><p>驱动程序与设备</p><p>驱动程序向设备发送命令，检测设备状态，通过中断机制响应设备事件</p></li></ul><h3 id="缓冲区的作用"><a href="#缓冲区的作用" class="headerlink" title="缓冲区的作用"></a>缓冲区的作用</h3><p>在内存中预留指定大小的存储空间用来临时存储I/O数据，可以缓和通信双方数据处理速度、单元的差异性，减少实际物理读写次数，提升并发性</p><p>缓冲区一直被重用，可以减少动态分配和回收内存的次数</p><h3 id="缓冲机制的三种用途并举例"><a href="#缓冲机制的三种用途并举例" class="headerlink" title="缓冲机制的三种用途并举例"></a>缓冲机制的三种用途并举例</h3><ul><li><p>处理数据流的生产者与消费者之间的速度差异</p><p>从调制解调器接收文件要保存到硬盘上。由于调制解调器大约比硬盘慢数千倍，所以在内存中创建缓冲区累计从调制解调器接收到的字节，当整个缓冲区填满后，通过一次操作将缓冲区内容写入磁盘中</p></li><li><p>协调传输数据大小不一致的设备</p><p>计算机网络中，缓冲用来处理消息的分段与重组。在发送端，一个到消息分成若干小包；在接收端，将包放在重组缓冲区内，最终生成完成的消息</p></li><li><p>支持应用程序I/O的复制语义</p><p>当某应用程序需要将缓冲区内的数据写入到磁盘上时，操作系统将应用程序缓冲区复制到内核缓冲区中，让磁盘写操作在内核缓冲区中执行，这样后来应用程序缓冲区的改变就没有影响</p></li></ul><h3 id="使用cache的意义"><a href="#使用cache的意义" class="headerlink" title="使用cache的意义"></a>使用cache的意义</h3><p>解决数据读写速度不匹配的问题</p><h3 id="高速缓存与缓冲区的区别"><a href="#高速缓存与缓冲区的区别" class="headerlink" title="高速缓存与缓冲区的区别"></a>高速缓存与缓冲区的区别</h3><p>作用上：高速缓存为了提高效率；缓冲区用于通信双方数据的交换</p><p>内容上：高速缓存中的内容是另一个存储器内容的备份；缓冲区中的数据是唯一的</p><h3 id="异步I-O-阻塞I-O-非阻塞I-O的区别，并举例"><a href="#异步I-O-阻塞I-O-非阻塞I-O的区别，并举例" class="headerlink" title="异步I/O 阻塞I/O 非阻塞I/O的区别，并举例"></a>异步I/O 阻塞I/O 非阻塞I/O的区别，并举例</h3><p>阻塞I/O：请求I/O系统调用后一直等待直到获得结果，进程变为就绪态 socket中的listen(), send(), recv()等</p><p>非阻塞式I/O：请求I/O系统调用后立即返回 socket中的select()</p><p>异步I/O：请求I/O系统调用后立即返回，I/O操作完成后向进程发出信号执行回调函数 aio_read()</p><h3 id="访存操作可能会导致I-O的进行，某进程读写文件时可能并没有I-O设备执行，为什么"><a href="#访存操作可能会导致I-O的进行，某进程读写文件时可能并没有I-O设备执行，为什么" class="headerlink" title="访存操作可能会导致I/O的进行，某进程读写文件时可能并没有I/O设备执行，为什么"></a>访存操作可能会导致I/O的进行，某进程读写文件时可能并没有I/O设备执行，为什么</h3><p>使用了假脱机技术。操作系统对于用户的读写文件请求，并没有真正把I/O设备分配给该用户进程，而是在磁盘缓冲区中为进程分配了空闲盘块和建立了一张I/O请求表，实现了虚拟设备的功能</p><h3 id="批处理、脱机、假脱机为了解决什么问题"><a href="#批处理、脱机、假脱机为了解决什么问题" class="headerlink" title="批处理、脱机、假脱机为了解决什么问题"></a>批处理、脱机、假脱机为了解决什么问题</h3><p>批处理阶段引入脱机技术（在外围控制机的控制下I/O设备的输入输出先被送到更快速的磁带上）缓解了CPU与慢速I/O设备的速度矛盾</p><p>假脱机技术用软件的方式模拟脱机技术（磁盘上开辟的输入输出井模拟磁带，输入输出进程模拟外围控制机）提高了I/O速度，把一台物理设备虚拟成逻辑上的多台设备，将独占设备改造为共享设备</p><h3 id="磁盘分配的三种方式和各自优缺点"><a href="#磁盘分配的三种方式和各自优缺点" class="headerlink" title="磁盘分配的三种方式和各自优缺点"></a>磁盘分配的三种方式和各自优缺点</h3><ul><li><p>连续分配</p><p>每个文件在磁盘上占有连续的块</p><p>优点：支持随机访问、顺序存取速度快</p><p>缺点：不方便文件扩展、会产生外碎片</p></li><li><p>链接分配</p><p>每个文件对应一个磁盘块链表，每个磁盘块有指向下一个磁盘块的指针</p><p>优点：方便文件扩展、无碎片</p><p>缺点：不支持随机访问、磁盘块指针占用空间、存取速度慢、可靠性差</p></li><li><p>索引分配</p><p>每个文件建立一张索引表，放在索引块中</p><p>优点：支持随机访问、方便文件扩展、无碎片</p><p>缺点：索引表占用空间</p></li></ul><h3 id="三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置"><a href="#三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置" class="headerlink" title="三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置"></a>三种磁盘分配方式中，FCB如何给出文件在磁盘上的物理位置</h3><p>连续分配：FCB记录了文件起始块号和长度，文件物理位置=起始块号+逻辑块号</p><p>链接分配：FCB记录了文件起始块号和结束块号，从起始块开始访问，每个磁盘块都有指向下一个磁盘块的指针，直到访问到结束块</p><p>索引分配：FCB记录了索引块所在的物理块号，访问该物理块读取索引表，得到各个逻辑块对应的物理块号</p><h3 id="FAT工作原理-链接分配中引入FAT的优点"><a href="#FAT工作原理-链接分配中引入FAT的优点" class="headerlink" title="FAT工作原理 链接分配中引入FAT的优点"></a>FAT工作原理 链接分配中引入FAT的优点</h3><p>每个磁盘建立一张文件分配表FAT，行号对应块号；每个FAT表项中存放对应磁盘块的下一块链接指针</p><p>支持随机访问</p><h3 id="空闲存储空间管理"><a href="#空闲存储空间管理" class="headerlink" title="空闲存储空间管理"></a>空闲存储空间管理</h3><ul><li><p>连续空闲空间管理</p><p>空闲区列表，每一项记录空闲区起始块号和空闲块数量</p></li><li><p>空闲块链</p><p>空闲块组成链表，指针放在空闲块中</p></li><li><p>成组空闲块链</p><p>每组100个空闲块，第一组索引在内存中，下一组索引在每组最后一块</p></li><li><p>位图</p><p>连续存储空间，每位对应一个盘块，存放在内存中</p></li></ul><h3 id="文件系统如何依据用户给出的文件名找到该文件对应的FCB"><a href="#文件系统如何依据用户给出的文件名找到该文件对应的FCB" class="headerlink" title="文件系统如何依据用户给出的文件名找到该文件对应的FCB"></a>文件系统如何依据用户给出的文件名找到该文件对应的FCB</h3><p>顺序检索目录表，找到文件名对应的目录项，该目录项就是FCB</p><h3 id="文件共享的途径"><a href="#文件共享的途径" class="headerlink" title="文件共享的途径"></a>文件共享的途径</h3><p>硬连接（基于索引节点）方式中，不同文件的目录项指向同一个索引节点，索引节点中设置一个引用计数变量</p><p>软连接（基于符号链接）方式中，由系统生成一个LINK类型文件，包含被共享文件的路径名</p><h3 id="如何实现多种文件系统的共存"><a href="#如何实现多种文件系统的共存" class="headerlink" title="如何实现多种文件系统的共存"></a>如何实现多种文件系统的共存</h3><p>文件系统的挂载，挂载表记录系统已安装文件系统的类型和指向文件系统的指针，挂载位置为目录节点或独立盘符</p><p>虚拟文件系统VFS，抽象出各种文件系统共有的部分，为各种文件系统提供一个统一的操作界面和应用编程接口</p><h3 id="操作系统中打开文件的工作过程"><a href="#操作系统中打开文件的工作过程" class="headerlink" title="操作系统中打开文件的工作过程"></a>操作系统中打开文件的工作过程</h3><p>使用open系统调用，提供文件存放路径、文件名、操作类型，操作系统在系统文件打开表中查找</p><ul><li><p>该文件已经打开</p><p>检查操作类型是否合法</p><p>在进程文件打开表中为文件分配一个表项，将该表项的指针指向系统文件打开表中该文件对应的一项</p><p>在PCB中为文件分配一个文件描述符fd作为进程文件打开表项的指针，文件打开完成</p></li><li><p>该文件没有打开</p><p>根据文件存放路径查找相应的目录文件是否在内存中，若不在则装入内存</p><p>从目录中找到文件名对应的目录项，检查操作类型是否合法，得到该文件的FCB在磁盘中的位置</p><p>将该FCB装入内存中的Active Inode中</p><p>在系统文件打开表中为文件分配一个表项，将该表项的指针指向Active Inode中对应的FCB</p><p>在进程文件打开表中为文件分配一个表项，将该表项的指针指向系统文件打开表中该文件对应的一项</p><p>在PCB中为文件分配一个文件描述符fd作为进程文件打开表项的指针，文件打开完成</p></li></ul><h3 id="临界区及其使用准则"><a href="#临界区及其使用准则" class="headerlink" title="临界区及其使用准则"></a>临界区及其使用准则</h3><p>进程在并发执行中可以共享系统中的资源，但对临界资源的访问必须互斥进行，一个进程中访问临界资源的代码段为临界区。</p><p>临界区的使用准则</p><ul><li>空闲让进：无进程处于临界区时，若有进程要求进入临界区应允许进入</li><li>忙则等待：有进程处于临界区时，其他试图进入该临界区的进程必须等待</li><li>有限等待：有进程等待进入临界区时，它的等待时间应该是有限的</li><li>让权等待：等待进入临界区的进程应释放CPU</li></ul><h3 id="同步与互斥的异同"><a href="#同步与互斥的异同" class="headerlink" title="同步与互斥的异同"></a>同步与互斥的异同</h3><p>相同点</p><ul><li>都是并发环境下操作之间的时序关系</li><li>不满足条件时线程等待</li><li>运行过程中动态判定</li></ul><p>不同点</p><ul><li>同步在时序上是固定的偏序关系</li><li>互斥在时序上只要不同时执行即可</li></ul><h3 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h3><ul><li>互斥：资源一次只能由一个进程使用</li><li>非抢占：资源只能在进程完成任务后自动释放</li><li>占有并等待：一个进程必须至少占用一个资源，并等待另一资源，且该资源被其他进程占有</li><li>循环等待：有一组等待进程{P0, P1, …, Pn}，P0等待的资源被P1占有，P1等待的资源被P2占有，……，Pn等待的资源被P0占有</li></ul><h3 id="CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁"><a href="#CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁" class="headerlink" title="CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁"></a>CPU是进程运行必需的资源，为什么进程不会因等待CPU而发生死锁</h3><p>CPU属于可剥夺性资源。只有不可剥夺资源才会因为竞争资源而产生死锁。</p><h3 id="死锁预防思路"><a href="#死锁预防思路" class="headerlink" title="死锁预防思路"></a>死锁预防思路</h3><ul><li><p>破坏互斥条件</p><p>一般不能破坏</p><p>假脱机技术可以将独占设备在逻辑上改造成共享设备</p></li><li><p>破坏占有并等待条件</p><p>一次性申请需要的所有资源；申请新资源前释放已占有资源</p><p>产生饥饿的概率增加</p></li><li><p>破坏非抢占条件</p><p>若进程请求资源不成功则回收其占有的所有资源</p><p>一般适用于易保存和恢复的资源</p></li><li><p>破坏循环等待条件</p><p>将所有资源排序编号，进程只能按序号递增的顺序申请资源</p></li></ul><h3 id="简述银行家算法避免死锁的过程"><a href="#简述银行家算法避免死锁的过程" class="headerlink" title="简述银行家算法避免死锁的过程"></a>简述银行家算法避免死锁的过程</h3><p>变量定义</p><ul><li>Allocation矩阵：当前已分配给各进程的各类资源数目</li><li>Max矩阵：各进程总共需要的各类资源数目</li><li>Need矩阵：各进程还需要的各类资源数目</li><li>Available向量：当前可供分配的各类资源数目</li><li>Work向量：用于安全检测算法中记录可供分配的各类资源数目</li><li>Finish数组：用于安全检测算法中记录是否能满足该进程所有资源请求</li></ul><p>算法过程</p><p>​    进程Pi提出申请资源的请求Request</p><ul><li><p>检查Request&lt;=Need[i]</p></li><li><p>检查Request&lt;=Available</p></li><li><p>Allocation[i]=Allocation[i]+Request</p><p>Need[i]=Need[i]-Request</p><p>Available=Available-Request</p></li><li><p>执行安全性算法</p><ul><li><p>Work=Available Finish[:]=false</p></li><li><p>查找i，使Work&gt;=Need[i]且Finish[i]=false</p><ul><li><p>若找到，则Work=Work+Allocation[i] Finish[i]=true，继续查找</p></li><li><p>若找不到，检查是否Finish数组全为true</p><p>是则安全，否则不安全</p></li></ul></li><li><p>若产生的资源分配状态安全，则满足Request请求；否则不满足，恢复到原来资源分配状态</p></li></ul></li></ul><h3 id="死锁避免、死锁预防并比较区别"><a href="#死锁避免、死锁预防并比较区别" class="headerlink" title="死锁避免、死锁预防并比较区别"></a>死锁避免、死锁预防并比较区别</h3><p>死锁预防：通过破坏产生死锁的四个必要条件之一，严格的防止死锁的出现。是在进程申请资源的层面上进行的，系统预先确定资源分配策略，系统按照策略进行分配。</p><p>死锁避免：当进程提出资源申请时系统测试资源分配，仅当能确保系统安全的时候才把资源分配给进程，这样使得系统能一直处于安全状态。是在操作系统分配资源的层面上进行的。</p><h3 id="死锁检测和恢复的思路"><a href="#死锁检测和恢复的思路" class="headerlink" title="死锁检测和恢复的思路"></a>死锁检测和恢复的思路</h3><p>检测：资源分配图化简后形成环路；死锁检测算法</p><p>恢复：资源剥夺法；撤销进程法；进程回退法</p><h3 id="阻塞、饥饿、死锁的区别"><a href="#阻塞、饥饿、死锁的区别" class="headerlink" title="阻塞、饥饿、死锁的区别"></a>阻塞、饥饿、死锁的区别</h3><p>阻塞：一个正在执行的进程由于I/O请求等事件暂时无法继续执行，将其暂停执行</p><p>饥饿：一个进程因调度算法不合理而长时间等待；发生饥饿的进程既可能是阻塞态（长期得不到需要的I/O设备）也可能是就绪态（长期得不到CPU）；等待会被释放但不会分配给自己的资源</p><p>死锁：多个进程因竞争资源而相互等待；发生死锁的进程一定处于阻塞态；等待永远不会被释放的资源</p><h3 id="简述保护的概念"><a href="#简述保护的概念" class="headerlink" title="简述保护的概念"></a>简述保护的概念</h3><ul><li><p>硬件层面</p><p>操作系统分为内核态和用户态，将可能引起损害的机器指令作为特权指令，且只能在内核态下执行特权指令</p><p>操作系统使用定时器防止用户程序陷入死循环</p></li><li><p>文件管理</p><p>文件保护指避免文件拥有者或其它用户因错误操作使文件受到破坏，有三种方式：口令保护、密码保护、访问控制（每个文件和目录增加一个访问控制列表ACL，记录每个用户名及允许的访问类型）</p></li><li><p>设备管理</p><p>设备被看作文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中的信息判断用户是否有访问权限，来实现设备保护的功能</p></li><li><p>存储管理</p><p>保护内存使各道作业互不干扰，可以设置一对上下限寄存器或基址寄存器和限长寄存器，当进行地址变换时检查是否出现越界</p></li><li><p>进程同步</p><p>为保护临界区资源同一时间只能由一个进程访问，可以采用硬件方法：关中断、TestAndSet指令、Swap指令，软件方法：Peterson算法</p></li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="m-n-k生产者-消费者问题"><a href="#m-n-k生产者-消费者问题" class="headerlink" title="m-n-k生产者-消费者问题"></a>m-n-k生产者-消费者问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore full=<span class="hljs-number">0</span>, empty=k, mutex=<span class="hljs-number">1</span>;<br>Item buffer[k];<br><span class="hljs-keyword">int</span> in=<span class="hljs-number">0</span>, out=<span class="hljs-number">0</span>;<br><br>producer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(empty);<br>    P(mutex);<br>    buffer[in] = item;<br>    in = (in+<span class="hljs-number">1</span>)%k;<br>    V(full);<br>    V(mutex);<br>&#125;<br><br>consumer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(full);<br>    P(mutex);<br>    item = buffer[out];<br>    out = (out+<span class="hljs-number">1</span>)%k;<br>    V(empty);<br>    V(mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore rw_mutex=<span class="hljs-number">1</span>, r_mutex=<span class="hljs-number">1</span>, w=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> r_count=<span class="hljs-number">0</span>;<br><br>writer:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(w);<br>    P(rw_mutex);<br>    <span class="hljs-comment">//writing...</span><br>    V(rw_mutex);<br>    V(w);<br>&#125;<br><br>reader:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    P(w);<br>    P(r_mutex);<br>    <span class="hljs-keyword">if</span>(r_count == <span class="hljs-number">0</span>)&#123;<br>        P(rw_mutex);<br>    &#125;<br>    r_count++;<br>    V(r_mutex);<br>    V(w);<br>    <span class="hljs-comment">//reading...</span><br>    P(r_mutex);<br>    r_count--;<br>    <span class="hljs-keyword">if</span>(r_count == <span class="hljs-number">0</span>)&#123;<br>        V(rw_mutex);<br>    &#125;<br>    V(r_mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">Semaphore chopstick[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;, mutex=<span class="hljs-number">1</span>;<br>Philosopher_i:<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>P(mutex);<br>    P(chopstick[i]);<br>    P(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    <span class="hljs-comment">//eating...</span><br>    V(mutex);<br>    V(chopstick[i]);<br>    V(chopstick[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">5</span>]);<br>    <span class="hljs-comment">//thinking...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SDU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>review</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
