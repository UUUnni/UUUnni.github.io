

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>

<script src="https://cdn.jsdelivr.net/gh/Sanarous/files@1.151/js/clicklove.js"></script>



<head>
  <meta charset="UTF-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC&display=swap" rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700;900&amp;display=swap" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/sun.png">
  <link rel="icon" href="/img/sun.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#252d38">
  <meta name="author" content="31">
  <meta name="keywords" content="">
  
    <meta name="description" content="2019-2020学年离散数学课堂笔记 （夏令营补档 大一的31可真认真 渲染问题等之后再慢慢搞">
<meta property="og:type" content="article">
<meta property="og:title" content="SDU离散数学笔记">
<meta property="og:url" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/index.html">
<meta property="og:site_name" content="31&#39;s Blog">
<meta property="og:description" content="2019-2020学年离散数学课堂笔记 （夏令营补档 大一的31可真认真 渲染问题等之后再慢慢搞">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1586334775927.png">
<meta property="og:image" content="https://iknow-pic.cdn.bcebos.com/9d82d158ccbf6c81a3db99d7bb3eb13533fa4024?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587541489902.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587541657401.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587541675425.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587541733936.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587541835759.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587542024117.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587542068485.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587542122803.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1587541376672.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1589963664205.png">
<meta property="og:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/image-20200525151642672.png">
<meta property="article:published_time" content="2022-07-07T02:15:49.000Z">
<meta property="article:modified_time" content="2022-07-07T02:35:49.354Z">
<meta property="article:author" content="31">
<meta property="article:tag" content="SDU">
<meta property="article:tag" content="DiscreteMath">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://uuunni.github.io/2022/07/07/DiscreteMathNote/1586334775927.png">
  
  
  <title>SDU离散数学笔记 - 31&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/night-owl.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/mac.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"uuunni.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":50,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"always","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":6},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"boxDRW3XpqvL2o48tPQxzy8N-gzGzoHsz","app_key":"t8snqjGhwT0Sery7lIU4V169","server_url":"https://boxdrw3x.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>31</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/3.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="SDU离散数学笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-07 10:15" pubdate>
        2022年7月7日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      238 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">SDU离散数学笔记</h1>
            
            <div class="markdown-body">
              <h1 id="§4-代数结构"><a href="#§4-代数结构" class="headerlink" title="§4 代数结构"></a>§4 代数结构</h1><h2 id="4-1-代数系统"><a href="#4-1-代数系统" class="headerlink" title="4.1 代数系统"></a>4.1 代数系统</h2><h3 id="4-1-1-代数系统的概念"><a href="#4-1-1-代数系统的概念" class="headerlink" title="4.1.1 代数系统的概念"></a>4.1.1 代数系统的概念</h3><p>非空集合$S$</p>
<p>$S$上有运算</p>
<p>运算在$S$上封闭</p>
<h3 id="4-1-2-子代数系统"><a href="#4-1-2-子代数系统" class="headerlink" title="4.1.2 子代数系统"></a>4.1.2 子代数系统</h3><p>若$<A,\*>$是代数系统, $S\subseteq A$，$S$对$*$是封闭的，则$<S,\*>$是$<A,\*>$的子代数系统</A,\*></S,\*></A,\*></p>
<h3 id="4-1-3-特殊元素"><a href="#4-1-3-特殊元素" class="headerlink" title="4.1.3 特殊元素"></a>4.1.3 特殊元素</h3><p>(1) 单位元（幺元）</p>
<p>$e_l*x=x,x*e_r=x$</p>
<blockquote>
<p>任一代数系统中的单位元若存在，必唯一</p>
</blockquote>
<p>(2) 零元</p>
<p>$\theta _l*x=\theta _l,x*\theta_r=\theta_r$</p>
<blockquote>
<p>任一代数系统中的零元若存在，必唯一</p>
</blockquote>
<p>(3) 逆元</p>
<p>$a^{-1}<em>a=e,a</em>a^{-1}=e$</p>
<blockquote>
<p>运算满足结合律的代数系统中，若a的逆元存在，必唯一</p>
</blockquote>
<p>(4) 幂等元</p>
<p>$a*a=a$</p>
<blockquote>
<p>任一代数系统中的单位元若存在，必为幂等元</p>
</blockquote>
<h2 id="4-2-运算"><a href="#4-2-运算" class="headerlink" title="4.2 运算"></a>4.2 运算</h2><h3 id="4-2-1-运算的概念"><a href="#4-2-1-运算的概念" class="headerlink" title="4.2.1 运算的概念"></a>4.2.1 运算的概念</h3><p>假设A是一个集合，A×A到A的映射称为A上的二元运算</p>
<p>$A^n$到A的映射称为A上的n原运算</p>
<h3 id="4-2-2-运算的性质"><a href="#4-2-2-运算的性质" class="headerlink" title="4.2.2 运算的性质"></a>4.2.2 运算的性质</h3><p>(1) 封闭性</p>
<p>(2) 交换律</p>
<p>(3) 结合律</p>
<p>(4) 分配律</p>
<p>(5) 消去律</p>
<p>(6) 吸收律</p>
<p>​        $\forall a,b\in A，a<em>(a+b)=a$    则称运算</em>关于运算+满足吸收律</p>
<p>(7) 等幂律</p>
<p>​        $\forall a\in A,a*a=a$</p>
<h2 id="4-3-同态与同构"><a href="#4-3-同态与同构" class="headerlink" title="4.3 同态与同构"></a>4.3 同态与同构</h2><h3 id="4-3-1-基本概念"><a href="#4-3-1-基本概念" class="headerlink" title="4.3.1 基本概念"></a>4.3.1 基本概念</h3><p>设$<A,*>$和$<B,。>$是代数系统，$f:A\to B$,如果$f$保持运算，即对$\forall x,y\in A$,有$f(x*y)=f(x)。f(y)$,则称两代数系统同态，$f$为同态映射</B,。></A,*></p>
<p>如果$f$是单射的，称$f$为单同态；如果$f$是满射的，称$f$为满同态；如果$f$是双射的，称$f$为同构$\cong$。</p>
<p>类似的，自同态，自同构</p>
<h3 id="4-3-2-同态同构的性质"><a href="#4-3-2-同态同构的性质" class="headerlink" title="4.3.2 同态同构的性质"></a>4.3.2 同态同构的性质</h3><p>(1) 如果两函数是同态同构的，则复合函数也是同态、同构的</p>
<p>(2) 满同态保持结合律</p>
<p>(3) 满同态保持交换律</p>
<p>(4) 满同态保持单位元</p>
<p>(5) 满同态保持逆元</p>
<p>(6) 满同态保持零元</p>
<p>(7) 满同态保持幂等元</p>
<p>(8) 同构映射运算性质双向$(f,f^{-1})$保持</p>
<h2 id="4-4-同余关系与商代数"><a href="#4-4-同余关系与商代数" class="headerlink" title="4.4 同余关系与商代数"></a>4.4 同余关系与商代数</h2><h3 id="4-4-1-同余关系"><a href="#4-4-1-同余关系" class="headerlink" title="4.4.1 同余关系"></a>4.4.1 同余关系</h3><p>假设 $<A,*> $是一个代数系统，E 是 A 上的等价关系。如果对$x_1,x_2,y_1,y_2\in A$当$x_1Ex_2,y_1Ey_2$时，必有$(x_1<em>y_1)E(x_2</em>y_2)$，则称E 是 A 上的同余关系。</A,*></p>
<h2 id="4-5-直积"><a href="#4-5-直积" class="headerlink" title="4.5 直积"></a>4.5 直积</h2><p>设$ <A,*>$和$<B,°>$ 为两个代数系统,$<A×B,\Delta>$称为两代数系统的直积。其中$ A×B$ 是 A 和 B 的笛卡尔乘积，$\Delta$定义如下：对任意的$<x,y>,<u,v>\in A×B，<x,y>\Delta<u,v>=<x*u,y°v>$<strong>。</strong></x*u,y°v></u,v></x,y></u,v></x,y></A×B,\Delta></B,°></A,*></p>
<h1 id="§5-群"><a href="#§5-群" class="headerlink" title="§5 群"></a>§5 群</h1><h2 id="5-1-半群"><a href="#5-1-半群" class="headerlink" title="5.1 半群"></a>5.1 半群</h2><h3 id="5-1-1-半群的定义"><a href="#5-1-1-半群的定义" class="headerlink" title="5.1.1 半群的定义"></a>5.1.1 半群的定义</h3><p>运算满足结合律的代数系统</p>
<blockquote>
<p>证明$<A,*>$是半群</A,*></p>
<blockquote>
<p>验证$(a<em>b)</em>c=a<em>(b</em>c)$</p>
</blockquote>
</blockquote>
<p>$a^m*a^n=a^{m+n},(a^m)^n=a^{mn}$</p>
<h3 id="5-1-2-交换半群"><a href="#5-1-2-交换半群" class="headerlink" title="5.1.2 交换半群"></a>5.1.2 交换半群</h3><p>满足交换律的半群</p>
<p>$(a<em>b)^n=a^n</em>b*n$</p>
<h3 id="5-1-3-独异点（含幺半群）"><a href="#5-1-3-独异点（含幺半群）" class="headerlink" title="5.1.3 独异点（含幺半群）"></a>5.1.3 独异点（含幺半群）</h3><p>含有单位元的半群</p>
<p>$(a^{-1})^{-1}=a\(a<em>b)^{-1}=b^{-1}</em>a^{-1}$</p>
<h3 id="5-1-4-子半群"><a href="#5-1-4-子半群" class="headerlink" title="5.1.4 子半群"></a>5.1.4 子半群</h3><p>若$<S,*>$是半群,$T\subseteq S,<T,*>$也是半群，则$<T,*>$是子半群</T,*></T,*></S,*></p>
<p>若$S$的单位元也在$T$内，则$<T,*>$是子含幺半群</T,*></p>
<blockquote>
<p>证明$<T,*>$是$<S,*>$的子含幺半群</S,*></T,*></p>
<blockquote>
<p>(1)封闭性$\star$</p>
<p>(2)可结合</p>
<p>(3)单位元是同一个</p>
</blockquote>
</blockquote>
<h2 id="5-2-群"><a href="#5-2-群" class="headerlink" title="5.2 群"></a>5.2 群</h2><h3 id="5-2-1-群的基本概念"><a href="#5-2-1-群的基本概念" class="headerlink" title="5.2.1 群的基本概念"></a>5.2.1 群的基本概念</h3><p>代数系统$<G,*>$满足：(1)运算可结合，(2)存在单位元，(3)任意元素存在逆元</G,*></p>
<p>$|G|$表示群的阶</p>
<p>若群还(4)满足交换律，则称该群为交换群，或Abel群</p>
<h3 id="5-2-2-群的性质"><a href="#5-2-2-群的性质" class="headerlink" title="5.2.2 群的性质"></a>5.2.2 群的性质</h3><p>(1)任何群都没有零元（零元的逆元不存在）</p>
<p>(2)$G$中消去律成立</p>
<p>(3)单位元$e$是$G$中唯一幂等元</p>
<p>(4)设$<G,*><h,。>$是群，$f$是$G$到$H$的同态，若$e$为$<G,*>$的单位元，则$f(e)$是$<H,。>$的单位元，并且对$\forall a\in G, f(a^{-1})=f(a)^{-1}$</H,。></G,*></h,。></G,*></p>
<p>(5)设$<G,*>$是群，$<H,。>$是任意代数系统，若存在$G$到$H$的满同态映射，则$<H,。>$必是群($\because 满同态有六保持$)</H,。></H,。></G,*></p>
<p>定理：设$<G,*>$是n阶有限群，他的运算表中的每一行/列都是G中元素的一个全排列。</G,*></p>
<p>三阶群运算表    唯一</p>
<p>四阶群运算表    ①每个元素自身为逆元；②两个元素自身为逆元，另两个元素互为逆元</p>
<p>$<G,*>$是Abel群的充要条件：$\forall a,b\in G,(a<em>b)</em>(a<em>b)=(a</em>a)<em>(b</em>b)$</G,*></p>
<p>任何阶数是1，2，3，4阶的群都是Abel群</p>
<p>$<G,*>$是一个二阶群，则$<G×G，*>$是一个Klein群，且是Abel群。</G×G，*></G,*></p>
<h3 id="5-2-3-半群与群"><a href="#5-2-3-半群与群" class="headerlink" title="5.2.3 半群与群"></a>5.2.3 半群与群</h3><p>（1）假设$<G,*>$是半群，并且</G,*></p>
<p>①$<G,*>$中有一左单位元$e$，使得对任意的$a\in G$ ,有$e*a=a$</G,*></p>
<p>②$<G,*>$中任意元素都有左逆元$a^{-1}$,使得$a^{-1}*a=e$</G,*></p>
<p>则$<G,*>$是群</G,*></p>
<p>（2）有限半群，如果消去律成立，则必为群</p>
<h2 id="5-3-子群与元素周期"><a href="#5-3-子群与元素周期" class="headerlink" title="5.3 子群与元素周期"></a>5.3 子群与元素周期</h2><h3 id="5-3-1-子群"><a href="#5-3-1-子群" class="headerlink" title="5.3.1 子群"></a>5.3.1 子群</h3><p>若$<G,*>$是一个群，非空集合$H\subseteq G$,如果$H$在$G$的运算下也构成群，则称$<H,*>$是$<G,*>$的子群。</G,*></H,*></G,*></p>
<p><strong>定理</strong>：设$<H,*>$是$<G,*>$的子群，则：</G,*></H,*></p>
<p>​        （1）$<H,*>$的单位元一定是$<G,*>$的单位元</G,*></H,*></p>
<p>​        （2）$\forall a\in H$，$a$在$H$中的逆元，一定是$a$在$G$中的逆元</p>
<h3 id="5-3-2-由子集构成子群的条件"><a href="#5-3-2-由子集构成子群的条件" class="headerlink" title="5.3.2 由子集构成子群的条件"></a>5.3.2 由子集构成子群的条件</h3><p>设$H$是$<G,*>$中$G$的非空子集，要$H$构成$<G,*>$子群 (封闭性，单位元，逆元，结合律自带)</G,*></G,*></p>
<p>（1）充要条件</p>
<p>​        ①$\forall a,b\in H,a*b\in H$</p>
<p>​        ②$\forall a\in H,a^{-1}\in H$</p>
<p>（2）H是G的非空子集，充要条件：</p>
<p>​        $\forall a,b\in H,a*b^{-1}\in H$</p>
<p>（3）H是G的非空<strong>有限</strong>子集，充要条件：</p>
<p>​        $\forall a,b\in H,a*b\in H$</p>
<h3 id="5-3-3-元素的周期"><a href="#5-3-3-元素的周期" class="headerlink" title="5.3.3 元素的周期"></a>5.3.3 元素的周期</h3><p>（1）群中元素的幂运算</p>
<p>​    设$<G,*>$是一个群，$a\in G$，则：</G,*></p>
<p>​    $a^0=e,a^{i+1}=a^i*a$</p>
<p>​    $(a^i)^{-1}=a^{-i}=(a^{-1})(a^{-1})…(a^{-1})=(a^{-1})^i$</p>
<p>​    $a^m*a^n=a^{m+n}$</p>
<p>​    $(a^m)^n=a^{mn}$</p>
<p>（2）定义</p>
<p>$<G,*>$是一个群，$a\in G$，使$a^n=e$的最小正整数n为元素$a$的周期或阶，若$n$不存在，则称元素$a$周期无限。记为$|a|$。</G,*></p>
<p>（3）元素周期的性质</p>
<p>设$<G,*>$是一个群，$a\in G$</G,*></p>
<p>①a的周期等于a生成的循环子群的阶，即$|a|=|(a)|$</p>
<p>②若a的周期为n，则$a^m=e$的充分必要条件是$n|m$（m是n的整数倍）</p>
<p>推论：<br>$(a)=\{a^0,a^1,…,a^{n-1}\}$</p>
<p>$|a|=|a^{-1}|$</p>
<h2 id="5-4-循环群"><a href="#5-4-循环群" class="headerlink" title="5.4 循环群"></a>5.4 循环群</h2><h3 id="5-4-1-定义"><a href="#5-4-1-定义" class="headerlink" title="5.4.1 定义"></a>5.4.1 定义</h3><p>设$<G,*>$是一个群，$\exist a\in G,G=(a)=\{a^i|i\in Z\}$，集合中任意元素都由a的幂构成，则称该群为循环群，元素$a$称为循环群的生成元。</G,*></p>
<h3 id="5-4-2-循环群的性质"><a href="#5-4-2-循环群的性质" class="headerlink" title="5.4.2 循环群的性质"></a>5.4.2 循环群的性质</h3><p>（1）设$<G,*>$是一个循环群</G,*></p>
<p>​          ①若$<G,*>$是n阶有限群循环群，则$<G,*>\cong<Z_n,+_n>$</Z_n,+_n></G,*></G,*></p>
<p>​          ②若$<G,*>$是无限群循环群，则$<G,*>\cong<Z,+>$</Z,+></G,*></G,*></p>
<p>（2）循环群的子群必为循环群</p>
<p>（3）设$<G,*>$是n阶循环群，m是正整数，并且m|n，则G中存在<strong>唯一</strong>一个m阶子群</G,*></p>
<p>​          n阶循环群的子群个数恰为n的正因子数</p>
<p>循环群的同态像必为循环群</p>
<p>若$<G,*>$是无限循环群，则只有两个生成元 $a,a^{-1}$</G,*></p>
<p>循环群必是Abel群</p>
<p>循环群的阶与生成元的阶相等</p>
<p>素数阶群一定是循环群，它的生成元是任一不为单位元的元素</p>
<h2 id="5-5-置换群"><a href="#5-5-置换群" class="headerlink" title="5.5 置换群"></a>5.5 置换群</h2><h3 id="5-5-1-置换及其运算"><a href="#5-5-1-置换及其运算" class="headerlink" title="5.5.1 置换及其运算"></a>5.5.1 置换及其运算</h3><p>（1）有限集S到其自身的双射称为S上的一个置换。当$|S|=n$时，S上的置换称为n次置换。</p>
<p>（2）定义：设S上有如下置换$f=\left(\begin{matrix}a_1&amp;a_2&amp;…&amp;a_{i-1}&amp;a_i&amp;…&amp;a_n\\a_2&amp;a_3&amp;…&amp;a_i&amp;a_1&amp;…&amp;a_n\end{matrix}\right)$称该置换为循环置换，记为$(a_1,a_2,…,a_i)$，i为循环长度。当$i=2$时称为对换。单位置换，即恒等映射也视为循环置换，记为$(1)$或$(n)$</p>
<h3 id="5-5-2-置换群"><a href="#5-5-2-置换群" class="headerlink" title="5.5.2 置换群"></a>5.5.2 置换群</h3><p>（1）定义</p>
<p>一个n阶的有限集合S上所有的置换所组成的集合$S_n$及其复合运算°构成群，称$<S,°>$为n次对称群，而$<S,°>$的任意子群为n次置换群。</S,°></S,°></p>
<p>（2）性质</p>
<p>（Cayley凯利定理）任意n阶群必同构于一个n次置换群</p>
<p>置换群都是Abel群</p>
<p>n次对称群的阶一定是$n!$，$|S_n|=n!$</p>
<h2 id="5-6-陪集"><a href="#5-6-陪集" class="headerlink" title="5.6 陪集"></a>5.6 陪集</h2><h3 id="5-6-1-左同余关系（左陪集关系）"><a href="#5-6-1-左同余关系（左陪集关系）" class="headerlink" title="5.6.1 左同余关系（左陪集关系）"></a>5.6.1 左同余关系（左陪集关系）</h3><p>（1）定义</p>
<p>设$<G,*>$是一个群，$<H,*>$是其子群。利用$H$在$G$上定义关系：</H,*></G,*></p>
<script type="math/tex; mode=display">
R_H=\{<a,b>|a,b\in G,b^{-1}*a\in H\}\\
R^,_H=\{<a,b>|a,b\in G ,a*b^{-1}\in H\}</script><p>则称$R_H$为$G$上的模$H$左同余关系（左陪集关系）；$R^,_H$为$G$上的模$H$右同余关系（右陪集关系）</p>
<p>（2）定理</p>
<p>设$<H,*>$是$<G,*>$的一个子群，则 $G$ 中模 $H$ 左同余关系是等价关系（自反、对称、传递）</G,*></H,*></p>
<h3 id="5-6-2-左陪集"><a href="#5-6-2-左陪集" class="headerlink" title="5.6.2 左陪集"></a>5.6.2 左陪集</h3><p>（1）定义</p>
<p>设$<H,*>$是$<G,*>$的一个子群，则$a\in G$为代表元的模$H$同余关系的等价类$[a]=\{a*h|h\in H\}$，称为 $H$ 在 $G$ 内由 a 确定的左陪集。简记为：$aH=[a]=\{ah|h\in H\}$</G,*></H,*></p>
<p>（2）定理<br>设$<H,*>$是$<G,*>$的一个子群，则：</G,*></H,*></p>
<p>①$eH=H$，单位元的陪集还是子群自身</p>
<p>②$\forall a,b\in G,aH=bH \Leftrightarrow b^{-1}*a\in H$，两个元素的陪集相同，则两个元素有模H左同余关系</p>
<p>③$\forall a\in G,aH=H\Leftrightarrow a\in H$，某元素的陪集与子群相同，则该元素一定是子群中的元素</p>
<h3 id="5-6-3-左商集和右商集"><a href="#5-6-3-左商集和右商集" class="headerlink" title="5.6.3 左商集和右商集"></a>5.6.3 左商集和右商集</h3><p>（1）定义<br>① 设$<H,*>$是$<G,*>$的一个子群，由H所确定的G上所有元素构成的集合称为G对H的左商集，记为：$S_L=\{aH|a\in G\}$；所有右陪集构成的集合称为G对H的右商集，记为：$S_R=\{Ha|a\in G\}$</G,*></H,*></p>
<p>② 设$<H,*>$是$<G,*>$的一个子群，$H$的左（右）陪集数称为$H$在$G$内的指数。记为：$[G:H]=|S_L|$或$[G:H]=|S_R|$，$|S_{L或R}|\times |H|=|G|$</G,*></H,*></p>
<p>（2）定理</p>
<p>① 设$<H,*>$是$<G,*>$的一个子群，则G关于H的左右商集必等势。</G,*></H,*></p>
<p>定义映射$f:S_L\to S_R,\forall a\in G,f(aH)=Ha^{-1}$</p>
<p>② 设$<H,*>$是$<G,*>$的一个子群，H的任意左陪集（右陪集）与H有相同的元素个数。$\forall a\in G,|aH|=|H|$或$|Ha|=|H|$</G,*></H,*></p>
<h3 id="5-6-4-Lagrange定理"><a href="#5-6-4-Lagrange定理" class="headerlink" title="5.6.4 Lagrange定理"></a>5.6.4 Lagrange定理</h3><p>假设$<G,*>$是有限群，$<H,*>$是$<G,*>$的子群，则H的阶必整除G的阶，并且$|G|=[G:H]|H|$。n阶群的子群的阶一定是n的因子。</G,*></H,*></G,*></p>
<p>（1）任何素数阶的群不可能有<strong>非平凡</strong>的子群</p>
<blockquote>
<p>平凡子群： $S\sube A,S=A$ 或 $S=e$</p>
<p>素数阶群的子群的阶只能是1或素数自身</p>
</blockquote>
<p>（2）素数阶的群必为循环群</p>
<p>素数阶循环群的每个非单位元都是生成元</p>
<blockquote>
<p>假设$<G,*>$是p阶有限群，p是素数，对G中任一非单位元a，设a的阶k，则$k\not =1$</G,*></p>
<p>由（3） k|p，因为p是素数，所以k=p。所以a是G的生成元。</p>
</blockquote>
<p>（3）假设$<G,*>$是n阶有限群，则对$\forall a\in G,|a| |n$</G,*></p>
<blockquote>
<p>n阶有限群中任意元素的周期只能是n的正因子</p>
</blockquote>
<p>（4）假设$<G,*>$是n阶有限群，则对$\forall a\in G,a^n=e$</G,*></p>
<blockquote>
<p>$\forall a\in G$，由（3）$|a|||G|$ ，设$|a|=m,|G|=n,n=km$</p>
<p>$a^n=a^{km}=(a^m)^k=e^k=e$</p>
</blockquote>
<h2 id="5-7-正规子群"><a href="#5-7-正规子群" class="headerlink" title="5.7 正规子群"></a>5.7 正规子群</h2><h3 id="5-7-1-正规子群的定义"><a href="#5-7-1-正规子群的定义" class="headerlink" title="5.7.1 正规子群的定义"></a>5.7.1 正规子群的定义</h3><p>设$<H,*>$是$<G,*>$的子群，如果对$\forall a\in G$，有$aH=Ha$，则称$<H,*>$是$<G,*>$的正规子群（不变子群）。</G,*></H,*></G,*></H,*></p>
<h3 id="5-7-2-判定正规子群的条件"><a href="#5-7-2-判定正规子群的条件" class="headerlink" title="5.7.2 判定正规子群的条件"></a>5.7.2 判定正规子群的条件</h3><p>设$<H,*>$是$<G,*>$的一个子群，则以下条件等价：</G,*></H,*></p>
<p>（1）$\forall a\in G,aH=Ha$</p>
<p>（2）$\forall a\in G,h\in H$，必存在$h´\in H$，使得$h<em>a=a</em>h´$</p>
<p>（3）$\forall a\in G,h\in H,a<em>h</em>a^{-1}\in H$，或者$a^{-1}<em>h</em>a\in H$</p>
<p>充要条件：$\forall a\in G,h\in H,a<em>h</em>a^{-1}\in H$，或者$\ a^{-1}<em>h</em>a\in H$</p>
<p>任何交换群的子群都是其正规子群</p>
<p>一个群G总有两个平凡的正规子群$H={e},H=G$</p>
<h3 id="5-7-3-商群"><a href="#5-7-3-商群" class="headerlink" title="5.7.3 商群"></a>5.7.3 商群</h3><p>定义:</p>
<p>子群$<H,*>$是群$<G,*>$的<strong>正规子群</strong>，在$G/H$上定义新的运算$\circ$：$\forall a,b\in G,aH\circ bH=(a*b)H$，称为$G$对$H$的商群。</G,*></H,*></p>
<p>$G/H=\{不同陪集作为元素\}$满足封闭性、可结合性、单位元、逆元</p>
<p>正规子群确定，商群一定唯一</p>
<h3 id="5-7-4-子集的乘积"><a href="#5-7-4-子集的乘积" class="headerlink" title="5.7.4 子集的乘积"></a>5.7.4 子集的乘积</h3><p>（1）定义</p>
<p>假设$<G,*>$是一个群，A，B是G的子集，集合$\{ab|a\in A,b\in B\}$，称为A，B的乘积，记为A*B或AB。</G,*></p>
<p>（2）性质</p>
<p>子集的乘积满足结合律。即$(A<em>B)</em>C=A<em>(B</em>C)$</p>
<p>在子集的运算下，任何子群都为幂等元。即$HH=H$</p>
<p>（3）定理</p>
<p>设$<H,*>$是$<G,*>$的正规子群，则对$\forall a,b\in G,aH<em>bH=(a</em>b)H$</G,*></H,*></p>
<h1 id="§6-环和域"><a href="#§6-环和域" class="headerlink" title="§6 环和域"></a>§6 环和域</h1><h2 id="6-1-环"><a href="#6-1-环" class="headerlink" title="6.1 环"></a>6.1 环</h2><h3 id="6-1-1-环"><a href="#6-1-1-环" class="headerlink" title="6.1.1 环"></a>6.1.1 环</h3><p>假设$<A,+,*>$是一个代数系统，其中，+和*都是集合A上的二元运算，如果满足：</A,+,*></p>
<p>（1）$<A,+>$是Abel群（封闭性、结合律、单位元、逆元、交换律）</A,+></p>
<p>（2）$<A,*>$是半群（封闭性、结合律）</A,*></p>
<p>（3）* 对 + 是可分配的</p>
<p>则称$<A,+>$是一个环</A,+></p>
<p>高斯环：$<Z(i),+,·>$</Z(i),+,·></p>
<h3 id="6-1-2-环的性质"><a href="#6-1-2-环的性质" class="headerlink" title="6.1.2 环的性质"></a>6.1.2 环的性质</h3><p>假设$<A,+，*>$是一个环</A,+，*></p>
<p>（1）因为$<A,+>$是Abel群，所以+满足结合律、交换律、消去律，$<A,+>$中有单位元。</A,+></A,+></p>
<p>​        约定$a^n=a+a+…+a=na$，那么：<br>​        $\forall a,b\in A,(a+b)^n=na+nb$</p>
<p>​        $a^{m+n}=a^m+a^n=(m+n)a$<br>​        $a^{mn}=(a^m)^n=n(ma)$</p>
<p>（2）假设e是$<A,+>$的单位元，对$\forall a,b,c\in A$</A,+></p>
<p>​    ①$a<em>e=e</em>a=e\ \ \ \ (\theta <em>a=a</em>\theta=\theta)$</p>
<blockquote>
<p><strong>在环中加法单位元一定是乘法零元</strong></p>
</blockquote>
<p>​    ②$a<em>b^{-1}=a^{-1}</em>b=(a*b)^{-1}$</p>
<p>​    ③$a^{-1}<em>b^{-1}=a</em>b$ </p>
<blockquote>
<script type="math/tex; mode=display">
(a*b)+(a^{-1}*b)=(a+a^{-1})*b=e*b=e\\
(a^{-1}*b)+(a*b)=(a^{-1}+a)*b=e*b=e\\
\therefore(a*b)^{-1}=a^{-1}*b\\
\therefore(a*b)^{-1}=a*b^{-1}\\
\because a^{-1}*b=a*b^{-1}\\
\therefore a*b=(a^{-1})^{-1}*b=a^{-1}*b^{-1}</script></blockquote>
<p>​    ④$a<em>(b+c^{-1})=(a</em>b)+(a*c)^{-1}$</p>
<p>​    ⑤$(b+c^{-1})<em>a=(b</em>a)+(c*a)^{-1}$</p>
<ul>
<li>任一环的同态像也是环（满同态下运算保持易证Abel群和半群，只需证分配律，设$f(a_i)=b_i$）</li>
</ul>
<h3 id="6-1-3-由-运算确定的几种环"><a href="#6-1-3-由-运算确定的几种环" class="headerlink" title="6.1.3 由*运算确定的几种环"></a>6.1.3 由*运算确定的几种环</h3><h4 id="（1）含幺环"><a href="#（1）含幺环" class="headerlink" title="（1）含幺环"></a>（1）含幺环</h4><p>在环$<A,+,*>$中，如果$<A,*>$是含幺半群，并且$e´$是单位元，则称$e´$为环的单位元。这时称A为有单位元的环（有/含幺环）。如果元素a在$<A,*>$中有逆元，则在含有单位元的环中，该元素的逆也称为环中元素的逆。</A,*></A,*></A,+,*></p>
<h4 id="（2）零环"><a href="#（2）零环" class="headerlink" title="（2）零环"></a>（2）零环</h4><p>如果环中只含有一个元素，此时该元素应该是$<A,+>$中的单位元，也是$<A,*>$中的零元，所以这种环称为零环。$A=\{\theta\}$</A,*></A,+></p>
<blockquote>
<p><strong>定理1</strong>    设A为有单位元的环，且不只含一个元素，则$1\not=0$（0加法单位元，1乘法单位元）</p>
</blockquote>
<h4 id="（3）可交换环"><a href="#（3）可交换环" class="headerlink" title="（3）可交换环"></a>（3）可交换环</h4><p>设$<A,+,*>$是环，当$<A,*>$是可交换半群时，称$<A,+,*>$是可交换环。</A,+,*></A,*></A,+,*></p>
<h2 id="6-2-整环、除环和域"><a href="#6-2-整环、除环和域" class="headerlink" title="6.2 整环、除环和域"></a>6.2 整环、除环和域</h2><h3 id="6-2-1-零因子"><a href="#6-2-1-零因子" class="headerlink" title="6.2.1 零因子"></a>6.2.1 零因子</h3><p>设$<A,\star,*>$是环，如果$\exist a,b\in A,a\not=\theta,b\not=\theta,a*b=\theta$，则称a为A中的左零因子，b为A中的右零因子，左、右零因子统称为零因子。</A,\star,*></p>
<blockquote>
<p>对于剩余环$<Z_m,+_m,×_m>$，若m不是素数，则$Z_m$中必存在零因子。</Z_m,+_m,×_m></p>
</blockquote>
<p>当一个环中不含零因子时，称它为无零因子环。即在无零因子环中，对$\forall a,b\in A$，若$a*b=\theta$，则必有$a=\theta$或$b=\theta$</p>
<blockquote>
<p><strong>定理1</strong>    设$<A,+,*>$是无零因子环，则*在A上消去律成立。$a<em>c=b</em>c \to a=b$。反之亦然</A,+,*></p>
</blockquote>
<h3 id="6-2-2-整环"><a href="#6-2-2-整环" class="headerlink" title="6.2.2 整环"></a>6.2.2 整环</h3><p>设$<A,+,*>$是无零因子环，并且是可交换的含幺环，则称它为整环。</A,+,*></p>
<blockquote>
<p>整数环$<Z,+,·>$    高斯环$<Z(i),+,·>$    模m剩余环(m是素数)$<Z_m,+_m,×_m>$</Z_m,+_m,×_m></Z(i),+,·></Z,+,·></p>
<p><strong>有限</strong>整环中乘法消去律成立</p>
</blockquote>
<h3 id="6-2-3-除环、域"><a href="#6-2-3-除环、域" class="headerlink" title="6.2.3 除环、域"></a>6.2.3 除环、域</h3><h4 id="6-2-3-1-定义"><a href="#6-2-3-1-定义" class="headerlink" title="6.2.3.1 定义"></a>6.2.3.1 定义</h4><ol>
<li><p>假设$<A,+,*>$是一个代数系统，其中，+和*都是集合A上的二元运算，如果满足：</A,+,*></p>
<p>（1）$<A,+>$是交换(Abel)群</A,+></p>
<p>（2）$<A-\{e\},*>$是群</A-\{e\},*></p>
<p>（3）*对+是可分配的</p>
<p>则称$<A,+,*>$是一个<strong>除环</strong></A,+,*></p>
</li>
<li><p>假设$<A,+,*>$是一个代数系统，其中，+和*都是集合A上的二元运算，如果满足：</A,+,*></p>
<p>（1）$<A,+>$是交换(Abel)群</A,+></p>
<p>（2）$<A-\{e\},*>$也是交换群（e是+运算的单位元）</A-\{e\},*></p>
<p>（3）*对+是可分配的</p>
<p>则称$<A,+,*>$是一个<strong>域</strong></A,+,*></p>
</li>
</ol>
<h4 id="6-2-3-2-另一表示"><a href="#6-2-3-2-另一表示" class="headerlink" title="6.2.3.2 另一表示"></a>6.2.3.2 另一表示</h4><p>设R是一个有1的环，$\hat{R}=R-\{0\}$</p>
<p>如果$&lt;\hat{R},*&gt;$是一个群，则称R为除环</p>
<p>如果$&lt;\hat{R},*&gt;$是一个可交换群，则称R为域</p>
<p>（1）有单位元的环R是除环$\Leftrightarrow R$中非零元的逆元都存在$\Leftrightarrow\hat{R}$构成乘法群$(\hat{R}=R-\{0\})$</p>
<p>（2）有单位元的环R是域$\Leftrightarrow R$是交换环，且R中非零元素均可逆</p>
<blockquote>
<p><strong>定理2</strong>    设R是一个无零因子的有限环，且$|R|\ge2$，则R必为除环</p>
<p><strong>推论</strong>      有限整环必为域</p>
<p><strong>推论</strong>      若p为素数，则$<Z_p,+_p,\times_p>$为域</Z_p,+_p,\times_p></p>
</blockquote>
<p>设F是一个域，若$b\not =\theta(e)$，可将$b^{-1}$写成$1\over b$，$b^{-1}a$写成$a\over b$，在这种记号下，有以下性质：</p>
<p>设$b\not=\theta,d\not=\theta$</p>
<p>（1）$ad=bc\Leftrightarrow {a\over b}={c\over d}$</p>
<p>（2）$\frac{a}{b}\pm\frac{c}{d}=\frac{ad\pm bc}{bd}$</p>
<p>（3）$\frac{a}{b}\cdot\frac{c}{d}=\frac{ac}{bd}$</p>
<p>（4）$\frac{\frac{a}{b}}{\frac{c}{d}}=\frac{ad}{bc}$</p>
<h3 id="整环、除环、域的关系"><a href="#整环、除环、域的关系" class="headerlink" title="整环、除环、域的关系"></a>整环、除环、域的关系</h3><p><img src="/2022/07/07/DiscreteMathNote/1586334775927.png" srcset="/img/loading.gif" lazyload alt="1586334775927" style="zoom:80%;"></p>
<p>条件1：除环若可交换则是整环</p>
<p>条件2：若$A-\{e\}$每个元素都有逆元则是除环</p>
<p>条件3：除环若可交换则是域</p>
<p>条件4：若$A-\{e\}$每个元素都有逆元则是域。或有限整环也是域。</p>
<h1 id="§7-格与布尔代数"><a href="#§7-格与布尔代数" class="headerlink" title="§7 格与布尔代数"></a>§7 格与布尔代数</h1><h2 id="7-1-格"><a href="#7-1-格" class="headerlink" title="7.1 格"></a>7.1 格</h2><blockquote>
<p><strong>偏序集</strong>    $<P,\leqslant>$ P是自反的、反对称的、传递的</P,\leqslant></p>
</blockquote>
<h3 id="7-1-1-定义"><a href="#7-1-1-定义" class="headerlink" title="7.1.1 定义"></a>7.1.1 定义</h3><p>设$<L,\leqslant>$是一个偏序集，若 $\forall x,y\in L，\{x,y\}$必有最小上界和最大下界，则称$<L,\leqslant>$为格</L,\leqslant></L,\leqslant></p>
<h3 id="7-1-2-并运算和交运算"><a href="#7-1-2-并运算和交运算" class="headerlink" title="7.1.2 并运算和交运算"></a>7.1.2 并运算和交运算</h3><blockquote>
<p>在$<L,\leqslant>$中，$<L,\oplus,*>$</L,\oplus,*></L,\leqslant></p>
<p>a,b的最小上界用 $a\oplus b$ 表示（并运算）</p>
<p>a,b的最大下界用 $a*b$ 表示（交运算）</p>
</blockquote>
<p><strong>定理1</strong>    设$<L,\leqslant>$是一个格，并运算与交运算$<L,\oplus,*>$满足如下性质：</L,\oplus,*></L,\leqslant></p>
<p>​            <strong>L1幂等律</strong>    $a\oplus a=a\ \ \ \ a*a=a$</p>
<p>​            <strong>L2交换律</strong>    $a\oplus b=b\oplus a\ \ \ \ a<em>b=b</em>a$</p>
<p>​            <strong>L3结合律</strong>    $(a<em>b)</em>c=a<em>(b</em>c)\ \ \ \ (a\oplus b)\oplus c=a\oplus(b\oplus c)$</p>
<p>​            <strong>L4吸收律</strong>    $a<em>(a\oplus b)=a\ \ \ \ a\oplus(a</em>b)=a$</p>
<h2 id="7-2-格和代数系统"><a href="#7-2-格和代数系统" class="headerlink" title="7.2 格和代数系统"></a>7.2 格和代数系统</h2><p>格$<L,\leqslant>$中自然存在两个运算$\oplus$和*，从而派生出一个代数系统$<L,\oplus,*>$</L,\oplus,*></L,\leqslant></p>
<p>设$<L,\oplus,*>$是一个代数系统，$\oplus$和*是L上的两个二元运算，如果这两个运算满足幂等律、交换律、结合律、吸收律，则称$<L,\oplus,*>$是一个格</L,\oplus,*></L,\oplus,*></p>
<p><strong>定理1</strong>    设$<L,\leqslant>$是一个格，则$\forall a,b\in L$，$a\leqslant b\Leftrightarrow a*b=a\Leftrightarrow a\oplus b=b$</L,\leqslant></p>
<p><strong>引理</strong>    设$<L,\oplus,*>$是一个代数系统，$\oplus$和*满足L1-4，则$a*b=a\Leftrightarrow a\oplus b=b$</L,\oplus,*></p>
<p><strong>定理2</strong>    设$<L,\oplus,*>$是一个代数系统，$\oplus$和*满足L1-4，令L上的关系$\leqslant$定义如下：$a\leqslant b\Leftrightarrow a<em>b=a(a\oplus b=b)$，则$\leqslant$是一个偏序关系，且$a</em>b=inf\{a,b\},a\oplus b=sup\{a,b\}$</L,\oplus,*></p>
<p><strong>定理3</strong>    设$<L,\leqslant>$是格，$a,b\in L$，则 </L,\leqslant></p>
<p>​                ①$a<em>b\leqslant a\ \ \ \ a</em>b\leqslant b$        </p>
<p>​                ②$a\leqslant a\oplus b\ \ \ \ b\leqslant a\oplus b$</p>
<p><strong>定理4</strong>    设$<L,\leqslant>$是格，$a,b,c\in L$</L,\leqslant></p>
<p>​                ①$c\leqslant a,c\leqslant b\to c\leqslant a*b$</p>
<p>​                ②$a\leqslant c,b\leqslant c\to a\oplus b\leqslant c$</p>
<p><strong>定理5</strong>    设$<L,\leqslant>$是一个格，$a_1,a_2,b_1,b_2\in L$，</L,\leqslant></p>
<p>​              如果$a_1\leqslant b_1,a_2\leqslant b_2$，那么$a_1<em>a_2\leqslant b_1</em>b_2,a_1\oplus a_2\leqslant b_1\oplus b_2$</p>
<p><strong>定理6</strong>    设$<L,\leqslant>$是一个格，$a,b,c\in L$，则</L,\leqslant></p>
<p>​                $a<em>(b\oplus c)\geqslant(a</em>b)\oplus(a*c)$</p>
<p>​                $a\oplus(b<em>c)\leqslant(a\oplus b)</em>(a\oplus c)$</p>
<blockquote>
<script type="math/tex; mode=display">
\because b\leqslant b\oplus c\\
\therefore a*b\leqslant a*(b\oplus c)\\
又\ c\leqslant b\oplus c\\
故\ a*c\leqslant a*(b\oplus c)\\
\therefore (a*b)\oplus(a*v)\leqslant a*(b\oplus c)\\
即\ a*(b\oplus c)\geqslant (a*b)\oplus(a*c)\\
同理可证\ a\oplus(b*c)\leqslant(a\oplus b)*(a\oplus c)</script></blockquote>
<h2 id="7-3-子格与格同态"><a href="#7-3-子格与格同态" class="headerlink" title="7.3 子格与格同态"></a>7.3 子格与格同态</h2><p>设$<L,\oplus,*>$是一个格，如果S是L的非空子集，且S关于$\oplus,<em>$ 封闭，则称$&lt;S,\oplus,</em>&gt;$是$<L,\oplus,*>$的子格</L,\oplus,*></L,\oplus,*></p>
<p>设$<L,\oplus,*>,<L´,\cup,\cap>$是两个格，$f:L\to L´$，如果$\forall a,b\in L$，有$f(a\oplus b)=f(a)\cup f(b)$，$f(a*b)=f(a)\cap f(b)$，则称f是格L到L´的同态</L´,\cup,\cap></L,\oplus,*></p>
<h2 id="7-4-完全格、有界格、补格"><a href="#7-4-完全格、有界格、补格" class="headerlink" title="7.4 完全格、有界格、补格"></a>7.4 完全格、有界格、补格</h2><p><strong>定义1</strong>    设$<L,\leqslant>$是一个格，如果L的<strong>任意子集</strong>均有最小上界和最大下界，则称其为完全格</L,\leqslant></p>
<blockquote>
<p>有限格必为完全格</p>
</blockquote>
<p><strong>定义2</strong>    设$<L,\leqslant>$是一个格，如果L中存在最大元和最小元，则称L是有界格。最大元也成为全上界或单位元，用1表示；最小元也称为全下界或零元，用零表示。对应地，有界格也称为有单位元和零元的格</L,\leqslant></p>
<blockquote>
<p>有界格表示：$<L,\oplus,*,0,1>$    </L,\oplus,*,0,1></p>
<p>完全格必为有界格</p>
<p><strong>定理1</strong>    设L是一个有界格，则对任意$x\in L$有$x\oplus 0=x,x\oplus1=1,x<em>0=0,x</em>1=x$</p>
</blockquote>
<p><strong>定义3</strong>    设L是一个有界格，对于$a\in L$，如果存在$b\in L$使$a\oplus b=1,a*b=0$，则称b是a的补元</p>
<blockquote>
<p>一个元的补元可以不唯一</p>
<p>补元存在则最小上界和最大下界一定存在</p>
<p><strong>定理2</strong>    设L是有界格，则单位元1是零元0的唯一补元</p>
</blockquote>
<p><strong>定义4</strong>    设L是一个有界格，如果L中每个元素都有补元，则称其为补格或有补格</p>
<blockquote>
<p>有补格一定是有界格，但有界格不一定是有补格</p>
</blockquote>
<h2 id="7-5-分配格与模格"><a href="#7-5-分配格与模格" class="headerlink" title="7.5 分配格与模格"></a>7.5 分配格与模格</h2><p><strong>定义1</strong>    设L是一个格，如果L中的并、交运算互相可分配，即对$\forall a,b,c\in L,$</p>
<script type="math/tex; mode=display">
a*(b\oplus c)=(a*b)\oplus(a*c)\\
a\oplus(b*c)=(a\oplus b)*(a\oplus c)</script><p>​                则称L是分配格</p>
<blockquote>
<p><strong>定理1</strong>    设L是一个格，如果L中的交对并可分配，则并对交必可分配。反之亦然。</p>
<p><strong>定理2</strong>    设$<L,\oplus,*>$是一个分配格，$a,b,c\in L$，如果$a<em>b=a</em>c,a\oplus b=a\oplus c$，则$b=c$</L,\oplus,*></p>
<p><strong>推论</strong>    设$<L,\oplus,*>$是一个分配格，$a\in L$，a的补元若存在则是唯一的</L,\oplus,*></p>
<p><strong>定理3</strong>    一个格是分配格，当且仅当格中不含有与钻石格或五角格同构的子格</p>
<p><img src="https://iknow-pic.cdn.bcebos.com/9d82d158ccbf6c81a3db99d7bb3eb13533fa4024?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;"></p>
<p>四个元素以下的格都是分配格</p>
<p>五个元素的格仅有两个格（钻石格、五角格）是非分配格</p>
<p>在有界分配格中，所有有补元构成的集合为一个子格</p>
</blockquote>
<p><strong>定义2</strong>    设L是一个格，如果对于$\forall a,b,c\in L$，当$a\geqslant b$时必有$a<em>(b\oplus c)=b\oplus (a</em>c)$(<strong>L5 模律</strong>)，则称L为模格</p>
<blockquote>
<p><strong>定理4</strong>    分配格必为模格</p>
</blockquote>
<h2 id="7-6-布尔代数"><a href="#7-6-布尔代数" class="headerlink" title="7.6 布尔代数"></a>7.6 布尔代数</h2><h3 id="7-6-1-布尔-有补分配格"><a href="#7-6-1-布尔-有补分配格" class="headerlink" title="7.6.1 布尔-有补分配格"></a>7.6.1 布尔-有补分配格</h3><p><strong>定义</strong>    有补分配格中每个元素的补元唯一，从而可定义一个“取补”的一元运算。因此，此种格是一个有两个二元运算，一个一元运算和常数0，1的代数$<L,\oplus,*,´,0,1>$，称为布尔代数</L,\oplus,*,´,0,1></p>
<p><strong>定义1</strong>    既是<strong>补格</strong>又是<strong>分配格</strong>的格称为布尔代数</p>
<p><strong>定义2</strong>    有两个二元运算的代数$<B,\oplus,*>$，如果$\forall a,b,c\in B$，满足①交换律②分配律③有界④有补，则为布尔代数</B,\oplus,*></p>
<p><strong>定理</strong>    布尔代数$<B,\oplus,*>$，$\forall a,b\in B$，有</B,\oplus,*></p>
<p>​            $(a´)´=a$</p>
<p>​            $(a*b)´=a´\oplus b´$</p>
<p>​            $(a\oplus b)´=a´*b´$</p>
<h3 id="7-6-2-布尔表达式"><a href="#7-6-2-布尔表达式" class="headerlink" title="7.6.2 布尔表达式"></a>7.6.2 布尔表达式</h3><p>假设 B 是一个布尔代数，$x_1,x_2,…,x_n$是 B 上的变量，B上由$x_1,x_2,…,x_n$生成的布尔表达式归纳定义如下：</p>
<p>(1) B中的元素是B上由$x_1,x_2,…,x_n$生成的布尔表达式；</p>
<p>(2) B上任意变量$x_i(i=1,2,…,n)$是B上由$x_1,x_2,…,x_n$生成的布尔表达式；</p>
<p>(3)如果a，b是B上由$x_1,x_2,…,x_n$生成的布尔表达式，则$a\lor b,a\land b,a´$（a的补元）是B上由$x_1,x_2,…,x_n$生成的布尔表达式；</p>
<p>(4)只有通过有限次使用(1),(2),(3)得到的符号串是B上由$x_1,x_2,…,x_n$生成的布尔表达式。</p>
<h3 id="7-6-3-布尔函数"><a href="#7-6-3-布尔函数" class="headerlink" title="7.6.3 布尔函数"></a>7.6.3 布尔函数</h3><p>设$B=\{0,1\},B^n=\{(x_1,x_2,…,x_n)|x_i\in B其中1\le i \le n\}$是n元有序对集合，函数$f:B^n\to B$为布尔函数</p>
<h1 id="§8-基本概念"><a href="#§8-基本概念" class="headerlink" title="§8 基本概念"></a>§8 基本概念</h1><h2 id="8-1-图"><a href="#8-1-图" class="headerlink" title="8.1 图"></a>8.1 图</h2><p><strong>定义1</strong>    设V是一个非空集合，E是一个V中元素的无序对构成的多重集，有序对$G=<V,E>$称为一个图（无向图），其中，V称为顶点集，其元素称为顶点或点，E称为边集，其元素称为边。</V,E></p>
<p><strong>定义2</strong>    设G是一个图，$u,v\in V(G),e=uv\in E(G)$，称u,v为边e的端点，e为连接u,v的边，并称顶点u,v与边e彼此关联。而顶点u,v相邻接。</p>
<p><strong>定义3</strong>    在任意图中，同一条边关联的两点，称为相邻点，同一个点关联的诸边称为相邻边。</p>
<p><strong>定义4</strong>    设G是一个图，若$e\in E(G)$的两端点重合为一点，即$e=uu$，则e为自环。若$uv\in E(G)$的重复度$&gt;1$，则称$uv$是多重边。</p>
<h3 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h3><ul>
<li>集合</li>
<li>矩阵<ul>
<li>邻接矩阵（$n*n$方阵，点和点的关系）</li>
<li>关联矩阵（$n*m$方阵，点和边的关系）</li>
</ul>
</li>
<li>邻接表（相邻表）</li>
<li>画图</li>
</ul>
<h3 id="图的类型"><a href="#图的类型" class="headerlink" title="图的类型"></a>图的类型</h3><ul>
<li>有向图<ul>
<li>简单有向图</li>
<li>有向多重图（可以有平行边，也可以有自环）</li>
</ul>
</li>
<li>无向图<ul>
<li>简单图</li>
<li>多重图（可以有多重边）</li>
<li>伪图（可以有多重边，也可以有自环）</li>
</ul>
</li>
</ul>
<h3 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h3><p><strong>定义5</strong>    设G是一个图，$v\in V(G)$，与v相关联的边数（自环计算两次）称为v的度数，记为$deg_G(v)$或简记为$deg(v)/d(v)$。</p>
<p>​        孤立点$d(v)=0$    悬挂点$d(v)=1$    奇顶点$d(v)是奇数$    偶顶点$d(v)是偶数$</p>
<p>​        最大度数$\Delta(G)=max\{d(v)|v\in V(G)\}$    最小度数$\delta(G)=min\{d(v)|v\in V(G)\}$</p>
<p><strong>定义6</strong>    设G是图，若$V(G),E(G)$均是有限集，则称G为有限图</p>
<p>​        $v(G)/v$表示图G的顶点数，$\epsilon(G)/\epsilon$表示图G的边数</p>
<p><strong>定理1</strong>    对任意图G，有$\sum_{v\in V(G)}d(v)=2\epsilon$（握手定理）</p>
<p><strong>推论</strong>    任意无向图中奇顶点的个数必为偶数</p>
<p>非负整数列$d=(d_1,d_2,…,d_n)(1\le i\le n)$可图化的充分必要条件是$\sum_{i=1}^nd_i=0(mod\ 2)$</p>
<h3 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h3><p><strong>定义7</strong>    设G是一个图，如果$v=1,\epsilon=0$，称G是平凡图；如果$\epsilon=0$，称G是零图。</p>
<h3 id="完全图"><a href="#完全图" class="headerlink" title="完全图"></a>完全图</h3><p><strong>定义8</strong>    设G是一个简单图，如果G中任意两顶点之间均有边相连，则称G为完全图，具有n个顶点的完全图记为$K_n$</p>
<p>$|E(K_n)|=C(n,2)=\frac{n(n-1)}{2}$</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587541489902.png" srcset="/img/loading.gif" lazyload alt="1587541489902" style="zoom: 67%;"></p>
<h3 id="二分图-偶图"><a href="#二分图-偶图" class="headerlink" title="二分图/偶图"></a>二分图/偶图</h3><p><strong>定义9</strong>    设G是一个图，如果存在V(G)的子集$V_1,V_2$使得$V_1\cup V_2=V(G),V_1\cap V_2=\empty$，且$V_1$中任意两点不相邻，$V_2$中任意两点也不相邻，则称G为二分图（偶图），并称$\{V_1,V_2\}$为G的一个二划分</p>
<p>若$V_1$中每一点皆与$V_2$中所有点相邻，则称G为完全二分图，且当$|V_1|=m,|V_2|=n$时，将其记为$K_{m,n}$</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587541657401.png" srcset="/img/loading.gif" lazyload alt="1587541657401" style="zoom:67%;"></p>
<h3 id="正则图"><a href="#正则图" class="headerlink" title="正则图"></a>正则图</h3><p><strong>定义10</strong>    设G是一个图，k是一个常数，若G中每点的度数均为k，则称G为k次正则图</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587541675425.png" srcset="/img/loading.gif" lazyload alt="1587541675425" style="zoom:67%;"></p>
<h3 id="圈图-C-n-、轮图-W-n"><a href="#圈图-C-n-、轮图-W-n" class="headerlink" title="圈图$C_n$、轮图$W_n$"></a>圈图$C_n$、轮图$W_n$</h3><p><img src="/2022/07/07/DiscreteMathNote/1587541733936.png" srcset="/img/loading.gif" lazyload alt="1587541733936" style="zoom:80%;"></p>
<h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><strong>定义11</strong>    设G,H是两个图，如果$V(H)\subseteq V(G),E(H)\subseteq E(G)$，则称H是G的子图，记为$H\subseteq G$</p>
<p>若$H\subseteq G$且$H\not = G$，称H是G的真子图，记为$H\sub G$。</p>
<p>若$H\subseteq G$且$V(H)=V(G)$，称H是G的生成子图</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587541835759.png" srcset="/img/loading.gif" lazyload alt="1587541835759" style="zoom:80%;"></p>
<p><strong>定义12</strong>    设G是一个图，$E_1\subseteq E(G)$，以$E_1$为边集，$E_1$中边的端点全体为顶点集构成的子图，称为由$E_1$导出的G的子图（边导出子图），记为$G(E_1)$</p>
<p>又设$V_1\subseteq V(G)$，以$V_1$为顶点集，端点均在$V_1$中的边的全体为边集构成的子图，称为由$V_1$导出的G的子图（点导出子图），记为$G(V_1)$</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587542024117.png" srcset="/img/loading.gif" lazyload alt="1587542024117" style="zoom:80%;"></p>
<h3 id="补图"><a href="#补图" class="headerlink" title="补图"></a>补图</h3><p><strong>定义13</strong>    设G是具有n个顶点的简单图，从这n个顶点构成的完全图中删去G的所有边，但保留顶点集$V(G)$所得到的图称为G的补图，简称G的补，记为$\sim G$</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587542068485.png" srcset="/img/loading.gif" lazyload alt="1587542068485" style="zoom:80%;"></p>
<h3 id="图的同构"><a href="#图的同构" class="headerlink" title="图的同构"></a>图的同构</h3><p><strong>定义14</strong>    设G,H是两个图，若存在一一映射$\theta:V(G)\to V(H),\psi:E(G)\to E(H)$，使得当且仅当$e=uv$时，$\psi(e)=\theta(u)\theta(v)$，则称G,H是同构的，记为$G\cong H$，而有序对$&lt;\theta,\psi&gt;$称为G与H之间的一个同构映射或同构。</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587542122803.png" srcset="/img/loading.gif" lazyload alt="1587542122803" style="zoom:80%;"></p>
<h3 id="自补图"><a href="#自补图" class="headerlink" title="自补图"></a>自补图</h3><p>$G$与$\sim G$同构</p>
<p><img src="/2022/07/07/DiscreteMathNote/1587541376672.png" srcset="/img/loading.gif" lazyload alt="1587541376672" style="zoom:67%;"></p>
<h2 id="8-2-路与连通"><a href="#8-2-路与连通" class="headerlink" title="8.2 路与连通"></a>8.2 路与连通</h2><p><strong>定义1</strong>    图G的一个非空顶点、边交替序列$W=v_0e_1v_1e_2v_2…e_kv_k$称为一条从$v_0$到$v_k$的路径path，或$(v_0,v_k)$通路，其中$v_{i-1},v_i$是$e_i$的端点$(1\le i\le k)$。称$v_0$为起点，$v_k$为终点，$v_i(1\le i\le k-1)$为内点，k为路长。$v_0,v_k$是连通的</p>
<p>若$W=v_0e_1v_1e_2v_2…e_kv_k$是一条$(v_0,v_k)$路径，逆转后$v_ke_k…v_2e_2v_1e_1v_0$必为$(v_k,v_0)$路径，记为$W^{-1}$</p>
<p>路径W的部分相连项构成的子序列$v_ie_iv_{i+1}…e_jv_j(0\le i\le j\le k)$也必构成一条路径，称为W的节</p>
<p>W可以与另一条路径$W´=v_ke_{k+1}v_{k+1}…e_lv_l$衔接在一起得到一条新路径，记为$WW^´$</p>
<blockquote>
<p>简单图中可简单地用顶点序列表示路径</p>
</blockquote>
<h3 id="路、迹"><a href="#路、迹" class="headerlink" title="路、迹"></a>路、迹</h3><p><strong>定义2</strong>    设$v_0e_1v_1e_2v_2…e_kv_k$为图G的一条路径，若边$e_1,e_2,…,e_k$互不相同，则称该路径为迹（简单通路）；若点序列$v_0,v_1,…,v_k$互不相同，则称该路径为路。</p>
<p><strong>定义3</strong>    设$v_0e_1v_1e_2v_2…e_kv_k$是图G中的一条路径且$k\ge1$，如果$v_0=v_k$，则称该路径为闭路径，否则称为开路径。</p>
<p>闭路径也称为回路</p>
<p>特别地，若$v_0e_1v_1e_2v_2…e_kv_k$是一条迹，$k\ge1$，当$v_0=v_k$时为闭迹，否则为开迹</p>
<p><strong>定义4</strong>    设$v_0e_1v_1e_2v_2…v_{k-1}e_kv_k$是一条闭迹，如果$v_0,v_1,…v_{k-1}$互不相同，则称该闭迹为圈或k圈（顶点和边都不相同的回路），且k为偶数时为偶圈，k为奇数时为奇圈。</p>
<blockquote>
<p>一条路必是一条迹。</p>
<p>自环和两条平行边都自成一圈。</p>
</blockquote>
<p><strong>定理1</strong>    若图G中每个顶点度数至少为2，则G中必含有圈</p>
<h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p><strong>定义5</strong>    设G是一个图，$u,v\in V(G)$，如果存在从u到v的通路，则称u，v是相连的或连通的，若G中任意两点都连通，则称图G是连通的（连通图）</p>
<p>图G中顶点之间的连通关系是一个等价关系</p>
<p>根据该关系可将V(G)划分成一些等价类$V_1,V_2,…V_n$，每个$V_i$导出的子图称为G的一个连通分支</p>
<p>G的连通分支数通常用$\omega(G)$表示</p>
<p><strong>定理1</strong>    连通无向图的每一对不同顶点之间都存在简单通路（边不同的通路/迹）</p>
<p><strong>定理2</strong>    一个图G是二分图$\Leftrightarrow$G中不含奇回路</p>
<p><strong>定理3</strong>    设G是具有n个顶点的简单图，若G有$\epsilon$条边，$\omega$个连通分支，则$n-\omega\le\epsilon\le \frac{1}{2}(n-\omega)(n-\omega+1)$</p>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p><strong>定义6</strong>    设$u,v\in V(G)$，若u，v连通，则称最短$(u,v)$路的长为u，v距离，记为$d(u,v)$</p>
<p>当u，v不连通时，认为u，v的距离是$\infin$</p>
<h3 id="点割集-边割集"><a href="#点割集-边割集" class="headerlink" title="点割集/边割集"></a>点割集/边割集</h3><p><strong>定义7</strong>    设$G=<V(G),E(G)>$是连通图，$\omega(G)=1,S1\sub V(G),$若$\omega(G-S1)&gt;1$，则称$S1$为点割集；$C1\sub E(G)$，若$\omega(G-C1)&gt;1$，则称$C1$为边割集;</V(G),E(G)></p>
<p>特别的，$S1=\{v\},C1=\{e\}$，则称v为割点，e为割边（桥）</p>
<h2 id="8-3-最短路"><a href="#8-3-最短路" class="headerlink" title="8.3 最短路"></a>8.3 最短路</h2><p><strong>定义1</strong>    设G是一个图，若对G中每条边e都规定一个非负实数w(e)，则称G为权图，w(e)称为边e的权。G的边与非负实数的这种对应关系称为权函数。</p>
<p>u，v不相邻时，规定$w(uv)=\infin$</p>
<p><strong>定义2</strong>    设G是一个权图，H是G的子图，H中各边的权之和称为子图H的权，记为$w(H)$，即$w(H)=\sum_{e\in E(H)}w(e)$</p>
<p><strong>定义3</strong>    设G是一个权图，路P的权称为P的长度，两点u,v之间最短路的长度称为两点u,v之间的距离，记为$d(u,v)$</p>
<p><strong>定义4</strong>    设G是一个权图，$u_0\in V(G),S\sub V(G)$，$u_0$到S内各点的所有路中长度最小的，称为$u_0$到S的最短路，其长度称为$u_0$到S的距离，记为$d(u_0,S)$</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><figure class="highlight pascal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pascal"><span class="hljs-comment">//基本思想伪代码</span><br><span class="hljs-comment">//V0=a, vn=z, 其中a是起点，z是目的点</span><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n<br>       L(vi):= inf<br>L(a):=<span class="hljs-number">0</span><br>S:=<span class="hljs-comment">&#123;&#125;</span><br><span class="hljs-keyword">while</span> z不在S中<br>       <span class="hljs-keyword">begin</span><br>           u=不在顶点集S中且L(u)标号最小<br>           S:=S∪<span class="hljs-comment">&#123;u&#125;</span><br>           <span class="hljs-keyword">for</span> 不属于S的任意v<br>               <span class="hljs-keyword">if</span> L(u)+w(u,v)&lt;L(v) <span class="hljs-keyword">then</span> L(v)=L(u)+w(u,v)<br>        <span class="hljs-keyword">end</span><br><br></code></pre></div></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//C++</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m,s,t;<br><span class="hljs-keyword">int</span> e[<span class="hljs-number">2501</span>][<span class="hljs-number">2501</span>];<br><span class="hljs-keyword">int</span> dis[<span class="hljs-number">2501</span>];<br><span class="hljs-keyword">bool</span> b[<span class="hljs-number">2501</span>];<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> inf=<span class="hljs-number">999999</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;<span class="hljs-comment">//n个点 m条边 从s到t最短路</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//初始化 </span><br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(ij) e[i][j]=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">else</span> e[i][j]=inf;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//读入边 </span><br>		<span class="hljs-keyword">int</span> u,v,w;<br>		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;<br>		e[u][v]=<span class="hljs-built_in">min</span>(w,e[u][v]);<br>		e[v][u]=e[u][v];<br>	&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//初始化dis数组</span><br>        <span class="hljs-keyword">if</span>(is) dis[s]=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">else</span> dis[s]=inf;<br>    &#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<span class="hljs-comment">//边松弛 </span><br>		<span class="hljs-keyword">int</span> key=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//找出该轮中最小编号</span><br>			<span class="hljs-keyword">int</span> min=inf;<br>			<span class="hljs-keyword">if</span>(dis[i]&lt;min &amp;&amp; !b[i])&#123;<br>				min=dis[i];<br>				key=i;<br>			&#125;<br>		&#125;<br>		b[key]=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//更新距离</span><br>			dis[i]=<span class="hljs-built_in">min</span>(dis[key]+e[key][i],dis[i]);<br>		&#125;<br>	&#125;<br>    <br>	cout&lt;&lt;dis[t];<br>	<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></div></td></tr></table></figure>
<h2 id="8-4-有向图"><a href="#8-4-有向图" class="headerlink" title="8.4 有向图"></a>8.4 有向图</h2><ul>
<li><p>设V是一个非空集合，A是一个由V中元素的有序对构成的多重集，有序对$D=<V,A>$称为一个有向图，其中，V称为顶点集，其元素称为顶点或点；A称为弧集，其元素称为弧。</V,A></p>
</li>
<li><p>若$a=<u,v>$，则称a从u连接到v，且称u，v与a彼此相关联；称u是a的尾或起点，v是a的头或终点，且将u，v统称为a的端点</u,v></p>
<p>子有向图，真子有向图，边导出子有向图，点导出子有向图</p>
</li>
<li><p>顶点的出度$d^+_D(v)$，入度$d^-_D(v)$</p>
<p><strong>定理1</strong>    设D是有向图，则D中顶点的入度之和与出度之和均为$\epsilon$（边数），即$\sum_{v\in V}d^-(v)=\sum_{v\in V}d^+(v)=\epsilon$</p>
</li>
<li><p>有向路径：一个非空有限点、弧交替序列$W=v_0a_1v_1a_2…a_kv_k$；也常用他的顶点序列$v_0v_1…v_k$表示</p>
<p>有向迹，有向路，有向回路，有向圈</p>
</li>
<li><p>存在有向$(u,v)$路，则称v是从u可达的</p>
</li>
<li><p>若u，v互相可达，则称u，v是双向连通的</p>
</li>
<li><p>若对D中任何两顶点，至少有一顶点可从另一顶点可达，则称D是单向连通图</p>
</li>
<li><p>若D中任何两顶点都是双向连通的，则称D是双向连通图或强连通图</p>
<p>双向连通关系是D的顶点集V上的一个等价关系</p>
<p>双向分支或强连通分支</p>
<p>D强连通$\Leftrightarrow$D恰有一个强连通分支</p>
</li>
<li><p>若有向图D中每两个顶点之间恰有一条弧，则称D为竞赛图</p>
<p>D是竞赛图$\Leftrightarrow$D是完全图的定向图</p>
</li>
</ul>
<h2 id="8-5-图的矩阵表示"><a href="#8-5-图的矩阵表示" class="headerlink" title="8.5 图的矩阵表示"></a>8.5 图的矩阵表示</h2><h3 id="无向图的关联矩阵"><a href="#无向图的关联矩阵" class="headerlink" title="无向图的关联矩阵"></a>无向图的关联矩阵</h3><p>设G是无自环的图，$n\times m$矩阵$A(G)=(a_{ij})_{n\times m}$称为G的关联矩阵，其中$a_{ij}=\begin{cases}1,&amp;v_i关联于e_j\\0,&amp;否则\end{cases}$</p>
<p>n为G顶点个数，m为G边的条数</p>
<ul>
<li>性质<ul>
<li>G中每一边关联两个顶点，所以A(G)中每一列恰好有两个1</li>
<li>每一行中的1的个数是对应顶点的度数</li>
<li>平行边对应的列全同</li>
<li>若G有两个分支$G_1,G_2$，则适当调整顶点及边的顺序，可使关联矩阵成块对角形</li>
</ul>
</li>
</ul>
<h3 id="有向图的关联矩阵"><a href="#有向图的关联矩阵" class="headerlink" title="有向图的关联矩阵"></a>有向图的关联矩阵</h3><p>$a_{ij}=\begin{cases}1,&amp;v_i为e_j的起点\\0,&amp;v_i与e_j不关联\-1,&amp;v_i为e_j的终点\end{cases}$</p>
<ul>
<li>性质<ul>
<li>$\sum^n_{i=1}a_{ij}=0,j=1,2,…,m$</li>
<li>每行中1的个数是该点的出度，-1的个数是该点的入度</li>
</ul>
</li>
</ul>
<h3 id="无向图的邻接矩阵"><a href="#无向图的邻接矩阵" class="headerlink" title="无向图的邻接矩阵"></a>无向图的邻接矩阵</h3><p>设G是无多重边的图，$n\times n$矩阵$X(G)=(x_{ij})_{n\times n}$称为图G的邻接矩阵，$x_{ij}=\begin{cases}1,&amp;v_iv_j相邻\\0,&amp;否则\end{cases}$</p>
<p>X(G)是对称矩阵</p>
<p>若G是有多重边或自环的图，邻接矩阵$X(G)$，$x_{ii}=1$表示有自环，$x_{ij}&gt;1$表示多重边</p>
<p><strong>定理1</strong>    <em>（无向图的通路条数的计算）</em>设G是一个简单图，X是G的邻接矩阵，令$X^L=(x_{ij}^L)$，则$x_{ij}^L$等于顶点$v_i,v_j$之间长度为L的通路数目</p>
<h3 id="有向图的邻接矩阵"><a href="#有向图的邻接矩阵" class="headerlink" title="有向图的邻接矩阵"></a>有向图的邻接矩阵</h3><p>$x_{ij}=1$表示从顶点$v_i$到顶点$v_j$存在有向边</p>
<h3 id="路径矩阵"><a href="#路径矩阵" class="headerlink" title="路径矩阵"></a>路径矩阵</h3><p>设G是一个无平行边的图，$P(G)=(p_{ij})$称为G的路径矩阵，其中$p_{ij}=\begin{cases}1,&amp;存在(v_i,v_j)路\\0,&amp;否则\end{cases}$</p>
<p>G是连通图$\Leftrightarrow$P(G)中元素全为1</p>
<h1 id="§9-Euler图与Hamilton图"><a href="#§9-Euler图与Hamilton图" class="headerlink" title="§9 Euler图与Hamilton图"></a>§9 Euler图与Hamilton图</h1><h2 id="Euler图"><a href="#Euler图" class="headerlink" title="Euler图"></a>Euler图</h2><p><strong>定义1</strong>    设G是一个图，G中包含所有边的迹（即每条边恰好出现一次的路径）称为Euler迹，闭的Euler迹称为Euler闭迹或Euler回路，具有Euler回路的图称为Euler图，开的Euler迹称为Euler开迹，具有Euler开迹的图称为半Euler图。</p>
<ul>
<li><p><strong>定理1</strong>    设G是连通图，则G是Euler图当且仅当G的所有顶点均是偶顶点</p>
</li>
<li><p><strong>定理2</strong>    设G是连通图，则G是半Euler图当且仅当G中恰有两个奇顶点</p>
</li>
<li><p><strong>定理3</strong>    设G是连通图，则G是Euler图当且仅当G是若干条边不相重的迹（圈）的并</p>
</li>
</ul>
<p><strong>定义2</strong>    设D是一个有向图，D中包含所有弧的有向迹称为Euler有向迹，闭的Euler有向迹称为Euler有向闭迹或Euler有向回路，具有Euler有向回路的图称为Euler有向图，开的Euler有向迹称为Euler有向开迹，具有Euler有向开迹的图称为半Euler有向图</p>
<ul>
<li>一个Euler有向图，如果没有孤立点，则必是强连通的</li>
</ul>
<p><strong>定义3</strong>    如果有向图D中每点的入度和出度都相等，$d^-(v)=d^+(v)$，则称D是平衡的，如果存在$k\in N$，使得D中每点的入度，出度均为k，$d^-(v)=d^+(v)=k$，则称D是一致平衡的</p>
<ul>
<li><strong>定理4</strong>    设D是连通有向图，则G是Euler有向图当且仅当G是一致平衡的</li>
<li><strong>定理5</strong>    设D是连通有向图，则G是半Euler有向图当且仅当G中恰有两个奇顶点，其中一个入度比出度大1，另一个出度比入度大1，而其他顶点的出度与入度相等</li>
</ul>
<h4 id="欧拉通（或回）路的构造算法"><a href="#欧拉通（或回）路的构造算法" class="headerlink" title="欧拉通（或回）路的构造算法"></a>欧拉通（或回）路的构造算法</h4><figure class="highlight pascal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pascal"><span class="hljs-comment">//Fleury算法</span><br>任取G中度数为奇度数的顶点v0,令P0=v0´<br>假设Pi=v0e1v1e2...eivi已经行遍<br>	E(G)-<span class="hljs-comment">&#123;e1,e2,...,ei&#125;</span>中选取边ei+<span class="hljs-number">1</span><br>	(<span class="hljs-number">1</span>)ei+<span class="hljs-number">1</span>与vi相关联<br>	(<span class="hljs-number">2</span>)除非无别的边可供行遍，否则 边ei+<span class="hljs-number">1</span>不应该是Gi=G-<span class="hljs-comment">&#123;e1,e2,...,ei&#125;</span>的割边<br>	(<span class="hljs-number">3</span>)当<span class="hljs-number">2</span>不能再进行时算法停止<br></code></pre></div></td></tr></table></figure>
<h2 id="Hamilton图"><a href="#Hamilton图" class="headerlink" title="Hamilton图"></a>Hamilton图</h2><p><strong>定义1</strong>    设G是一个图，G中包含所有顶点的圈（即每个顶点恰好出现一次的回路）称为Hamilton圈，具有Hamilton圈的图称为Hamilton图；G中包含所有顶点的通路称为Hamilton路径（通路），具有Hamilton路径的图称为半Hamilton图</p>
<ul>
<li><p>每个哈密顿图都一定是连通的且每个顶点的度均大于等于2</p>
</li>
<li><p>设G是有n个顶点的连通图，则G的哈密顿通路是长度为n-1的基本通路，哈密顿回路是长度为n的回路</p>
</li>
<li><p>如果存在度为1的顶点（悬挂点），那么G没有哈密顿回路</p>
</li>
<li><p>设v是G中度为2的顶点，若G中有哈密顿回路，则该回路必经过以v为端点的那两条边</p>
</li>
<li><p>哈密顿图中的哈密顿回路并不唯一</p>
</li>
<li><p>设v是G中度大于2的顶点，若G有哈密顿回路，则该回路只使用以v为端点的某两条边</p>
</li>
<li><p>如果图中必须在哈密顿回路中出现的边（如2度顶点关联的边）构成了一回路，但该回路未能经过G的所有顶点，则G没有哈密顿回路</p>
</li>
<li><p><strong>定理1（必要）</strong>    设G是Hamilton图，则对于顶点集V的任一非空真子集V1，均有$\omega (G-V1)\le |V1|$</p>
</li>
<li><p><strong>定理2（狄拉克定理 充分）</strong>    设G是简单图，且$n\ge3,\delta (G)\ge \frac{n}{2}$，则G是Hamilton图  </p>
</li>
<li><p><strong>奥尔定理（充分）</strong>    设图$G(m,n),n\ge3$，若G中任意两个不相邻的顶点u和v，均有$deg(u)+deg(v)\ge n$，则G有哈密顿回路</p>
</li>
<li><p><strong>定理3（充要）</strong>    简单图G是Hamilton图当且仅当闭图$G_c$是Hamilton图</p>
<blockquote>
<p>闭图：G是具有n个顶点的图，对$deg(u)+deg(v)\ge n$的每一对顶点u和v，都有u和v相邻接</p>
</blockquote>
<ul>
<li><strong>推论1</strong>    若C(G)是完全图，则G是Hamilton图</li>
<li><strong>推论2</strong>    若G中任意不相邻顶点u，v均满足$deg(u)+deg(v)\ge n$，则G是Hamilton图</li>
</ul>
</li>
</ul>
<p><strong>定义2</strong>    设D是有向图，D中包含所有顶点的有向圈称为Hamilton有向圈，具有Hamilton圈的图称为Hamilton有向图；D中包含所有顶点的有向路称为Hamilton有向路，具有Hamilton有向路的图称为半Hamilton有向图</p>
<ul>
<li><p><strong>定理4</strong>    竞赛图必是半Hamilton有向图</p>
</li>
<li><p><strong>定理5</strong>    强连通的竞赛图必是Hamilton有向图</p>
</li>
</ul>
<h1 id="§10-树"><a href="#§10-树" class="headerlink" title="§10 树"></a>§10 树</h1><h2 id="10-1-树的概念"><a href="#10-1-树的概念" class="headerlink" title="10.1 树的概念"></a>10.1 树的概念</h2><p><strong>定义1</strong>    连通无回路的图称为树，树中度为1的点称为树叶，度大于1的点称为分枝点或内点，每个连通分支均为树的图称为森林</p>
<ul>
<li><p><strong>定理1</strong>    设图T是有n个顶点、$\epsilon$条边的非平凡图，则下列各条等价</p>
<ul>
<li><p>T是树</p>
</li>
<li><p>T中无回路，且$\epsilon =n-1$</p>
</li>
<li>T连通，且$\epsilon =n-1$</li>
<li>T中无回路，且在T的任意两个不相邻点之间添加一边恰得一条回路</li>
<li>T连通，删去任一边则不连通</li>
<li>T得任意两个不同顶点之间恰有一条路</li>
</ul>
</li>
<li><strong>定理2</strong>    任意一棵非平凡书T中，至少有两片树叶</li>
</ul>
<h2 id="10-2-生成树"><a href="#10-2-生成树" class="headerlink" title="10.2 生成树"></a>10.2 生成树</h2><p><strong>定义1</strong>    若图G的<strong>生成子图</strong>T是树，则称T为G的生成树</p>
<p><strong>求连通图的生成树：</strong>破圈法、避圈法</p>
<p><strong>定理1</strong>    G是连通图当且仅当G有生成树</p>
<h3 id="求连通有权图的最小生成树"><a href="#求连通有权图的最小生成树" class="headerlink" title="求连通有权图的最小生成树"></a>求连通有权图的最小生成树</h3><h4 id="Kruskal算法（避圈法）"><a href="#Kruskal算法（避圈法）" class="headerlink" title="Kruskal算法（避圈法）"></a>Kruskal算法（避圈法）</h4><p>选择图中权最小的一条边，相继添加不与已经选择的边形成圈的权最小的边，挑选n-1条边为止（其中n为结点的个数）</p>
<figure class="highlight pascal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pascal">(<span class="hljs-number">1</span>) 选取G的一边e1,使w(e1)=min<span class="hljs-comment">&#123;w(e)|e∈E&#125;</span>,令E1=<span class="hljs-comment">&#123;e1&#125;</span><br>(<span class="hljs-number">2</span>) 若已选出Ei=<span class="hljs-comment">&#123;e1,...,ei&#125;</span>,那么,从E-Ei中选取一边e(i+<span class="hljs-number">1</span>),使:<br>	(a)Ei∪e(i+<span class="hljs-number">1</span>)的导出子图中不含回路；<br>    (b)w(e(i+<span class="hljs-number">1</span>))=min<span class="hljs-comment">&#123;w(e)|e∈E-Ei,Ei∪&#123;e&#125;</span>的导出子图无回路&#125;    <br>(<span class="hljs-number">3</span>) 若e(i+<span class="hljs-number">1</span>)存在,令E(i+<span class="hljs-number">1</span>)=Ei∪e(i+<span class="hljs-number">1</span>),i+<span class="hljs-number">1</span>→i,转(<span class="hljs-number">2</span>),<br>	若e(i+<span class="hljs-number">1</span>)不存在,则停止。<br></code></pre></div></td></tr></table></figure>
<p><strong>定理2</strong>    Kruskal算法的得到的图T*是最小生成树</p>
<h4 id="Prim算法（逐步短接）"><a href="#Prim算法（逐步短接）" class="headerlink" title="Prim算法（逐步短接）"></a>Prim算法（逐步短接）</h4><p>选择图中与V(T)邻接且权最小的一条边，将该边加入到T中且不形成回路，相继选择n-1条边为止（其中n为结点的个数）</p>
<figure class="highlight pascal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pascal">(<span class="hljs-number">1</span>) 选取G的一边e1,使w(e1)=min<span class="hljs-comment">&#123;w(e)|e∈E&#125;</span>,令T(E)=<span class="hljs-comment">&#123;e1&#125;</span><br>(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n-<span class="hljs-number">2</span><br>	<span class="hljs-keyword">begin</span><br>	e=权重最小且邻接于T(V)，加入T中不形成回路<br>    T(E)=T(E)+<span class="hljs-comment">&#123;e&#125;</span><br>    <span class="hljs-keyword">end</span><br></code></pre></div></td></tr></table></figure>
<h4 id="破圈法"><a href="#破圈法" class="headerlink" title="破圈法"></a>破圈法</h4><figure class="highlight pascal"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pascal">将赋权简单连通无向图G=&lt;V,E&gt;的边排序,开始时A:=E<br>(<span class="hljs-number">1</span>) 若A无回路，则A是最小生成树，算法结束；否则转步骤(<span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span>) 在A中任取的一条回路C中取有最大权的边e，置A:=A-e后转步骤(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>
<h2 id="10-3-有向树-有根树-有序树-m叉树"><a href="#10-3-有向树-有根树-有序树-m叉树" class="headerlink" title="10.3 有向树/有根树/有序树/m叉树"></a>10.3 有向树/有根树/有序树/m叉树</h2><p><strong>定义1</strong>    设D是一个有向图，如果在不考虑弧的方向时D是一棵树（即D的底图是一棵树），则D为一棵有向树</p>
<p><strong>定义2</strong>    若一棵有向树中恰有一个顶点的入度为0，其余所有顶点的入度均为1，则称该有向树为有根树（或树形图），入度为0的顶点称为根</p>
<ul>
<li><strong>定理1</strong>    设T是一根有根树，r是T的根，则r到其余每个顶点恰有一条有向路</li>
</ul>
<p><strong>定义3</strong>    儿子，父亲，兄弟，子孙，祖先；从根到某一顶点的路长称为该顶点的路长或层数，从根到树叶的最大层数，称为有根树的高</p>
<p><strong>定义4</strong>    设u是有根树T的一个顶点，$V_u$是u及其子孙构成的顶点集，$V_u$的导出子图称为T的以u为根的子树</p>
<p><strong>定义5</strong>    在有根树中每个分支点发出的弧从左到右依次标注（或左中右），则称该树为有序树</p>
<p><strong>定义6</strong>    在有序树中，如果每个分支v都满足$d^+(v)\le m$，则称该有序树为m叉树，如果每个分支点v都满足$d^+(v)=m$，称该有序树为正则m叉树</p>
<ul>
<li><p>一类重要的m叉树是二叉树和正则二叉树</p>
</li>
<li><p><strong>定理2</strong>     在正则m叉树中，分枝点数i与树叶数L满足：$(m-1)i=L-1$</p>
<blockquote>
<p>顶点总数 $mi+1=i+L$ </p>
</blockquote>
</li>
<li><p><strong>定理3</strong>     设T是正则m叉树，I表示分枝点的路长总和，L表示树叶的路长总和，i是分枝点数，则$L=(m-1)I+mi$</p>
</li>
</ul>
<h1 id="§11-平面图-图的着色"><a href="#§11-平面图-图的着色" class="headerlink" title="§11 平面图 图的着色"></a>§11 平面图 图的着色</h1><h2 id="11-1-平面图"><a href="#11-1-平面图" class="headerlink" title="11.1 平面图"></a>11.1 平面图</h2><p><strong>定义1</strong>    如果一个图能画在平面上，使得它的边仅在端点相交，则称这个图为平面图，或说它是可平面嵌入的，平面图G的这样一种画法，称为G的一个平面嵌入</p>
<p>平面图G的平面嵌入称为平图</p>
<p><strong>定义2</strong>    一条连续的、自身不相交的封闭曲线称为Jordon曲线</p>
<p><strong>引理（Jordon定理）</strong>    设J是一条Jordon曲线，任何连接J的内点与外点的曲线必与J相交</p>
<p><strong>定义3</strong>    设G是一个平图，则G把平面划分成若干个连通区域，每个连通区域得闭包称为G的一个面，其中恰有一个无界的面，称为外部面。</p>
<p>每个面所关联的边，称为面的次数$Deg(R)$</p>
<ul>
<li><p><strong>定理1</strong>    G=(V,E)是有m条边的平面图，则$\sum deg(R)=2m,|E|=m$</p>
</li>
<li><p><strong>定理2</strong>     若G是连通平面图，则 $m-n+2=r(v-\epsilon +f=2)$，其中r是G的面数，这个公式称为Euler公式</p>
<p><strong>推论1</strong>    给定平面连通图G，则G的所有平面嵌入有相同的面数。</p>
<p><strong>推论2</strong>    若G是简单平面图，$n\ge3$，则$m\le 3n-6$</p>
<p><strong>推论3</strong>    若平图G的每条面由至少四条边围成，则$m\le 2n-4$</p>
</li>
<li><p><strong>库拉托夫斯基定理</strong>     一个图是非平面图当且仅当含有同胚于$K_{3,3}$或$K_5$的子图</p>
<p><strong>推论4</strong>    $K_{3,3}$和$K_5$是非平面图</p>
<ul>
<li><strong>定理3</strong>    在平面简单图G中，至少存在一个顶点$v_0$，使$d(v_0)\le 5$</li>
</ul>
</li>
</ul>
<h2 id="11-2-顶点着色"><a href="#11-2-顶点着色" class="headerlink" title="11.2 顶点着色"></a>11.2 顶点着色</h2><p><strong>定义</strong>    设G是一个图，对G的每个顶点着色，使得没有两个相邻的顶点着上相同的颜色，这种着色称为图的正常着色。</p>
<p>若图G的顶点可用k种颜色正常着色，称 G为k可着色的，使G是k可着色的数k的最小值称为G的色数，记为$\chi(G)$，如果$\chi(G)=k$，则称G是k色的</p>
<ul>
<li><strong>定理1</strong></li>
<li><p>对于完全图$K_n$，有$\chi(K_n)=n,\chi(\sim K_n)=1$</p>
</li>
<li><p>对于n个顶点构成的圈$C_n$，当n是偶数时，$\chi(C_n)=2$，当n是奇数时，$\chi(C_n)=3$</p>
</li>
<li><p>对于非平凡树T，有$\chi(T)=2$</p>
</li>
<li><p>G是二分图，当且仅当$\chi(G)=2$</p>
</li>
<li><strong>定理2</strong>    对于任意连通简单图G，有$\chi(G)\le\Delta(G)+1$</li>
<li><strong>五色定理（希伍德定理）</strong>    任何简单平面图都是5-可着色的</li>
</ul>
<h3 id="顶点着色算法"><a href="#顶点着色算法" class="headerlink" title="顶点着色算法"></a><strong>顶点着色算法</strong></h3><p><strong>Welch Powell(韦尔奇-鲍威)algorithm</strong></p>
<p>1) 将图 G 中的结点按度数递减的次序进行排列(相同度数的结点的排列随意)。 </p>
<p>2) 用第一种颜色，对第一点着色，并按排列次序对与前面结点不相邻的每一点着同样的颜色。 </p>
<p>3) 用第二种颜色对尚未着色的点重复第2 步, 直到所有的点都着上颜色为止。 </p>
<h2 id="11-3-对偶图"><a href="#11-3-对偶图" class="headerlink" title="11.3 对偶图"></a>11.3 对偶图</h2><p><strong>定义</strong>    满足下列条件的图$G^*$称为平面图G的对偶图：</p>
<ul>
<li>G中每个确定的面$r_i$内设置一个顶点$v_i^*$</li>
<li>若面$r_i$和$r_j$的共同边界$e_k$，则有一条边$e_k^<em>=(v_i^</em>,v_j^<em>)\in E(G^</em>)$，并且与$e_k$相交一次</li>
<li>若$e_k$处于面$r_i$之内，则$v_i^<em>$有一自环$e_k^</em>$与$e_k$相交一次</li>
</ul>
<p><img src="/2022/07/07/DiscreteMathNote/1589963664205.png" srcset="/img/loading.gif" lazyload alt="1589963664205" style="zoom:60%;"></p>
<p><strong>对偶图的规律：</strong></p>
<ul>
<li>$G^*$为平面图</li>
<li>若边e为G中的环，则它对应的边$e^<em>$为$G^</em>$的割边；若边e为G中的割边，则它对应的边$e^<em>$为$G^</em>$的环</li>
<li>两个同构图的对偶图不一定是同构的</li>
</ul>
<p><strong>对偶图的性质：</strong></p>
<ul>
<li><p><strong>性质1</strong>    若G是平面图，则G存在唯一的对偶图$G^*$</p>
</li>
<li><p><strong>性质2</strong>    若G是平面连通图，则$(G^<em>)^</em>=G$</p>
</li>
<li><p><strong>性质3</strong>    若G是平面图，则$G^*$是连通图</p>
</li>
</ul>
<p><strong>定理1</strong>    平面连通图G与其对偶图$G^*$的顶点、边和面之间存在如下关系：</p>
<ul>
<li>$m=m^*$</li>
<li>$r=n^*$</li>
<li>$n=r^*$</li>
</ul>
<p><strong>定理2</strong>    G有对偶图的充要条件是G为平面图</p>
<h2 id="11-4-面着色"><a href="#11-4-面着色" class="headerlink" title="11.4 面着色"></a>11.4 面着色</h2><p><strong>定义1</strong>    设e是图G的一条边，如果$\omega(G-e)&gt;\omega(G)$，则称e是G的割边</p>
<p><strong>定义2</strong>    一个没有割边的连通平面图，称为地图</p>
<p><strong>利用对偶原理，对地图的着色研究就变成了点着色的研究</strong></p>
<h2 id="11-5-边着色"><a href="#11-5-边着色" class="headerlink" title="11.5 边着色"></a>11.5 边着色</h2><p><strong>定义</strong>    若图G的任何两条相邻接的边着有不同的颜色，称G是可边着色或正常边着色。图G的正常边着色所需的最少颜色数目称为G的边色数，记作$\chi´(G)=k$，称G是可以k-边着色的。</p>
<p><strong>定义</strong>    若图L(G)中的顶点与G的边一一对应，L(G)中的两个顶点是邻接的当且仅当对应的边在G中是邻接的，则称L(G)是图G的线图</p>
<p><strong>图G的边着色问题可以转化为G的线图L(G)的点着色问题</strong></p>
<p><strong>定理1</strong>    设G是简单图，则$\Delta(G)\le\chi´(G)\le\Delta(G)+1$</p>
<p><strong>定理2</strong>    若G(n,m)​是二分图，则$\chi´(G)=\Delta(G)$</p>
<p><strong>定理3</strong>    $n&gt;1$，当n为奇数时，$\chi´(K_n)=n$；当n为偶数时，$\chi´(K_n)=n-1$</p>
<h1 id="§12-网络-匹配-独立集"><a href="#§12-网络-匹配-独立集" class="headerlink" title="§12 网络 匹配 独立集"></a>§12 网络 匹配 独立集</h1><h2 id="12-1-网络模型"><a href="#12-1-网络模型" class="headerlink" title="12.1 网络模型"></a>12.1 网络模型</h2><p><strong>定义</strong>    $N=<V,U>$为带权有向图，存在$X,Y\sub V$，满足$X∩Y=\empty$，X的所有顶点入度为0，Y中所有顶点的出度为0，则称N为网络</V,U></p>
<p>X中的顶点称为源点，Y中的顶点称为聚点（汇点），其他顶点称为中间点，N上的权值函数称为容量函数，一条弧$a=<i,j>$的权值称为它的容量，记为$c(a)$或$c(<i,j>)$或$c(i,j)$</i,j></i,j></p>
<p><strong>定义</strong>    f为网络N=<V,U>的弧集上U的实数值函数，如果函数f满足：(1)容量约束条件，(2)守恒条件，则称函数为网格N的一个容许流。</V,U></p>
<h2 id="12-2-二分图的匹配与最大匹配"><a href="#12-2-二分图的匹配与最大匹配" class="headerlink" title="12.2 二分图的匹配与最大匹配"></a>12.2 二分图的匹配与最大匹配</h2><p><strong>定义</strong>    二分图G的边集E的子集M，如果M的任意二边都没有公共端点，称M为G的一个匹配，G中边数最多的匹配称为最大匹配（不唯一），含有G的所有顶点的匹配称为完美匹配（必为最大匹配，不唯一）</p>
<h2 id="12-3-独立集"><a href="#12-3-独立集" class="headerlink" title="12.3 独立集"></a>12.3 独立集</h2><p><strong>定义</strong>    简单无向图G=<V,E>，$S\sub V$，如果S中任意两个顶点在G中不相邻接，称S为G独立集，二分图的独立集是V1或V2</V,E></p>
<h1 id="§13-组合数学"><a href="#§13-组合数学" class="headerlink" title="§13 组合数学"></a>§13 组合数学</h1><h2 id="13-1-基本计数原理"><a href="#13-1-基本计数原理" class="headerlink" title="13.1 基本计数原理"></a>13.1 基本计数原理</h2><h3 id="乘法规则"><a href="#乘法规则" class="headerlink" title="乘法规则"></a>乘法规则</h3><p>假设一个过程可以分解成两个任务的序列。如果有$n_1$方法来完成第一个任务，有$n_2$方法来完成第一个任务后的第二个任务，那么就有$n_1\times n_2$方法来完成这个过程。</p>
<h3 id="加法规则"><a href="#加法规则" class="headerlink" title="加法规则"></a>加法规则</h3><p>如果第一个任务可以用$n_1$方法完成，第二个任务可以用$n_2$方法完成，如果这些任务不能同时完成，那么就有$n_1+n_2$方法来完成这些任务。</p>
<h2 id="13-2-鸽巢原理"><a href="#13-2-鸽巢原理" class="headerlink" title="13.2 鸽巢原理"></a>13.2 鸽巢原理</h2><h3 id="13-2-1-鸽巢原理"><a href="#13-2-1-鸽巢原理" class="headerlink" title="13.2.1 鸽巢原理"></a>13.2.1 鸽巢原理</h3><p>把k+1个物体放入k个箱子，至少有一个箱子中至少有两个物体</p>
<h3 id="13-2-2-拉姆齐数"><a href="#13-2-2-拉姆齐数" class="headerlink" title="13.2.2 拉姆齐数"></a>13.2.2 拉姆齐数</h3><p>假设p,q为正整数，$p,q\ge2$，则存在最小正整数$R(p,q)$，使得$n\ge R(p,q)$时，或者有p人是彼此相识，或者有q人彼此不认识，称$R(p,q)$为Ramsey数（拉姆齐数）</p>
<h2 id="13-3-排列组合"><a href="#13-3-排列组合" class="headerlink" title="13.3 排列组合"></a>13.3 排列组合</h2><h3 id="13-3-1-排列"><a href="#13-3-1-排列" class="headerlink" title="13.3.1 排列"></a>13.3.1 排列</h3><h4 id="不允许重复选取的排列"><a href="#不允许重复选取的排列" class="headerlink" title="不允许重复选取的排列"></a>不允许重复选取的排列</h4><p>$P(n,r)=\begin{cases}1&amp;n\ge r=0\\0&amp;n&lt;r\end{cases}$</p>
<p>$P(n,r)=n(n-1)(n-2)…(n-r+1)=\frac{n!}{(n-r)!}$</p>
<h4 id="允许重复选取的排列"><a href="#允许重复选取的排列" class="headerlink" title="允许重复选取的排列"></a>允许重复选取的排列</h4><p>$n^r$</p>
<h3 id="13-3-2-组合"><a href="#13-3-2-组合" class="headerlink" title="13.3.2 组合"></a>13.3.2 组合</h3><h4 id="不允许重复的组合"><a href="#不允许重复的组合" class="headerlink" title="不允许重复的组合"></a>不允许重复的组合</h4><p>$C(n,r)=\begin{cases}1&amp;n\ge r=0\\0&amp;n&lt;r\end{cases}$</p>
<p>$C(n,r)=\begin{bmatrix}n\\r\end{bmatrix}=\frac{P(n,r)}{r!}=\frac{n!}{r!(n-r)!}$</p>
<h4 id="允许重复的组合"><a href="#允许重复的组合" class="headerlink" title="允许重复的组合"></a>允许重复的组合</h4><p>$C(n+r-1,r)$</p>
<p>$C(n+r-1,r)=C(n+r-1,n-1)$</p>
<h2 id="13-4-二项式"><a href="#13-4-二项式" class="headerlink" title="13.4 二项式"></a>13.4 二项式</h2><h3 id="13-4-1-二项式定理"><a href="#13-4-1-二项式定理" class="headerlink" title="13.4.1 二项式定理"></a>13.4.1 二项式定理</h3><p>$(x+y)^n=\sum_{k=0}^n\begin{bmatrix}n\\r\end{bmatrix}x^{n-k}y^k=\begin{bmatrix}n\\0\end{bmatrix}x^n+\begin{bmatrix}n\\1\end{bmatrix}x^{n-1}y+…\begin{bmatrix}n\\n-1\end{bmatrix}xy^{n-1}+\begin{bmatrix}n\\n\end{bmatrix}y^n$</p>
<p>$C(n,r)=C(n,n-r)$</p>
<h3 id="13-4-2-Pascal恒等式"><a href="#13-4-2-Pascal恒等式" class="headerlink" title="13.4.2 Pascal恒等式"></a>13.4.2 Pascal恒等式</h3><p>$\begin{bmatrix}n+1\\k\end{bmatrix}=\begin{bmatrix}n\\k-1\end{bmatrix}+\begin{bmatrix}n\\k\end{bmatrix}$</p>
<h2 id="13-5-排列和组合"><a href="#13-5-排列和组合" class="headerlink" title="13.5 排列和组合"></a>13.5 排列和组合</h2><p><img src="/2022/07/07/DiscreteMathNote/image-20200525151642672.png" srcset="/img/loading.gif" lazyload alt="image-20200525151642672" style="zoom: 50%;"></p>
<h1 id="§15-命题逻辑"><a href="#§15-命题逻辑" class="headerlink" title="§15 命题逻辑"></a>§15 命题逻辑</h1><h2 id="15-1-命题与真值"><a href="#15-1-命题与真值" class="headerlink" title="15.1 命题与真值"></a>15.1 命题与真值</h2><p>能判定真假的陈述句称作命题</p>
<p>陈述句为真或为假的这种性质称为命题的真值</p>
<ul>
<li>语法上命题必须是陈述句</li>
<li>命题具有唯一的真值</li>
<li>真值符号化：1或T为真，0或F为假</li>
<li>命题符号化：大写拉丁字母或带有下标的大写字母</li>
</ul>
<h2 id="15-2-命题联结词"><a href="#15-2-命题联结词" class="headerlink" title="15.2 命题联结词"></a>15.2 命题联结词</h2><p>简单命题或原子命题：不能再分解为更简单的命题</p>
<p>复合命题：若干简单命题通过命题联结词构成的新命题</p>
<p>命题联结词又称逻辑运算符</p>
<h3 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h3><p>设P是一个命题，利用$\neg$和P组成的命题称为命题P的否命题，记作$\neg P$</p>
<p>命题$\neg P$取值为真，当且仅当命题P为假</p>
<h3 id="合取"><a href="#合取" class="headerlink" title="合取"></a>合取</h3><p>设P和Q是两个命题，由P和Q利用二元连接词$\land$组成的复合命题，记作$P\land Q$</p>
<p>当且仅当命题P和Q均为真，$P\land Q$取值为真</p>
<h3 id="析取"><a href="#析取" class="headerlink" title="析取"></a>析取</h3><p>设P和Q是两个命题，由P和Q利用二元连接词$\lor$组成的复合命题，记作$P\lor Q$</p>
<p>当且仅当命题P和Q至少有一个取值为真时，$P\lor Q$取值为真</p>
<h3 id="蕴涵"><a href="#蕴涵" class="headerlink" title="蕴涵"></a>蕴涵</h3><p>设P和Q是两个命题，由P和Q利用二元连接词$\to$组成的复合命题，记作$P\to Q$</p>
<p>当前件P为真，后件Q为假时，命题$P\to Q$取值为假，否则为真</p>
<h3 id="等价"><a href="#等价" class="headerlink" title="等价"></a>等价</h3><p>设P和Q是两个命题，由P和Q利用二元连接词$\leftrightarrow$组成的复合命题，记作$P\leftrightarrow Q$</p>
<p>当且仅当P和Q取值相同时，命题$P\leftrightarrow Q$取值为真</p>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>对于排斥或，在数理逻辑中用$\oplus$表示，称为异或</p>
<p>当且仅当命题P和Q的真值相异时，$P\oplus Q$取值为真</p>
<h2 id="15-3-合式公式和真值表"><a href="#15-3-合式公式和真值表" class="headerlink" title="15.3 合式公式和真值表"></a>15.3 合式公式和真值表</h2><p>合式公式（命题公式）的递归定义：</p>
<p>（1）0，1和命题变元是命题公式</p>
<p>（2）如果P和Q是命题公式，则$\neg P,(P\land Q),(P\lor Q),(P\to Q),(P\leftrightarrow Q)$也是命题公式</p>
<p>（3）只有有限次地利用上述1，2而产生的符号串才是命题公式</p>
<p>设$B:(0,1)^n\to \{0,1\},(n\ge1)$，即此函数是以n个命题变元为自变量，其定义域和值域都是由0和1两值构成，则称B为一个n元真值函数</p>
<p>公式F在其全部可能的真值指派所取的真值的表，称为真值表</p>
<p>一命题公式F，如果对于它所含的命题变元的任何一组真值指派，取值恒为真，则称公式F为重言式，或永真公式，常用1表示。相反，如果对于它所含的命题变元的任何一组真值指派，取值恒为假，则称公式F为矛盾式，或永假公式，常用0表示。如果至少有一组真值指派使公式F的值为真，则称F为可满足式</p>
<ul>
<li><p>重言式的否定是矛盾式；矛盾式的否定是重言式</p>
</li>
<li><p>重言式一定是可满足式</p>
</li>
<li><p>可满足式的否定并非矛盾式</p>
</li>
<li><p>如果公式F在指派A下是真的，则称A满足F，否则称A弄假于F</p>
</li>
</ul>
<p><strong>定理</strong>    若A和B为重言式，则$A\land B,A\lor B$仍是重言式</p>
<h2 id="15-4-命题公式的等价关系"><a href="#15-4-命题公式的等价关系" class="headerlink" title="15.4 命题公式的等价关系"></a>15.4 命题公式的等价关系</h2><h3 id="命题公式的等价"><a href="#命题公式的等价" class="headerlink" title="命题公式的等价"></a>命题公式的等价</h3><p>设A和B是两个命题公式，若$A\to B$为重言式，则称公式A和B是等价的公式，记为$A\Leftrightarrow B(A=B)(A\equiv B)$</p>
<p>当且仅当A和B真值表完全相同时，A和B是等价的公式</p>
<h3 id="命题公式的蕴涵"><a href="#命题公式的蕴涵" class="headerlink" title="命题公式的蕴涵"></a>命题公式的蕴涵</h3><p>设A和B是两个公式，若公式$A\to B$为重言式，即$A\to B\Leftrightarrow 1$，则称公式A蕴涵公式B，记为$A\Rightarrow B$</p>
<p><strong>定理</strong>    设A和B是两个命题公式，$A\Leftrightarrow B$当且仅当$A\Rightarrow B$且$B\Rightarrow A$</p>
<p><strong>定理</strong>    设A,B,C是公式，若$A\Rightarrow B$且$B\Rightarrow C$，则$A\Rightarrow C$</p>
<h2 id="15-5-命题公式的对偶式"><a href="#15-5-命题公式的对偶式" class="headerlink" title="15.5 命题公式的对偶式"></a>15.5 命题公式的对偶式</h2><p>在仅含有联结词$\neg,\land,\lor$的公式A中，若用联结词$\lor$代换$\land$，用$\land$代换$\lor$，用0代换1，用1代换0，则所得的公式称为A的对偶，记作$A^*$</p>
<p><strong>定理</strong>    设A和$A^<em>$互为对偶的两个公式，$P_1,P_2,…,P_n$是其命题变元，则$\neg A(P_1,P_2,…,P_n)\Leftrightarrow A^</em>(\neg P_1,\neg P_2,…,\neg P_n)$</p>
<p><strong>对偶定理</strong>    设$A(P_1,P_2,…,P_n)$和$B(P_1,P_2,…,P_n)$是两个公式，若$A\Leftrightarrow B$，则$A^<em>\Leftrightarrow B^</em>$</p>
<h2 id="15-6-范式"><a href="#15-6-范式" class="headerlink" title="15.6 范式"></a>15.6 范式</h2><h3 id="合取范式和析取范式"><a href="#合取范式和析取范式" class="headerlink" title="合取范式和析取范式"></a>合取范式和析取范式</h3><p>命题变元或命题变元的否定称为文字</p>
<p>有限个文字的合取式称为基本合取式（短语）</p>
<p>有限个文字的析取式称为基本析取式（子句）</p>
<p><strong>定理</strong>    一基本合取式为矛盾式的充要条件是，它同时包含某个命题变元$P$及其否定$\neg P$</p>
<p>​            一基本析取式为重言式的充要条件是，它同时包含某个命题变元$P$及其否定$\neg P$</p>
<p>有限个基本合取式的析取组成的公式称为析取范式，具有形式$A_1\lor A_2\lor …\lor A_n$，其中$A_i$都是基本合取式</p>
<p>有限个基本析取式的析取组成的公式称为合取范式，具有形式$A_1\land A_2\land …\land A_n$，其中$A_i$都是基本析取式</p>
<p>析取范式和合取范式仅含联结词$\neg,\land,\lor$</p>
<p>任何析取范式的对偶式为合取范式，任何合取范式的对偶式为析取范式</p>
<p><strong>范式存在定理</strong>    对于任意公式F，都存在等价于它的析取范式和合取范式</p>
<h3 id="主范式"><a href="#主范式" class="headerlink" title="主范式"></a>主范式</h3><p>设有命题变元$P_1,P_2,…,P_n$，形如$\land_{i=1}^nm_i$的命题公式称为是由命题变元$P_1,P_2,…,P_n$所产生的最小项；而形如$\lor_{i=1}^nM_i$的命题公式称为是由命题变元$P_1,P_2,…,P_n$所产生的最大项。其中每一个$m_i$和$M_i$或为$P_i$或为$\neg P_i$</p>
<h4 id="最小项性质"><a href="#最小项性质" class="headerlink" title="最小项性质"></a>最小项性质</h4><ul>
<li>n个命题变元可构成$2^n$个最小项</li>
<li>任意两个最小项的合取式永为0，即$i\not=j,m_i\land m_j=0$</li>
<li>全体最小项的析取式永为1</li>
<li>每个最小项当其真值指派与编码相同时，其真值为1，其余$2^n-1$种指派情况下均为0</li>
</ul>
<h4 id="最大项性质"><a href="#最大项性质" class="headerlink" title="最大项性质"></a>最大项性质</h4><ul>
<li>n个命题变元可构成$2^n$个最大项</li>
<li>任意两个最大项的析取式永为1，即$i\not=j,M_i\lor M_j=1$</li>
<li>全体最大项的合取式永为0</li>
<li>每个最小项当其真值指派与编码相同时，其真值为0，其余$2^n-1$种指派情况下均为1</li>
</ul>
<p>由不同最小项组成的析取范式称为主析取范式</p>
<p>由不同最大项组成的合取范式称为主合取范式</p>
<p><strong>定理</strong>    每一个不为矛盾式的命题公式$A(P_1,P_2,…P_n)$必与一个$P_1,P_2,…,P_n$所产生的主析取范式等值</p>
<p><strong>定理</strong>    每一个不为重言式的命题公式$A(P_1,P_2,…P_n)$必与一个$P_1,P_2,…,P_n$所产生的主合取范式等价</p>
<h4 id="主范式性质"><a href="#主范式性质" class="headerlink" title="主范式性质"></a>主范式性质</h4><ul>
<li><p>如果命题公式是重言式$\iff$它的主析取范式包含所有极小项$\iff$此时主合取范式为空$\iff$定义它为1</p>
</li>
<li><p>如果命题公式是矛盾式$\iff$它的主合取范式包含所有极大项$\iff$此时主析取范式为空$\iff$定义它为0</p>
</li>
<li><p>两个命题公式是等价的$\iff$它们的主合取范式合主析取范式等价。若主范式非空且无$2^n$项，是可满足式</p>
</li>
<li><p>含有n个命题变元的公式G的主析取范式中最小项项数与G的主合取范式中最大项项数之和为$2^n$项</p>
</li>
<li><p>若G的主析取范式中有最小项$m_i$，则G的主合取范式中一定不含有最大项$M_i$，反之亦然</p>
</li>
</ul>
<p><strong>定理</strong>    设A是包含命题变元$P_1,P_2,…,P_n$的命题公式，若不计其中最小项（最大项）的排列次序则A的主析取范式（主合取范式）是唯一的</p>
<h2 id="15-7-命题演算的推理理论"><a href="#15-7-命题演算的推理理论" class="headerlink" title="15.7 命题演算的推理理论"></a>15.7 命题演算的推理理论</h2><h3 id="推理形式"><a href="#推理形式" class="headerlink" title="推理形式"></a>推理形式</h3><p>设$H_1,H_2,…,H_n$和C是一些命题公式，如果$H_1\land H_2\land…\land H_n\Rightarrow C$则称从前提$H_1,H_2,…,H_n$推出结论C，并称$\{H_1,H_2,…,H_n\}$为C的前提集合</p>
<p>判断$H_1\land H_2\land…\land H_n\rightarrow C$是否为重言式</p>
<h3 id="构造证明"><a href="#构造证明" class="headerlink" title="构造证明"></a>构造证明</h3><p>一个描述推理过程的命题序列，其中每个命题或者是已知的命题，或者是由某些前提所推得的结论，序列中最后一个命题就是所要求的结论，这样的命题序列称为形式证明</p>
<p>前提引入规则(P)，结论引用规则(T)，置换规则，带入规则，等价关系式和蕴涵关系式</p>
<h3 id="蕴含证明"><a href="#蕴含证明" class="headerlink" title="蕴含证明"></a>蕴含证明</h3><p>设P是一组前提的合取，及前提集合，结论为$Q\to R$。如果能够从原结论中的前件Q包括到前提中去作为附加前提，和前提集合P推导出R来，就能够从P推导出$Q\to R$</p>
<h1 id="§16-谓词逻辑"><a href="#§16-谓词逻辑" class="headerlink" title="§16 谓词逻辑"></a>§16 谓词逻辑</h1><h2 id="16-1-谓词和量词"><a href="#16-1-谓词和量词" class="headerlink" title="16.1 谓词和量词"></a>16.1 谓词和量词</h2><h3 id="个体词、个体域和谓词"><a href="#个体词、个体域和谓词" class="headerlink" title="个体词、个体域和谓词"></a>个体词、个体域和谓词</h3><p>可以独立存在的事物称为个体</p>
<blockquote>
<p>具体、特指的个体词称为个体常元</p>
<p>抽象的、泛指的、在一定范围内变化的个体词称为个体变元</p>
</blockquote>
<p>个体变元的取值范围称为个体域，常用D表示</p>
<p>用来刻画个体性质或多个个体之间关系的词称为谓词。谓词中包含个体的数目称为谓词的元数</p>
<blockquote>
<p>有具体确定意义的性质或关系的谓词称为谓词常元，否则称为谓词变元</p>
<p>从数学角度看，谓词是一个以D为定义域，以{1,0}为值域的函数</p>
</blockquote>
<p>由一个谓词和若干个体变元组成的表达式称为简单命题函数</p>
<p>由有限个简单命题函数以及逻辑联结词组成的命题形式称为复合命题函数</p>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><p>表示数量的词为量词</p>
<p>表示“所有”，“任意”，“一切”的词称为全称量词，记为$\forall $。$\forall x$表示对个体域中的所有个体，x称为全称性变元</p>
<p>表示“存在着”，“有某些”，“至少存在一个”的词称为存在量词，记为$\exist$。$\exist x$表示存在个体域中的个体，x称为存在性变元</p>
<h2 id="16-2-谓词合式公式"><a href="#16-2-谓词合式公式" class="headerlink" title="16.2 谓词合式公式"></a>16.2 谓词合式公式</h2><p>由n元谓词P和n个个体变元$x_1,x_2,…,x_n$构成的命题函数$P(x_1,x_2,…,x_n)$称为原子谓词公式</p>
<ul>
<li>任意原子谓词公式都是谓词公式</li>
<li>若A是谓词公式，则也是谓词公式</li>
<li>若A是谓词公式，x是A中的个体变元，则$\forall x\  A$和$\exist x\  A$也是谓词公式</li>
</ul>
<p>谓词公式是由原子谓词公式、命题联结词、量词以及圆括号按照上述规则组成的一个符号串</p>
<p>在谓词公式中，形如$\forall x\ A(x)$或$\exist x\ A(x)$的那一部分称为是公式的x约束部分，而$A(x)$称为是量词$\forall x$或$\exist x$的辖域</p>
<p>x在公式的x约束部分的任一出现都称为x的约束出现；当x的出现不是约束出现时，称x的出现是自由出现。公式中约束出现的变元是约束变元，自由出现的变元是自由变元</p>
<h2 id="16-3-谓词演算等价与范式"><a href="#16-3-谓词演算等价与范式" class="headerlink" title="16.3 谓词演算等价与范式"></a>16.3 谓词演算等价与范式</h2><p>如果对于公式A的任一组指派，公式A的值总是为真，则称A为永真公式；如果对于公式A的任一组指派，公式A的值总是为假，则称A为永假公式；如果至少存在着一组指派，使公式A的值为真，则称A是可满足的公式</p>
<p>设A,B是个体域D上的两个公式，若对于A和B的任意一组指派，两公式都具有相同的真值，则称A和B在D上等值，记作$A\Leftrightarrow B$</p>
<p>对于公式A和B，若$A\to B\Leftrightarrow 1$，则称公式A蕴含公式B，记作$A\Rightarrow B$</p>
<h2 id="16-4-前束范式"><a href="#16-4-前束范式" class="headerlink" title="16.4 前束范式"></a>16.4 前束范式</h2><p>一个谓词公式，如果它的所有量词均非否定地出现在公式地最前面，且它们的辖域一直延伸到公式的末尾，则称这种形式的公式为前束范式。记作$Q_1x_1Q_2x_2…Q_kx_kB$，其中，每个$Q_i$为量词，B为不含量词的谓词公式</p>
<p><strong>定理</strong>    任一谓词公式都可以化成为与之等值的前束范式</p>
<p>前束合取范式，前束析取范式</p>
<p><strong>定理</strong>    每个谓词公式均可以变换为与它等值的前束合取范式和前束析取范式</p>
<h3 id="斯柯林范式"><a href="#斯柯林范式" class="headerlink" title="斯柯林范式"></a>斯柯林范式</h3><p>首标中不含有<strong>存在量词</strong>的前束合取范式称为斯柯林范式</p>
<p><strong>定理</strong>    每个谓词公式A均可以变换为与它等值的斯柯林范式</p>
<h2 id="16-5-谓词演算的推理理论"><a href="#16-5-谓词演算的推理理论" class="headerlink" title="16.5 谓词演算的推理理论"></a>16.5 谓词演算的推理理论</h2><h3 id="全称指定化US规则"><a href="#全称指定化US规则" class="headerlink" title="全称指定化US规则"></a>全称指定化US规则</h3><p>$\forall x\ A(x)\Rightarrow A(y)$</p>
<p>(1)    x为A(x)自由出现的个体变元</p>
<p>(2)    y为任意的不在A(x)中约束出现的个体变元</p>
<p>(3)    自由变元y也可替换成任意个体常元c    </p>
<h3 id="存在指定化ES规则"><a href="#存在指定化ES规则" class="headerlink" title="存在指定化ES规则"></a>存在指定化ES规则</h3><p>$\exists x\ A(x)\Rightarrow A(c)$</p>
<p>(1)    c是使A为真的特定的个体常元</p>
<p>(2)    c不曾在A(x)中出现过</p>
<p>(3)    A(x)中除x外还由其他自由出现的个体变元时，不能用此规则</p>
<h3 id="全称一般化UG规则"><a href="#全称一般化UG规则" class="headerlink" title="全称一般化UG规则"></a>全称一般化UG规则</h3><p>$A(x)\Rightarrow \forall y\ A(y)$</p>
<p>(1)    y在A(y)中自由出现，且y取任何值时A均为真</p>
<p>(2)    取代x的y不能在A(x)中约束出现，否则会出错</p>
<h3 id="存在一般化EG规则"><a href="#存在一般化EG规则" class="headerlink" title="存在一般化EG规则"></a>存在一般化EG规则</h3><p>$A(c)\Rightarrow \exists y\ A(y)$</p>
<p>(1)    c是特定的个体常元</p>
<p>(2)    取代c的x不能已在A(c)中出现过</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Note/">Note</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/SDU/">SDU</a>
                    
                      <a class="hover-with-bg" href="/tags/DiscreteMath/">DiscreteMath</a>
                    
                  </div>
                
              </div>
              <!-- 
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
               -->
              
                <p class="note note-info" style="background: #2e3a49; color: #eee;">
                <strong>本文作者: </strong><a href="/">31</a> <br>
                <strong>本文链接: </strong><a href="http://uuunni.github.io/2022/07/07/DiscreteMathNote/">http://uuunni.github.io/2022/07/07/DiscreteMathNote/</a> <br>
                <strong>版权声明: </strong>本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                </p>
              

              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/07/BasicElectronicCircuitNote/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">SDU电子电路基础笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/07/ComputerNetworkReview/">
                        <span class="hidden-mobile">SDU计算机网络复习笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QJtn4PrebEYsIJPwEkfclcO0-gzGzoHsz","appKey":"kdxH4zfnh96BgUrFbIGbhUVE","path":"window.location.pathname","placeholder":"留下点什么叭... ᶘ ᵒᴥᵒᶅ","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>

<div class="text-center">
  <span id="timeDate">载入天数...</span>
  <span id="times">载入时分秒...</span>
  <script>
  var now = new Date();
  function createtime(){
      var grt= new Date("01/15/2022 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "🚀 for&nbsp"+dnum+"&nbspdays";  //此次自定义显示内容
      document.getElementById("times").innerHTML = hnum + "&nbsphr&nbsp" + mnum + "&nbspmin&nbsp" + snum + "&nbspsec";
  }  //此次自定义显示内容
  setInterval("createtime()",250);
  </script>
</div>

  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  




  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
